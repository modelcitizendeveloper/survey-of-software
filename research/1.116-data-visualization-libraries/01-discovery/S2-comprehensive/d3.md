# D3.js - Technical Architecture

## Core Philosophy

D3 = **Data-Driven Documents**

Unlike other libraries that render charts, D3 provides **primitives** for binding data to DOM and applying transformations.

```javascript
// D3 doesn't "render a bar chart"
// D3 gives you tools to create one yourself

d3.select('svg')
  .selectAll('rect')
  .data([10, 20, 30])
  .join('rect')
    .attr('x', (d, i) => i * 25)
    .attr('height', d => d * 10)
```

## Module Architecture

D3 v7+ is **modular** - 30+ independent packages:

### Data Manipulation
- `d3-array` - Statistics (min, max, mean, quantile, bisect)
- `d3-collection` - Maps, sets, nests
- `d3-random` - Random number generators

### Scales and Axes
- `d3-scale` - Map data → visual values
- `d3-axis` - Generate axis elements
- `d3-time` - Time intervals, formatting

### Shapes and Layouts
- `d3-shape` - Line, area, arc, pie generators
- `d3-chord` - Chord diagrams
- `d3-hierarchy` - Tree layouts, treemaps, partitions
- `d3-force` - Force-directed graph layouts
- `d3-sankey` - Flow diagrams

### DOM Manipulation
- `d3-selection` - Select and manipulate elements
- `d3-transition` - Animated transitions
- `d3-drag` - Drag-and-drop
- `d3-zoom` - Pan and zoom

### Geographic
- `d3-geo` - Map projections
- `d3-geo-projection` - Extended projections

### Utilities
- `d3-fetch` - Load CSV, JSON, etc.
- `d3-format` - Number formatting
- `d3-interpolate` - Interpolation functions
- `d3-ease` - Easing functions

## Selection API (Core Abstraction)

### The Join Pattern

D3's fundamental operation: **data joins**

```javascript
const data = [10, 20, 30, 40]

d3.select('svg')
  .selectAll('circle')  // Select all circles (even if none exist)
  .data(data)           // Bind data
  .join('circle')       // Create/update/remove elements
    .attr('cx', (d, i) => i * 50)
    .attr('cy', 100)
    .attr('r', d => d)
```

**What `.join()` does:**
1. **Enter**: Create missing elements (4 data points, 0 circles → create 4)
2. **Update**: Update existing elements (4 data points, 4 circles → update 4)
3. **Exit**: Remove extra elements (4 data points, 6 circles → remove 2)

### Method Chaining

D3 uses **fluent interface** pattern:

```javascript
selection
  .attr('width', 100)
  .attr('height', 200)
  .style('fill', 'blue')
  .on('click', handler)
```

Each method returns the selection for chaining.

## Scale System

Scales are **pure functions** that map input → output.

### Scale Types

**1. Continuous Scales**
```javascript
// Linear: y = mx + b
const linear = d3.scaleLinear()
  .domain([0, 100])      // Data space
  .range([0, 500])       // Pixel space

linear(50)  // → 250

// Log: y = log(x)
const log = d3.scaleLog()
  .domain([1, 1000])
  .range([0, 500])

// Power: y = x^k
const power = d3.scalePow().exponent(2)

// Time: handles date arithmetic
const time = d3.scaleTime()
  .domain([new Date(2024, 0, 1), new Date(2024, 11, 31)])
  .range([0, 1000])
```

**2. Sequential Scales** (continuous color)
```javascript
const color = d3.scaleSequential(d3.interpolateViridis)
  .domain([0, 100])

color(50)  // → "rgb(72, 130, 145)"
```

**3. Ordinal Scales** (discrete)
```javascript
const category = d3.scaleOrdinal()
  .domain(['A', 'B', 'C'])
  .range(['red', 'green', 'blue'])

category('A')  // → "red"
```

**4. Band Scales** (for bar charts)
```javascript
const x = d3.scaleBand()
  .domain(['Jan', 'Feb', 'Mar'])
  .range([0, 300])
  .padding(0.1)

x('Jan')        // → 0
x.bandwidth()   // → 96 (width of each band)
```

## Shape Generators

Generators create SVG path `d` attributes.

### Line Generator

```javascript
const line = d3.line()
  .x(d => xScale(d.date))
  .y(d => yScale(d.value))
  .curve(d3.curveMonotoneX)  // Smoothing

const pathData = line(data)
// → "M 0,100 L 50,150 L 100,120 ..."
```

**Curve algorithms:**
- `curveLinear` - Straight lines (default)
- `curveBasis` - B-spline (smooth)
- `curveMonotoneX` - Monotone cubic (no overshoots)
- `curveStep` - Step function
- 10+ more curves

### Area Generator

```javascript
const area = d3.area()
  .x(d => xScale(d.date))
  .y0(height)              // Baseline
  .y1(d => yScale(d.value)) // Top line

// Creates filled area under curve
```

### Arc Generator (Pie/Donut)

```javascript
const arc = d3.arc()
  .innerRadius(0)      // 0 = pie, > 0 = donut
  .outerRadius(100)

const pie = d3.pie()
  .value(d => d.value)

const arcs = pie(data)  // Calculates angles
arcs.forEach((d, i) => {
  svg.append('path')
    .attr('d', arc(d))  // arc generates path
    .attr('fill', colors[i])
})
```

## Transition System

Smooth animations between states.

```javascript
d3.selectAll('circle')
  .transition()              // Start transition
  .duration(1000)            // 1 second
  .delay((d, i) => i * 100)  // Stagger
  .ease(d3.easeCubicInOut)   // Easing function
  .attr('r', d => newRadius(d))
```

**Easing Functions:**
- Linear: `easeLinear`
- Quadratic: `easeQuadIn`, `easeQuadOut`, `easeQuadInOut`
- Cubic, Quartic, Quintic, Exponential
- Bounce: `easeBounce`
- Elastic: `easeElastic`
- Back: `easeBack` (overshoots then settles)

**Transition Chaining:**
```javascript
selection
  .transition().duration(500).attr('opacity', 0)
  .transition().duration(500).attr('height', 0)
  .remove()  // Remove after transitions
```

## Force-Directed Layouts

For network graphs, node-link diagrams.

```javascript
const simulation = d3.forceSimulation(nodes)
  .force('charge', d3.forceManyBody().strength(-30))  // Repulsion
  .force('link', d3.forceLink(links).distance(50))    // Attraction
  .force('center', d3.forceCenter(width / 2, height / 2))
  .force('collision', d3.forceCollide().radius(10))   // No overlap

simulation.on('tick', () => {
  // Update node/link positions on each tick
  linkElements.attr('x1', d => d.source.x)
  nodeElements.attr('cx', d => d.x)
})
```

**Forces available:**
- `forceManyBody` - N-body charge (repulsion/attraction)
- `forceLink` - Spring between linked nodes
- `forceCenter` - Pull toward center point
- `forceCollide` - Collision detection
- `forceX` / `forceY` - Pull toward axis
- `forceRadial` - Circular arrangement

## Hierarchy Layouts

For tree structures.

```javascript
const data = {
  name: 'root',
  children: [
    { name: 'child1', children: [...] },
    { name: 'child2' }
  ]
}

const hierarchy = d3.hierarchy(data)

// Tree layout
const tree = d3.tree().size([width, height])
tree(hierarchy)  // Assigns x, y to each node

// Treemap layout
const treemap = d3.treemap().size([width, height])
treemap(hierarchy.sum(d => d.value))  // Assigns x0, y0, x1, y1

// Partition (sunburst)
const partition = d3.partition()
```

## Performance Characteristics

### Benchmark Results

**Rendering 10,000 circles:**
- D3 + SVG: ~150ms (choppy)
- D3 + Canvas: ~15ms (smooth)
- D3 + WebGL: ~2ms (very smooth)

**Key insight:** D3 itself is fast - **SVG is the bottleneck**.

### Canvas Rendering

D3 can target Canvas instead of SVG:

```javascript
const canvas = document.querySelector('canvas')
const ctx = canvas.getContext('2d')

data.forEach(d => {
  ctx.beginPath()
  ctx.arc(xScale(d.x), yScale(d.y), 5, 0, 2 * Math.PI)
  ctx.fill()
})
```

**Trade-off:** No DOM elements = no hover events on individual points.

## Bundle Size

```
d3 (full): 250 KB (uncompressed), ~70 KB gzipped

Modular imports (tree-shaking):
d3-selection: 45 KB → 15 KB gzipped
d3-scale: 85 KB → 25 KB gzipped
d3-shape: 73 KB → 22 KB gzipped
```

**Best practice:** Import only what you need
```javascript
import { scaleLinear } from 'd3-scale'
import { line } from 'd3-shape'
```

## TypeScript Support

**Type Coverage:** Excellent (`@types/d3`)

```typescript
import { ScaleLinear, Selection } from 'd3'

const scale: ScaleLinear<number, number> = d3.scaleLinear()
  .domain([0, 100])
  .range([0, 500])

const svg: Selection<SVGSVGElement, unknown, HTMLElement, any> =
  d3.select<SVGSVGElement, unknown>('svg')
```

**Challenge:** Complex generic types for selections.

## React Integration Challenges

### Anti-Pattern: D3 Controls DOM

```tsx
// DON'T DO THIS
useEffect(() => {
  d3.select(ref.current)
    .selectAll('rect')
    .data(data)
    .join('rect')  // D3 creates/removes elements
}, [data])
```

**Problem:** React doesn't know about DOM changes.

### Best Practice: D3 for Math, React for DOM

```tsx
// DO THIS
const xScale = scaleLinear().domain([0, 100]).range([0, width])
const yScale = scaleLinear().domain([0, 100]).range([height, 0])

return (
  <svg>
    {data.map(d => (
      <circle
        key={d.id}
        cx={xScale(d.x)}
        cy={yScale(d.y)}
        r={5}
      />
    ))}
  </svg>
)
```

This is exactly what **visx** does.

## Key Strengths

1. **Maximum flexibility** - Can create ANY visualization
2. **Modular** - Import only what you need
3. **Battle-tested** - 13 years, 108K GitHub stars
4. **Excellent docs** - Observable notebooks, examples

## Key Limitations

1. **Steep learning curve** - Takes weeks to master
2. **Verbose** - More code than high-level libraries
3. **No built-in charts** - You build everything from scratch
4. **React friction** - Doesn't fit React's declarative model

## When to Use D3

**Ideal for:**
- Custom, novel visualizations
- Full creative control needed
- Complex interactions (brushing, linked views)
- Network graphs, force layouts, geo maps

**Not ideal for:**
- Standard charts (use Recharts)
- Tight deadlines (high-level libs faster)
- Teams new to D3 (steep learning curve)
- React projects (consider visx)
