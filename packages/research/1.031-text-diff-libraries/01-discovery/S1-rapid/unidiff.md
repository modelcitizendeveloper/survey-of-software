# unidiff

## Overview
- **Package**: unidiff (PyPI)
- **Status**: Active (regular updates)
- **Popularity**: ~400 GitHub stars, ~3M PyPI downloads/month
- **Scope**: Diff parser (parses unified/context diff output, doesn't generate diffs)

## Algorithm
- **Core**: Parser for unified diff and context diff formats
- **NOT a diff generator**: Reads existing diffs (from git, diff, etc.)
- **Metadata extraction**: File paths, line numbers, hunks, changes
- **Programmatic access**: Modify, filter, analyze diffs

## Best For
- **Analyzing git diffs**: Parse `git diff` output programmatically
- **Diff filtering**: Remove hunks, skip files, extract changes
- **Code review tools**: Build tooling on top of git diffs
- **CI/CD**: Process diff output in pipelines
- **Diff modification**: Manipulate diffs before applying

## Trade-offs

**Strengths:**
- Very fast (parsing only, no diff computation)
- Low memory (no LCS algorithm, just text processing)
- Clean API (intuitive object model for diffs)
- Stable (mature, well-tested)
- Focused (does parsing well, nothing extra)

**Limitations:**
- Parser only (doesn't generate diffs - use git/difflib for that)
- Unified/context formats only (can't parse other diff formats)
- No patch application (can parse but not apply)
- Limited to line-based diffs (no object/JSON/XML parsing)

## Ecosystem Fit
- **Dependencies**: None (pure Python)
- **Platform**: All (cross-platform)
- **Python**: 3.x
- **Maintenance**: Active (regular updates)
- **Risk**: Very low (focused, stable)

## Quick Verdict
**Not a diff library** - this is for **parsing** diffs generated by other tools (git, difflib, etc.). Use this when you need to analyze or manipulate existing diff output programmatically. Pair with GitPython or difflib for diff generation.
