---
id: 1-115
title: "1.115 Form Validation Libraries"
sidebar_label: "1.115 Form Validation Libraries"
description: "Research on Form Validation Libraries"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# 1.115 Form Validation Libraries



---

<Tabs>
<TabItem value="s1" label="S1: Rapid Discovery" default>

# 1.115 Form & Validation Libraries - S1 Rapid Discovery

## Quick Decision Guide

| Situation | Recommendation |
|-----------|----------------|
| New React project | **React Hook Form + Zod** |
| TypeScript project | React Hook Form + Zod |
| Bundle size critical | React Hook Form + **Valibot** |
| TanStack ecosystem | **TanStack Form** + Zod |
| Existing Formik project | Consider migration to RHF |
| Legacy JavaScript | React Hook Form + Yup |

## 2025 Landscape

### Form Libraries

```
GitHub Stars:
React Hook Form:  ████████████████████████████  38.7K
Formik:           ██████████████████████        33.3K
React Final Form: █████                         7.3K
TanStack Form:    ███                           4K

Weekly Downloads:
React Hook Form:  ████████████████████████████  5M
Formik:           ███████████                   1.9M
React Final Form: ██                            350K
TanStack Form:    █                             50K
```

### Validation Libraries

```
Weekly Downloads:
Zod:     ████████████████████████████████████  12M
Yup:     ████████████████████████              8M
Valibot: ██                                    500K
```

## The Winning Combination: React Hook Form + Zod

This is the **default choice** for React forms in 2025:

```tsx
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { z } from 'zod'

const schema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
})

type FormData = z.infer<typeof schema>

function LoginForm() {
  const { register, handleSubmit, formState: { errors } } = useForm<FormData>({
    resolver: zodResolver(schema),
  })

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register('email')} />
      {errors.email && <span>{errors.email.message}</span>}
      <input type="password" {...register('password')} />
      {errors.password && <span>{errors.password.message}</span>}
      <button type="submit">Login</button>
    </form>
  )
}
```

## Why This Combination Wins

| Aspect | React Hook Form + Zod |
|--------|----------------------|
| Bundle | 12KB + 45KB = 57KB |
| Performance | Uncontrolled (minimal re-renders) |
| TypeScript | First-class (infer types from schema) |
| Validation | Schema-based (reusable, testable) |
| Ecosystem | Huge (resolvers for all validators) |
| Maintenance | Both actively maintained |

## Library Summary

### Form Management

| Library | Bundle | Approach | Status | Best For |
|---------|--------|----------|--------|----------|
| React Hook Form | 12KB | Uncontrolled | Active | Default choice |
| Formik | 44KB | Controlled | Dormant | Legacy projects |
| TanStack Form | ~10KB | Signals | Active | TanStack users |
| React Final Form | ~15KB | Subscription | Dormant | Existing users |

### Validation Schema

| Library | Bundle | TypeScript | Best For |
|---------|--------|------------|----------|
| Zod | 45KB | First-class | Default choice |
| Yup | 60KB | Supported | Legacy/JavaScript |
| Valibot | 1-2KB | First-class | Bundle-sensitive |

## Key Insight: Formik is Dead

Formik was the default for years, but:
- Last commit: over 1 year ago
- GitHub issues: ignored
- No new features
- Larger bundle (44KB vs 12KB)
- Controlled = more re-renders

**Recommendation**: Migrate existing Formik projects to React Hook Form.

## Sources

- [React Hook Form vs Formik - LogRocket](https://blog.logrocket.com/react-hook-form-vs-formik-comparison/)
- [Zod vs Yup - Better Stack](https://betterstack.com/community/guides/scaling-nodejs/yup-vs-zod/)
- [Valibot - Lightweight Zod Alternative](https://blog.logrocket.com/valibot-lightweight-zod-alternative/)
- [TanStack Form](https://tanstack.com/form/latest)


---

# Form & Validation Libraries - Comparison Matrix

## Form Libraries

### Quantitative Comparison

| Library | Stars | Weekly DL | Bundle | Deps | Approach |
|---------|-------|-----------|--------|------|----------|
| React Hook Form | 38.7K | 5M | 12KB | 0 | Uncontrolled |
| Formik | 33.3K | 1.9M | 44KB | 9 | Controlled |
| React Final Form | 7.3K | 350K | 15KB | 2 | Subscription |
| TanStack Form | 4K | 50K | 10KB | 1 | Signals |

### Feature Comparison

| Feature | RHF | Formik | Final Form | TanStack |
|---------|-----|--------|------------|----------|
| TypeScript | ★★★★★ | ★★★ | ★★★ | ★★★★★ |
| Performance | ★★★★★ | ★★★ | ★★★★ | ★★★★★ |
| Bundle Size | ★★★★★ | ★★ | ★★★★ | ★★★★★ |
| Documentation | ★★★★★ | ★★★★ | ★★★ | ★★★★ |
| Maintenance | ★★★★★ | ★ | ★★ | ★★★★★ |
| Ecosystem | ★★★★★ | ★★★★ | ★★★ | ★★★ |

### Maintenance Status

| Library | Last Commit | Status |
|---------|-------------|--------|
| React Hook Form | Days ago | Active |
| Formik | 1+ year ago | **Abandoned** |
| React Final Form | Months ago | Maintenance |
| TanStack Form | Days ago | Active |

## Validation Libraries

### Quantitative Comparison

| Library | Stars | Weekly DL | Bundle | Deps |
|---------|-------|-----------|--------|------|
| Zod | 35K | 12M | 45KB | 0 |
| Yup | 22K | 8M | 60KB | 4 |
| Valibot | 6K | 500K | 1-2KB | 0 |

### Feature Comparison

| Feature | Zod | Yup | Valibot |
|---------|-----|-----|---------|
| TypeScript | ★★★★★ | ★★★ | ★★★★★ |
| Type Inference | ★★★★★ | ★★★ | ★★★★★ |
| Bundle Size | ★★★ | ★★ | ★★★★★ |
| API Simplicity | ★★★★★ | ★★★★ | ★★★★ |
| Ecosystem | ★★★★★ | ★★★★ | ★★★ |
| Performance | ★★★★ | ★★★ | ★★★★★ |

### TypeScript Integration

| Library | Type Inference | Single Source of Truth |
|---------|---------------|------------------------|
| Zod | Excellent | Yes |
| Valibot | Excellent | Yes |
| Yup | Limited | Partial |

## Recommended Combinations

### Default: React Hook Form + Zod (57KB)
```
Best for: Most projects
TypeScript: Excellent
Ecosystem: Huge
Status: Both actively maintained
```

### Bundle Optimized: React Hook Form + Valibot (14KB)
```
Best for: Mobile, slow networks
TypeScript: Excellent
Trade-off: Smaller Valibot ecosystem
Status: Both actively maintained
```

### TanStack: TanStack Form + Zod (~55KB)
```
Best for: TanStack ecosystem users
TypeScript: Excellent
Status: Both actively maintained
```

### Legacy: Formik + Yup (~104KB)
```
Best for: Existing projects only
Trade-off: Abandoned, large bundle
Status: Both in maintenance mode
```

## Decision Matrix

| Situation | Form Library | Validation |
|-----------|--------------|------------|
| New TypeScript project | RHF | Zod |
| Bundle size critical | RHF | Valibot |
| TanStack ecosystem | TanStack Form | Zod |
| Legacy JavaScript | RHF | Yup |
| Existing Formik project | Migrate to RHF | Migrate to Zod |

## Performance Comparison

### Re-renders (10 field form)

```
Per keystroke re-renders:

Formik (controlled):    ████████████████████ 10 (whole form)
React Final Form:       ████ 2 (field + form)
React Hook Form:        █ 0-1 (just validation)
TanStack Form:          █ 0-1 (signal-based)
```

### Bundle Size (Form + Validation)

```
Formik + Yup:           ████████████████████████████████ 104KB
React Hook Form + Yup:  █████████████████████ 72KB
React Hook Form + Zod:  █████████████████ 57KB
TanStack Form + Zod:    ████████████████ 55KB
React Hook Form + Valibot: ████ 14KB
```

## Migration Paths

### Formik → React Hook Form
- Similar concepts, different API
- Gradual migration possible
- Form-by-form replacement

### Yup → Zod
- Nearly identical syntax
- Can coexist during migration
- Minor API differences

### Zod → Valibot
- Codemod available
- Pipe syntax is main difference
- Good for bundle optimization


---

# Formik

> "Build forms in React, without the tears."

## Quick Facts

| Metric | Value |
|--------|-------|
| GitHub Stars | 33,300 |
| npm Weekly Downloads | ~1.9M |
| Bundle Size | 44KB (gzipped) |
| Dependencies | 9 |
| Status | **Maintenance mode** |

## Current Status: Avoid for New Projects

**Important**: Formik is effectively abandoned:
- Last commit: over 1 year ago
- GitHub issues: largely ignored
- No new features or bug fixes
- Creator (Jared Palmer) moved on to other projects

**Recommendation**: Use React Hook Form for new projects. Migrate existing Formik projects when practical.

## Why Formik Was Popular

Formik dominated 2018-2021 because it:
- Simplified form state management
- Integrated well with Yup validation
- Had good documentation
- Was the first major React form library

## How Formik Works

Formik uses **controlled components**:

```tsx
import { Formik, Form, Field, ErrorMessage } from 'formik'
import * as Yup from 'yup'

const schema = Yup.object({
  email: Yup.string().email('Invalid email').required('Required'),
  password: Yup.string().min(8, 'Min 8 chars').required('Required'),
})

function LoginForm() {
  return (
    <Formik
      initialValues={{ email: '', password: '' }}
      validationSchema={schema}
      onSubmit={(values) => console.log(values)}
    >
      <Form>
        <Field name="email" type="email" />
        <ErrorMessage name="email" />

        <Field name="password" type="password" />
        <ErrorMessage name="password" />

        <button type="submit">Submit</button>
      </Form>
    </Formik>
  )
}
```

## Why React Hook Form Is Better

| Aspect | Formik | React Hook Form |
|--------|--------|-----------------|
| Bundle | 44KB | 12KB |
| Dependencies | 9 | 0 |
| Re-renders | Every keystroke | Minimal |
| Maintenance | Abandoned | Active |
| TypeScript | Added later | First-class |
| Performance | Slower | Faster |

### Performance Difference

Formik (controlled):
```
Keystroke → setState → re-render entire form → DOM update
```

React Hook Form (uncontrolled):
```
Keystroke → DOM update only (no React re-render)
```

## Migration Guide

### Basic Form

**Formik:**
```tsx
<Formik initialValues={{ email: '' }} onSubmit={handleSubmit}>
  <Form>
    <Field name="email" />
  </Form>
</Formik>
```

**React Hook Form:**
```tsx
const { register, handleSubmit } = useForm({ defaultValues: { email: '' } })
<form onSubmit={handleSubmit(onSubmit)}>
  <input {...register('email')} />
</form>
```

### With Validation

**Formik + Yup:**
```tsx
<Formik validationSchema={yupSchema}>
```

**React Hook Form + Zod:**
```tsx
useForm({ resolver: zodResolver(zodSchema) })
```

### Accessing Values

**Formik:**
```tsx
<Formik>
  {({ values }) => <span>{values.email}</span>}
</Formik>
```

**React Hook Form:**
```tsx
const { watch } = useForm()
const email = watch('email')
```

## When Formik Might Still Be Used

- Large existing codebase (migration cost too high)
- Team very familiar with Formik
- No performance concerns
- Not actively developing new features

## Resources

- [Official Docs](https://formik.org/)
- [GitHub](https://github.com/jaredpalmer/formik)
- [Migration to RHF](https://react-hook-form.com/get-started#SchemaValidation)


---

# React Hook Form

> "Performant, flexible and extensible forms with easy-to-use validation."

## Quick Facts

| Metric | Value |
|--------|-------|
| GitHub Stars | 38,700 |
| npm Weekly Downloads | ~5M |
| Bundle Size | 12KB (gzipped) |
| Dependencies | Zero |
| License | MIT |

## Why React Hook Form Dominates

React Hook Form is the **clear winner** for React forms in 2025:

1. **Performance**: Uncontrolled components = minimal re-renders
2. **Bundle size**: 12KB vs 44KB (Formik)
3. **Zero dependencies**: No extra baggage
4. **Active maintenance**: Regular updates
5. **TypeScript first**: Excellent type inference

## Core Concept: Uncontrolled Components

Traditional controlled forms re-render on every keystroke:
```tsx
// Controlled (Formik style) - re-renders on every change
const [value, setValue] = useState('')
<input value={value} onChange={e => setValue(e.target.value)} />
```

React Hook Form uses refs (uncontrolled):
```tsx
// Uncontrolled (RHF style) - no re-renders
const { register } = useForm()
<input {...register('email')} />
```

## Basic Usage

```tsx
import { useForm } from 'react-hook-form'

function LoginForm() {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting }
  } = useForm()

  const onSubmit = (data) => console.log(data)

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register('email', { required: 'Email required' })} />
      {errors.email && <span>{errors.email.message}</span>}

      <input
        type="password"
        {...register('password', { minLength: { value: 8, message: 'Min 8 chars' } })}
      />
      {errors.password && <span>{errors.password.message}</span>}

      <button disabled={isSubmitting}>Submit</button>
    </form>
  )
}
```

## Schema Validation (Zod)

```tsx
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { z } from 'zod'

const schema = z.object({
  email: z.string().email('Invalid email'),
  password: z.string().min(8, 'Min 8 characters'),
})

type FormData = z.infer<typeof schema>

function LoginForm() {
  const { register, handleSubmit, formState: { errors } } = useForm<FormData>({
    resolver: zodResolver(schema),
  })
  // ...
}
```

## Key Features

### Form State
```tsx
const { formState } = useForm()
// formState.errors - validation errors
// formState.isDirty - form has been modified
// formState.isValid - all validations pass
// formState.isSubmitting - form is submitting
// formState.isSubmitSuccessful - submission succeeded
```

### Watch Values
```tsx
const { watch } = useForm()
const email = watch('email') // Subscribe to single field
const allValues = watch() // Subscribe to all fields
```

### Reset Form
```tsx
const { reset } = useForm()
reset() // Reset to default values
reset({ email: 'new@email.com' }) // Reset with new values
```

### Field Arrays
```tsx
import { useFieldArray } from 'react-hook-form'

const { fields, append, remove } = useFieldArray({
  control,
  name: 'items',
})
```

## Validation Resolvers

React Hook Form supports multiple validation libraries:

```bash
npm install @hookform/resolvers
```

| Library | Resolver |
|---------|----------|
| Zod | `zodResolver` |
| Yup | `yupResolver` |
| Valibot | `valibotResolver` |
| Joi | `joiResolver` |
| Vest | `vestResolver` |

## When to Choose React Hook Form

**Choose RHF when:**
- Building any React form (it's the default)
- Performance matters
- Want smallest bundle
- Using TypeScript
- Need schema validation

**Consider alternatives when:**
- Using TanStack ecosystem → TanStack Form
- Already have large Formik codebase (migrate gradually)

## Resources

- [Official Docs](https://react-hook-form.com/)
- [GitHub](https://github.com/react-hook-form/react-hook-form)
- [Resolvers](https://github.com/react-hook-form/resolvers)
- [DevTools](https://react-hook-form.com/dev-tools)


---

# Form & Validation Library Recommendation Guide

## Quick Decision Tree

```
Start Here
│
├─ What's your priority?
│  │
│  ├─ Standard React project
│  │  └─ React Hook Form + Zod ✓
│  │
│  ├─ Bundle size critical
│  │  └─ React Hook Form + Valibot ✓
│  │
│  ├─ Using TanStack ecosystem
│  │  └─ TanStack Form + Zod ✓
│  │
│  └─ Legacy JavaScript (no TypeScript)
│     └─ React Hook Form + Yup ✓

├─ Have existing Formik codebase?
│  └─ Plan migration to React Hook Form
│     (Formik is abandoned)
```

## The Default Choice: React Hook Form + Zod

For **90% of React projects**, use this combination:

```tsx
npm install react-hook-form @hookform/resolvers zod
```

**Why this wins:**
- React Hook Form: 12KB, zero deps, best performance
- Zod: TypeScript-first, type inference, 12M downloads/week
- Total: ~57KB (vs 104KB for Formik + Yup)
- Both actively maintained

---

## Recommendation by Scenario

### 1. New React + TypeScript Project

**Recommended**: React Hook Form + Zod

```tsx
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { z } from 'zod'

const schema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
})

type FormData = z.infer<typeof schema>
```

---

### 2. Bundle Size Critical (Mobile, PWA)

**Recommended**: React Hook Form + Valibot

Saves 43KB vs Zod:
- RHF + Zod: 57KB
- RHF + Valibot: 14KB

```tsx
import { useForm } from 'react-hook-form'
import { valibotResolver } from '@hookform/resolvers/valibot'
import * as v from 'valibot'

const schema = v.object({
  email: v.pipe(v.string(), v.email()),
  password: v.pipe(v.string(), v.minLength(8)),
})
```

---

### 3. TanStack Ecosystem User

**Recommended**: TanStack Form + Zod

If you're using TanStack Query, Router, Table:

```tsx
import { useForm } from '@tanstack/react-form'
import { zodValidator } from '@tanstack/zod-form-adapter'

const form = useForm({
  validatorAdapter: zodValidator(),
  // ...
})
```

---

### 4. Legacy JavaScript Project

**Recommended**: React Hook Form + Yup

For non-TypeScript projects where Yup's simpler syntax helps:

```tsx
import { useForm } from 'react-hook-form'
import { yupResolver } from '@hookform/resolvers/yup'
import * as yup from 'yup'

const schema = yup.object({
  email: yup.string().email().required(),
  password: yup.string().min(8).required(),
})
```

---

### 5. Existing Formik Codebase

**Recommended**: Plan migration to React Hook Form

Why migrate:
- Formik is abandoned (no updates in 1+ year)
- 3.6x larger bundle (44KB vs 12KB)
- Worse performance (controlled vs uncontrolled)

Migration strategy:
1. New forms use React Hook Form
2. Migrate existing forms incrementally
3. Replace Yup with Zod as you migrate

---

## What NOT to Do

### Don't Start New Projects with Formik
- Last commit: 1+ year ago
- No bug fixes or features
- Creator moved on

### Don't Use Yup for TypeScript Projects
- Type inference is limited
- Zod does it better
- Smaller bundle

### Don't Build Your Own Validation
- Schema libraries handle edge cases
- Type inference is valuable
- Community-tested

---

## Form vs Validation: Separate Concerns

Form libraries (state management):
- React Hook Form ✓
- TanStack Form
- Formik ✗

Validation libraries (schema + types):
- Zod ✓
- Valibot (bundle-critical)
- Yup (legacy JS)

They work together via **resolvers**:
```tsx
useForm({ resolver: zodResolver(schema) })
useForm({ resolver: valibotResolver(schema) })
useForm({ resolver: yupResolver(schema) })
```

---

## Bundle Size Summary

| Combination | Size | Recommendation |
|-------------|------|----------------|
| RHF + Valibot | 14KB | Bundle-critical |
| TanStack + Zod | 55KB | TanStack users |
| RHF + Zod | 57KB | **Default** |
| RHF + Yup | 72KB | Legacy JS |
| Formik + Yup | 104KB | Avoid |

---

## Final Recommendations

### For Most Projects
**React Hook Form + Zod** - The standard choice

### For Bundle-Sensitive
**React Hook Form + Valibot** - 75% smaller validation

### For TanStack Users
**TanStack Form + Zod** - Ecosystem alignment

### For Legacy JS
**React Hook Form + Yup** - Better than Formik

### Always Avoid
**Formik** - Abandoned, migrate away


---

# TanStack Form

> "Headless, performant, and type-safe form state management."

## Quick Facts

| Metric | Value |
|--------|-------|
| GitHub Stars | ~4,000 |
| npm Weekly Downloads | ~50K |
| Bundle Size | ~10KB |
| Dependencies | 1 (@tanstack/store) |
| License | MIT |
| TypeScript Requirement | v5.4+ |

## What Is TanStack Form?

TanStack Form is the newest entry in the form library space, from the creators of TanStack Query, Router, and Table. It brings the same philosophy: **headless, performant, and framework-agnostic**.

## Key Differentiators

### 1. Signals-Based Architecture

Built on `@tanstack/store`, each field only re-renders when its specific data changes:

```tsx
// Only re-renders when this specific field changes
<form.Field name="email">
  {(field) => <input value={field.state.value} />}
</form.Field>
```

### 2. First-Class TypeScript

Written 100% in TypeScript with automatic type inference:

```tsx
const form = useForm({
  defaultValues: {
    email: '',
    age: 0,
  },
})

// TypeScript knows: email is string, age is number
form.getFieldValue('email') // string
form.getFieldValue('age') // number
```

### 3. Framework Agnostic

Same API across React, Vue, Angular, Solid, and Lit.

## Basic Usage

```tsx
import { useForm } from '@tanstack/react-form'

function LoginForm() {
  const form = useForm({
    defaultValues: {
      email: '',
      password: '',
    },
    onSubmit: async ({ value }) => {
      console.log(value)
    },
  })

  return (
    <form
      onSubmit={(e) => {
        e.preventDefault()
        form.handleSubmit()
      }}
    >
      <form.Field name="email">
        {(field) => (
          <>
            <input
              value={field.state.value}
              onChange={(e) => field.handleChange(e.target.value)}
              onBlur={field.handleBlur}
            />
            {field.state.meta.errors.length > 0 && (
              <span>{field.state.meta.errors[0]}</span>
            )}
          </>
        )}
      </form.Field>

      <button type="submit">Submit</button>
    </form>
  )
}
```

## Validation with Zod

```tsx
import { useForm } from '@tanstack/react-form'
import { zodValidator } from '@tanstack/zod-form-adapter'
import { z } from 'zod'

const form = useForm({
  validatorAdapter: zodValidator(),
  defaultValues: {
    email: '',
  },
})

<form.Field
  name="email"
  validators={{
    onChange: z.string().email('Invalid email'),
    onBlur: z.string().min(1, 'Required'),
  }}
>
  {(field) => /* ... */}
</form.Field>
```

## When to Choose TanStack Form

**Choose TanStack Form when:**
- Already using TanStack ecosystem (Query, Router, Table)
- Want signals-based reactivity
- Building framework-agnostic forms
- TypeScript v5.4+ is available

**Choose React Hook Form instead when:**
- Want larger ecosystem/community
- Need more third-party integrations
- Want simpler API for basic forms

## Comparison with React Hook Form

| Aspect | TanStack Form | React Hook Form |
|--------|--------------|-----------------|
| Architecture | Signals | Refs/Uncontrolled |
| Bundle | ~10KB | 12KB |
| Community | Growing | Huge |
| Ecosystem | Small | Large |
| TypeScript | v5.4+ required | Any |
| Learning curve | Higher | Lower |

## Current Status

TanStack Form is **actively developed** but still maturing:
- Smaller community than RHF
- Fewer tutorials and resources
- API may evolve

For most projects, React Hook Form is still the safer choice. But TanStack Form is worth watching if you're invested in the TanStack ecosystem.

## Resources

- [Official Docs](https://tanstack.com/form/latest)
- [GitHub](https://github.com/TanStack/form)
- [TypeScript Guide](https://tanstack.com/form/latest/docs/typescript)


---

# Valibot

> "The modular and type safe schema library for validating structural data."

## Quick Facts

| Metric | Value |
|--------|-------|
| GitHub Stars | ~6,000 |
| npm Weekly Downloads | ~500K |
| Bundle Size | **1-2KB** (vs 45KB Zod) |
| Dependencies | Zero |
| License | MIT |
| Version | v1.0 (stable) |

## Why Valibot Matters

Valibot is the **bundle-size champion**:
- **90%+ smaller** than Zod for equivalent schemas
- Login form: Zod 13.5KB → Valibot 1.37KB
- Same TypeScript-first approach as Zod

## How It Achieves Small Size

Valibot uses **modular, tree-shakeable architecture**:

```tsx
// Zod - methods chained on objects
import { z } from 'zod'
const schema = z.string().email().min(5)

// Valibot - functions composed in pipelines
import * as v from 'valibot'
const schema = v.pipe(v.string(), v.email(), v.minLength(5))
```

Only imported functions are bundled. Unused validators are tree-shaken away.

## Basic Usage

```tsx
import * as v from 'valibot'

// Primitives
const str = v.string()
const num = v.number()
const bool = v.boolean()

// With validations (using pipe)
const email = v.pipe(v.string(), v.email())
const age = v.pipe(v.number(), v.minValue(0), v.maxValue(120))

// Objects
const UserSchema = v.object({
  name: v.pipe(v.string(), v.minLength(1)),
  email: v.pipe(v.string(), v.email()),
  age: v.optional(v.number()),
})

// Type inference (same as Zod)
type User = v.InferOutput<typeof UserSchema>
```

## Validation

```tsx
// Parse (throws on error)
const user = v.parse(UserSchema, data)

// SafeParse (never throws)
const result = v.safeParse(UserSchema, data)
if (result.success) {
  console.log(result.output)
} else {
  console.log(result.issues)
}
```

## Key Differences from Zod

| Aspect | Zod | Valibot |
|--------|-----|---------|
| API style | Method chaining | Function pipelines |
| Bundle | ~45KB | 1-2KB |
| Tree-shaking | Partial | Full |
| Performance | Good | 2x faster |
| Ecosystem | Larger | Growing |

### Syntax Comparison

```tsx
// Zod
const schema = z.object({
  email: z.string().email().min(5),
  age: z.number().min(0).optional(),
})

// Valibot
const schema = v.object({
  email: v.pipe(v.string(), v.email(), v.minLength(5)),
  age: v.optional(v.pipe(v.number(), v.minValue(0))),
})
```

## Integration with React Hook Form

```tsx
import { useForm } from 'react-hook-form'
import { valibotResolver } from '@hookform/resolvers/valibot'
import * as v from 'valibot'

const schema = v.object({
  email: v.pipe(v.string(), v.email()),
  password: v.pipe(v.string(), v.minLength(8)),
})

type FormData = v.InferOutput<typeof schema>

function Form() {
  const { register, handleSubmit } = useForm<FormData>({
    resolver: valibotResolver(schema),
  })
  // ...
}
```

## When to Choose Valibot

**Choose Valibot when:**
- Bundle size is critical
- Building for mobile/slow networks
- Simple to medium complexity schemas
- Willing to learn slightly different API

**Choose Zod instead when:**
- Bundle size isn't critical
- Want larger ecosystem
- Team already knows Zod
- Need more complex transformations

## Migration from Zod

Valibot provides a [migration guide](https://valibot.dev/guides/migrate-from-zod/) and codemod.

Key changes:
- `z.string().email()` → `v.pipe(v.string(), v.email())`
- `z.infer<>` → `v.InferOutput<>`
- `z.optional()` → `v.optional()`

## Who Uses Valibot

- The Guardian
- React Router
- Rolldown
- 50,000+ dependent GitHub repos

## Resources

- [Official Docs](https://valibot.dev/)
- [GitHub](https://github.com/fabian-hiller/valibot)
- [Comparison with Zod](https://valibot.dev/guides/comparison/)
- [Migration from Zod](https://valibot.dev/guides/migrate-from-zod/)


---

# Yup

> "Schema validation for JavaScript and TypeScript."

## Quick Facts

| Metric | Value |
|--------|-------|
| GitHub Stars | ~22,000 |
| npm Weekly Downloads | ~8M |
| Bundle Size | ~60KB |
| License | MIT |
| Creator | Jason Quense |

## Current Status

Yup remains widely used but **Zod has overtaken it** for TypeScript projects:
- Yup: 8M downloads/week
- Zod: 12M downloads/week

## Why Yup Was Popular

Yup dominated 2018-2022 because:
- First major schema validation for JS
- Excellent Formik integration
- Chainable API (familiar to JS developers)
- Good documentation

## How Yup Works

```tsx
import * as yup from 'yup'

const schema = yup.object({
  email: yup.string().email('Invalid email').required('Required'),
  age: yup.number().min(0).max(120).required(),
  website: yup.string().url().nullable(),
})

// Validate
try {
  const result = await schema.validate(data)
} catch (error) {
  console.log(error.errors) // Array of error messages
}

// Validate sync
const isValid = schema.isValidSync(data)
```

## Yup vs Zod

| Aspect | Yup | Zod |
|--------|-----|-----|
| Bundle | 60KB | 45KB |
| TypeScript | Added later | First-class |
| Type inference | Limited | Excellent |
| API | Chainable | Chainable + functional |
| Async | Built-in | Built-in |
| Popularity | Declining | Rising |

### TypeScript Difference

**Yup** - Types can drift from schema:
```tsx
// Schema
const schema = yup.object({ name: yup.string() })

// Type might not match exactly
type User = yup.InferType<typeof schema>
// Sometimes has issues with optional/nullable
```

**Zod** - Types always match:
```tsx
const schema = z.object({ name: z.string() })
type User = z.infer<typeof schema>
// Always accurate
```

## When to Choose Yup

**Choose Yup when:**
- Legacy JavaScript project (no TypeScript)
- Team already knows Yup
- Using Formik (historical pairing)
- Don't need strict type inference

**Choose Zod instead when:**
- Using TypeScript (always)
- Starting new project
- Want smaller bundle
- Using React Hook Form

## Migration to Zod

Most Yup patterns have direct Zod equivalents:

```tsx
// Yup
yup.string().required()
yup.number().min(0)
yup.object({ name: yup.string() })
yup.array().of(yup.string())

// Zod
z.string().min(1)  // Note: Zod has no required(), use min(1)
z.number().min(0)
z.object({ name: z.string() })
z.array(z.string())
```

## Resources

- [Official Docs](https://github.com/jquense/yup)
- [GitHub](https://github.com/jquense/yup)
- [API Reference](https://github.com/jquense/yup#api)


---

# Zod

> "TypeScript-first schema validation with static type inference."

## Quick Facts

| Metric | Value |
|--------|-------|
| GitHub Stars | ~35,000 |
| npm Weekly Downloads | ~12M |
| Bundle Size | ~45KB |
| Dependencies | Zero |
| License | MIT |
| Creator | Colin McDonnell (2020) |

## Why Zod Dominates

Zod is the **default validation library** for TypeScript projects:

1. **TypeScript-first**: Built for TS from the ground up
2. **Type inference**: `z.infer<typeof schema>` derives types from schema
3. **Single source of truth**: Schema = validation + types
4. **Zero dependencies**: No extra baggage
5. **Ecosystem**: Works with everything (RHF, tRPC, etc.)

## Core Concept: Schema as Types

Traditional approach - duplicate definitions:
```tsx
// Define types
type User = { email: string; age: number }

// Define validation separately (can drift!)
function validate(data: unknown) {
  if (!data.email || !data.age) throw new Error()
}
```

Zod approach - single source of truth:
```tsx
import { z } from 'zod'

// Schema IS the type definition
const UserSchema = z.object({
  email: z.string().email(),
  age: z.number().min(0),
})

// Derive TypeScript type from schema
type User = z.infer<typeof UserSchema>
// { email: string; age: number }

// Validation uses the same schema
const result = UserSchema.safeParse(unknownData)
```

## Basic Usage

```tsx
import { z } from 'zod'

// Primitives
const str = z.string()
const num = z.number()
const bool = z.boolean()
const date = z.date()

// With validations
const email = z.string().email()
const age = z.number().min(0).max(120)
const url = z.string().url()

// Objects
const UserSchema = z.object({
  name: z.string().min(1),
  email: z.string().email(),
  age: z.number().optional(),
})

// Arrays
const TagsSchema = z.array(z.string())

// Enums
const RoleSchema = z.enum(['admin', 'user', 'guest'])

// Union
const IdSchema = z.union([z.string(), z.number()])
// or: z.string().or(z.number())
```

## Validation

```tsx
// Parse (throws on error)
try {
  const user = UserSchema.parse(data)
} catch (error) {
  // ZodError with details
}

// SafeParse (never throws)
const result = UserSchema.safeParse(data)
if (result.success) {
  console.log(result.data) // typed correctly
} else {
  console.log(result.error.issues) // validation errors
}
```

## Key Features

### Custom Error Messages
```tsx
const schema = z.object({
  email: z.string().email({ message: 'Invalid email address' }),
  password: z.string().min(8, { message: 'Password must be at least 8 characters' }),
})
```

### Transformations
```tsx
const schema = z.string().transform((val) => val.toUpperCase())
schema.parse('hello') // 'HELLO'
```

### Refinements
```tsx
const schema = z.string().refine(
  (val) => val.includes('@'),
  { message: 'Must contain @' }
)
```

### Object Manipulation
```tsx
const UserSchema = z.object({
  id: z.string(),
  email: z.string(),
  password: z.string(),
})

// Pick specific fields
const PublicUser = UserSchema.pick({ id: true, email: true })

// Omit fields
const CreateUser = UserSchema.omit({ id: true })

// Make all optional
const PartialUser = UserSchema.partial()

// Extend
const AdminSchema = UserSchema.extend({
  role: z.literal('admin'),
})
```

## Integration with React Hook Form

```tsx
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { z } from 'zod'

const schema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
})

type FormData = z.infer<typeof schema>

function Form() {
  const { register, handleSubmit, formState: { errors } } = useForm<FormData>({
    resolver: zodResolver(schema),
  })
  // ...
}
```

## When to Choose Zod

**Choose Zod when:**
- Using TypeScript (always)
- Want schema as single source of truth
- Need excellent DX and type inference
- Using React Hook Form, tRPC, etc.

**Consider alternatives when:**
- Bundle size is critical → Valibot (1KB vs 45KB)
- Legacy JavaScript project → Yup (more familiar syntax)

## Resources

- [Official Docs](https://zod.dev/)
- [GitHub](https://github.com/colinhacks/zod)
- [Error Handling](https://zod.dev/ERROR_HANDLING)

</TabItem><TabItem value="explainer" label="Explainer">

# Form & Validation Libraries: Domain Explainer

## What Problem Do They Solve?

Forms are deceptively complex. A simple login form requires:
- Tracking input values
- Validation (email format, password length)
- Error messages
- Submit handling
- Loading states
- Preventing double submits
- Accessibility (labels, error announcements)

Multiply by dozens of forms in a real application, and complexity explodes.

## Two Separate Concerns

### 1. Form State Management
Tracking values, dirty state, touched fields, submission status.

Libraries: React Hook Form, Formik, TanStack Form

### 2. Schema Validation
Defining rules (email format, required fields) and checking data against them.

Libraries: Zod, Yup, Valibot

These concerns are **separate but work together**:
```tsx
// Form library handles state
const { register, handleSubmit } = useForm({
  // Validation library handles rules
  resolver: zodResolver(schema)
})
```

## Key Concepts

### Controlled vs Uncontrolled Components

**Controlled**: React state drives the input
```tsx
const [value, setValue] = useState('')
<input value={value} onChange={e => setValue(e.target.value)} />
// Every keystroke: setState → re-render
```

**Uncontrolled**: DOM holds the value, React reads via ref
```tsx
const inputRef = useRef()
<input ref={inputRef} />
// Read value: inputRef.current.value
// No re-renders during typing
```

**Why it matters**: Controlled forms re-render on every keystroke. With 20 fields, that's 20 re-renders per character typed. Uncontrolled is faster.

### Schema Validation

Instead of inline validation:
```tsx
// Inline (hard to reuse, test, maintain)
if (!email.includes('@')) {
  setError('Invalid email')
}
if (password.length < 8) {
  setError('Too short')
}
```

Use declarative schemas:
```tsx
// Schema (reusable, testable, type-safe)
const schema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
})
```

### Type Inference

Modern validation libraries can **derive TypeScript types from schemas**:

```tsx
const schema = z.object({
  email: z.string(),
  age: z.number(),
})

// Automatically: { email: string; age: number }
type FormData = z.infer<typeof schema>
```

This is powerful: define once, get both validation AND types.

### Validation Timing

When to validate?

| Timing | Description | UX |
|--------|-------------|-----|
| onChange | Every keystroke | Annoying for users |
| onBlur | When leaving field | Good balance |
| onSubmit | On form submit | Delayed feedback |
| onTouched | After first interaction + onChange | Common pattern |

Most libraries let you configure this per-field or globally.

### Error Handling Patterns

**Field-level errors**: Each field shows its own error
```tsx
<input {...register('email')} />
{errors.email && <span>{errors.email.message}</span>}
```

**Form-level errors**: Errors shown together (less common)
```tsx
{Object.values(errors).map(err => <li>{err.message}</li>)}
```

**Server errors**: Returned from API, mapped to fields
```tsx
// After API call fails
setError('email', { message: 'Email already exists' })
```

### Field Arrays

Dynamic lists of fields (add/remove items):

```tsx
// Tasks list with add/remove
const { fields, append, remove } = useFieldArray({ name: 'tasks' })

{fields.map((field, index) => (
  <div key={field.id}>
    <input {...register(`tasks.${index}.name`)} />
    <button onClick={() => remove(index)}>Remove</button>
  </div>
))}
<button onClick={() => append({ name: '' })}>Add Task</button>
```

### Nested Objects

Forms often map to nested data structures:

```tsx
const schema = z.object({
  user: z.object({
    name: z.string(),
    address: z.object({
      street: z.string(),
      city: z.string(),
    }),
  }),
})

// Access nested fields
register('user.name')
register('user.address.street')
```

## Common Patterns

### Resolver Pattern

Form libraries use "resolvers" to integrate with any validation library:

```tsx
import { zodResolver } from '@hookform/resolvers/zod'
import { yupResolver } from '@hookform/resolvers/yup'
import { valibotResolver } from '@hookform/resolvers/valibot'

useForm({ resolver: zodResolver(schema) })
useForm({ resolver: yupResolver(schema) })
useForm({ resolver: valibotResolver(schema) })
```

This decouples form state from validation logic.

### Default Values

Initialize forms with existing data (edit forms):

```tsx
const { register } = useForm({
  defaultValues: {
    name: user.name,
    email: user.email,
  },
})
```

### Async Validation

Some validations require API calls:

```tsx
const schema = z.object({
  username: z.string().refine(
    async (val) => {
      const exists = await checkUsernameExists(val)
      return !exists
    },
    { message: 'Username taken' }
  ),
})
```

### Transformations

Modify data during validation:

```tsx
const schema = z.object({
  email: z.string().email().transform(val => val.toLowerCase()),
  age: z.string().transform(val => parseInt(val, 10)),
})
```

## Bundle Size Considerations

Forms add significant JavaScript:

| Combination | Size |
|-------------|------|
| No library (manual) | 0KB |
| React Hook Form only | 12KB |
| RHF + Zod | 57KB |
| RHF + Valibot | 14KB |
| Formik + Yup | 104KB |

For bundle-critical applications, consider:
- Valibot (90% smaller than Zod)
- Lazy loading form-heavy routes
- Server-side validation only for simple forms

## Server vs Client Validation

**Client-side**: Fast feedback, better UX
```tsx
// Immediate feedback as user types
{errors.email && <span>Invalid email</span>}
```

**Server-side**: Security, authoritative
```tsx
// After submit, server checks
const result = await api.submit(data)
if (result.errors) {
  setServerErrors(result.errors)
}
```

**Best practice**: Do both. Client for UX, server for security. Never trust client-only validation for sensitive data.

## Accessibility

Form libraries should handle:
- `aria-invalid` on fields with errors
- `aria-describedby` linking fields to error messages
- Error announcements for screen readers
- Focus management (focus first error on submit)

Most modern libraries handle this automatically.

## Common Misconceptions

### "Forms are simple"
Forms are deceptively complex. Validation, accessibility, async operations, nested data, arrays, error handling - each adds complexity.

### "I can build my own"
You can, but you'll reinvent solutions to solved problems. Libraries encode years of edge cases and best practices.

### "More features = better library"
Sometimes simpler is better. React Hook Form wins partly because it does less (uncontrolled) and performs better.

### "Validation belongs in the form library"
They're separate concerns. Form = state. Validation = rules. The resolver pattern lets you mix and match.

## Evolution of the Space

### 2015-2018: Manual forms, redux-form
Every project rolled their own. Redux-form tried to solve it with Redux.

### 2018-2020: Formik + Yup era
Formik simplified form state. Yup became the default validation. This combo dominated.

### 2020-2022: React Hook Form rises
Performance-focused, uncontrolled approach. Smaller bundle. Overtook Formik.

### 2022-Present: Zod takes over
TypeScript-first validation with type inference. Zod overtook Yup in downloads.

### 2025 Trend
- React Hook Form + Zod is the standard
- Valibot for bundle-sensitive apps
- Formik is abandoned
- TanStack Form emerging

---

**Last Updated**: 2025-12-12
**Related Research**: 1.111 (State Management), 1.113 (UI Components)

</TabItem>
</Tabs>
