---
title: "1.085 Collision Detection Libraries"
weight: 1085
description: "Research on Collision Detection Libraries"
---

# 1.085 Collision Detection Libraries

---

<details open>
<summary>Explainer</summary>

# Collision Detection Libraries: Domain Explainer

## What This Solves

**The problem**: Computers need to know when objects in virtual worlds touch, overlap, or come close to each other.

**Who encounters this**: Anyone building interactive 3D or 2D software where objects move and interact:
- Game developers (characters colliding with walls, projectiles hitting targets)
- Robotics engineers (robots avoiding obstacles, path planning)
- Simulation developers (physics simulations, training environments)
- Creative technologists (interactive art, data visualizations)

**Why it matters**: Without collision detection, objects pass through each other like ghosts. Games feel broken, robots crash into walls, simulations lack realism. Accurate, fast collision detection is essential for believable interactive experiences.

## Accessible Analogies

### The Core Problem: Finding Overlaps in Space

Imagine organizing a large warehouse:
- **Without spatial organization**: To find if two boxes touch, check every box against every other box. With 1,000 boxes, that's nearly 500,000 checks (slow and wasteful).
- **With spatial organization** (collision detection's solution): Group boxes by warehouse section. Only check boxes in nearby sections against each other. Dramatically fewer checks needed.

Collision detection libraries are sophisticated spatial organization systems for virtual objects.

### Broad-Phase vs Narrow-Phase: Two-Step Filtering

**Broad-phase** (Quick Rejection):
> Like sorting mail by postal code before street address. First, eliminate obviously non-overlapping objects using simple bounding boxes. Fast but imprecise.

**Narrow-phase** (Precise Testing):
> Like checking exact apartment numbers after postal code matches. Test precise geometry only for pairs that might actually overlap. Slower but accurate.

This two-phase approach is like searching for a lost item: first check which rooms it could possibly be in (broad-phase), then search carefully in those specific rooms (narrow-phase).

### Continuous vs Discrete Collision Detection

**Discrete collision** (Snapshots):
> Like taking photos every second to see if a baseball hit a window. If the ball moves very fast, it might be on one side of the window in one photo and the other side in the next—you'd miss the collision. This "tunneling" problem happens with fast-moving objects.

**Continuous collision** (Motion Tracking):
> Like recording video instead of photos. Even if the ball moves between frames, you can calculate when it would have hit by analyzing its path. More expensive but catches fast collisions.

Fast projectiles (bullets, racing cars) need continuous collision detection. Slow-moving objects (characters walking, items on shelves) work fine with discrete.

### Shape Representation Trade-offs

**Simple shapes** (Spheres, Boxes):
> Like approximating furniture with rectangular boxes for moving day. Quick calculations, but imprecise—corners stick out, curves are wrong.

**Convex shapes** (Simplified Hulls):
> Like wrapping furniture in tight plastic wrap—follows the outer contour but smooths out details. More accurate than boxes, still reasonably fast.

**Triangle meshes** (Precise Geometry):
> Like the exact furniture shape with every curve and edge. Most accurate but much slower to check collisions. Used for detailed static objects (buildings, terrain).

Different use cases need different accuracy-speed trade-offs.

## When You Need This

### Choose collision detection library when:

**Building games or simulations**:
- Need objects to interact realistically (characters can't walk through walls)
- Physics behavior required (objects bounce, stack, collide)
- Performance critical (60 frames per second requires fast collision checks)

**Robotics applications**:
- Path planning (robot must avoid obstacles)
- Manipulation (robot arm mustn't hit objects while reaching)
- Safety-critical (collision = damage or injury)

**Interactive visualizations**:
- User clicks/touches virtual objects
- Drag-and-drop interfaces with physics
- Data visualization with spatial relationships

### When you DON'T need collision detection library:

**Static scenes**: If nothing moves, no collisions to detect.

**Non-interactive content**: Pure animation or video playback.

**Simple overlap checking**: If just checking if mouse cursor is over a button, basic geometry math suffices—no library needed.

**Turn-based games**: If movement isn't real-time (chess, card games), simple spatial checks work.

## Trade-offs

### Complexity vs Capability

**Simple libraries** (Matter.js):
- **Pros**: Learn in hours, working prototype in minutes
- **Cons**: Limited features, moderate performance, 2D only
- **Use when**: Rapid prototyping, browser games, creative coding

**Mid-tier libraries** (Box2D, Bullet):
- **Pros**: Production-grade features, excellent documentation
- **Cons**: Days to learn, weeks to master
- **Use when**: Serious game development, professional projects

**Advanced libraries** (PhysX):
- **Pros**: Maximum features, GPU acceleration, industry-standard
- **Cons**: Steep learning curve, complex integration
- **Use when**: AAA games, large-scale simulations, enterprise

### Performance vs Accuracy

**Fast, approximate** (Bounding boxes, spheres):
- 100,000+ collision checks per frame possible
- Good enough for many games
- Misses some collisions at corners/edges

**Slow, precise** (Triangle meshes, complex shapes):
- Captures every detail
- Required for robotics (safety-critical)
- May limit number of objects

**Strategic choice**: Use simple shapes where possible (characters, projectiles), detailed shapes only where accuracy critical (terrain, complex environments).

### 2D vs 3D

**2D libraries** (Box2D, Matter.js):
- **Simpler**: Fewer dimensions, easier math
- **Faster**: Less computation required
- **Limited**: Can't do 3D games or simulations

**3D libraries** (Bullet, PhysX):
- **Flexible**: Can simulate 2D via constraints
- **Complex**: More overhead, steeper learning curve
- **Necessary**: For 3D games, robotics, most simulations

**Rule**: Use 2D library for pure 2D projects (simpler, faster). Use 3D library only when actually need 3D.

### Build vs Buy (Library)

**Using existing library**:
- **Pros**: Years of optimization and bug fixes, proven in production
- **Cons**: Learning curve, may have more features than needed

**Building custom collision detection**:
- **Pros**: Perfect fit for exact use case, full control
- **Cons**: Months of development, easy to introduce bugs, ongoing maintenance

**Reality**: Building production-quality collision detection is extremely difficult. Use library unless you have specialized requirements AND expert team.

## Implementation Reality

### Realistic Timeline Expectations

**Prototype** (Proof of concept):
- Simple library (Matter.js): Hours
- Mid-tier library (Box2D): 1-2 days
- Advanced library (PhysX): 3-5 days

**Production-ready** (Shipped product):
- Simple library: 1-2 weeks (tuning, optimization)
- Mid-tier library: 3-6 weeks (integration, edge cases)
- Advanced library: 2-3 months (full integration, optimization, testing)

**Ongoing** (Maintenance, updates):
- Continuous tuning (physics "feel" requires iteration)
- Performance optimization (as scenes grow complex)
- Bug fixes (edge cases appear in production)

### Team Skill Requirements

**Minimum viable**:
- Basic programming (JavaScript, C++, or chosen language)
- Understanding of coordinate systems (X, Y, Z positions)
- Patience for iteration (physics tuning takes time)

**Production-grade**:
- Strong math fundamentals (vectors, basic linear algebra)
- Performance profiling skills
- Debugging complex spatial issues

**Expert-level** (Custom solutions, optimization):
- Advanced mathematics (computational geometry)
- Low-level optimization (SIMD, multi-threading)
- Deep understanding of algorithms (GJK, SAT, etc.)

**Hiring reality**: Finding developers with production collision detection experience is hard. Plan to train internally or hire for underlying skills (math, systems programming) and teach the domain.

### Common Pitfalls and Misconceptions

**Misconception**: "All physics engines are equally fast."
**Reality**: Performance varies 10-100x depending on library, configuration, and use case. Profile your specific scenario.

**Misconception**: "More accurate = better."
**Reality**: Overkill accuracy wastes performance. Balance accuracy with computational budget.

**Misconception**: "Set up once, works forever."
**Reality**: Physics tuning is iterative. Expect weeks of tweaking gravity, friction, damping to feel right.

**Misconception**: "JavaScript is too slow for physics."
**Reality**: WebAssembly (Rapier) achieves near-native performance in browsers. Pure JavaScript (Matter.js) works fine for moderate complexity.

**Pitfall**: Choosing 3D engine for 2D game.
**Fix**: Use 2D-specific library (Box2D)—simpler and faster.

**Pitfall**: Not enabling continuous collision detection for fast objects.
**Fix**: Enable CCD for bullets, vehicles, fast-moving objects to prevent tunneling.

**Pitfall**: Using complex mesh shapes everywhere.
**Fix**: Use simple primitives (spheres, boxes) where possible. Reserve meshes for static environment.

### First 90 Days: What to Expect

**Weeks 1-2**: Learning library basics
- Set up development environment
- Run example programs
- Understand basic concepts (bodies, shapes, collisions)

**Weeks 3-4**: Building first prototype
- Integrate library into your application
- Create simple scene with collision detection
- Basic interaction working but not polished

**Weeks 5-8**: Iteration and tuning
- Performance profiling and optimization
- Physics "feel" tuning (gravity, friction, bounce)
- Edge case bug fixing (objects stuck, explosions, instability)

**Weeks 9-12**: Production polish
- Advanced features (continuous collision, complex shapes)
- Integration with rendering, gameplay, AI
- Stress testing (many objects, worst-case scenarios)

**Reality check**: Most projects underestimate physics integration time by 2-3x. Budget accordingly.

## Summary

Collision detection libraries solve the fundamental problem of detecting when virtual objects overlap or come close together. Essential for games, robotics, and simulations, these libraries range from simple browser tools (Matter.js) to industrial-grade engines (PhysX).

Choose based on your context: 2D vs 3D, performance requirements, team expertise, and platform. Start with simpler libraries unless you know you need advanced features. Expect significant tuning time—physics "feel" is as much art as engineering.

Production-quality collision detection is hard to build from scratch. Use existing libraries unless you have specialized requirements and expert team. Even then, starting with an existing library and customizing is often faster than building from zero.

</details>
<details>
<summary>S1: Rapid Discovery</summary>

# S1: Rapid Discovery Approach

## Research Method

This pass focuses on speed and ecosystem-driven discovery to identify the most established collision detection libraries across programming languages.

## Selection Criteria

1. **Popularity metrics** - GitHub stars, community size, production usage
2. **Language coverage** - Libraries representing major programming languages
3. **Active maintenance** - Recent commits, ongoing development
4. **Production readiness** - Battle-tested in real applications

## Scope

This rapid pass covers:
- Pure collision detection libraries
- Physics engines with strong collision detection components
- Spatial indexing libraries used for broad-phase collision detection
- Language-specific implementations (C++, Rust, Python, JavaScript, Java)

## Libraries Identified

### High-Performance Native
- **FCL** (C++) - Flexible Collision Library
- **Bullet** (C++) - Physics engine with collision detection
- **PhysX** (C++) - NVIDIA's enterprise-grade physics/collision system
- **Box2D** (C++) - Mature 2D collision and physics

### Modern Alternatives
- **Rapier** (Rust) - High-performance 2D/3D for modern applications

### Web & Mobile
- **Matter.js** (JavaScript) - Browser-based 2D physics
- **p2.js** (JavaScript) - JavaScript 2D physics with multiple detection methods
- **box-intersect** (JavaScript) - Fast axis-aligned bounding box detection

### Specialized
- **dyn4j** (Java) - Pure Java 2D collision and physics
- **python-fcl** (Python) - Python bindings for FCL

## Discovery Strategy

Each library file includes:
- **Speed indicators** - Performance characteristics and benchmarks
- **Maturity** - Age, GitHub stars, maintenance status
- **Best for** - Primary use cases and strengths
- **Trade-offs** - Key limitations or constraints

---

# box-intersect

## Overview

Ultra-fast axis-aligned bounding box (AABB) intersection library for JavaScript, optimized for detecting overlaps in large sets of boxes.

## Key Stats

- **npm downloads**: ~200k/week
- **Language**: JavaScript
- **Maturity**: Stable (specialized library)
- **License**: MIT

## Performance Profile

- **Speed**: 25-50% faster than grid-based approaches
- **Dimensions**: Supports 2D and higher dimensions
- **Algorithm**: Optimized sweep-and-prune with specialized data structures
- **Scalability**: Handles large box sets efficiently

## Core Capabilities

- **Collision detection**:
  - AABB intersection testing
  - Batch processing of large box sets
  - Returns all overlapping pairs
- **Limitations**:
  - Only axis-aligned boxes (no rotation)
  - No narrow-phase (requires additional libraries for precise collision)
  - No physics simulation

## Ecosystem

- **Usage**: Broad-phase in custom collision systems, spatial indexing, game engines
- **Integration**: Often used as building block in larger systems
- **Use cases**: Large-scale particle systems, spatial queries, collision culling

## Best For

- **Broad-phase collision detection** in custom engines
- **Large-scale simulations** with thousands of objects
- **Spatial indexing** and querying systems
- **Performance-critical** applications needing fast AABB tests
- **Building blocks** for custom collision detection pipelines

## Trade-offs

**Strengths**:
- Extremely fast for its specific purpose
- Low overhead and minimal API
- Handles large numbers of boxes efficiently
- Works in any dimension (2D, 3D, higher)
- Focused, does one thing very well

**Limitations**:
- AABB only (no oriented bounding boxes or arbitrary shapes)
- No narrow-phase collision detection
- No physics or collision response
- Requires additional libraries for complete collision system
- Not a full-featured solution

## When to Choose box-intersect

Choose box-intersect when:
- Building custom collision detection system
- Need optimized broad-phase for large numbers of objects
- Working with spatial queries and culling
- Performance is critical and AABB suffices
- Integrating collision detection into existing architecture
- Don't need full physics engine overhead

---

# Box2D

## Overview

Mature, reference-quality 2D physics engine with excellent collision detection. Version 3.0 (2024) rewrote the engine in C with major performance improvements.

## Key Stats

- **Language**: C (v3.0), C++ (v2.x)
- **Maturity**: Industry reference (15+ years, extremely well-documented)
- **License**: MIT (changed from zlib in v2.4)

## Performance Profile

- **Speed**: Reference standard for 2D (v3.0 significantly faster than v2.x)
- **Dimensions**: 2D only
- **Algorithms**: Incremental sweep-and-prune broad-phase, SAT, continuous collision detection
- **Parallelization**: Multi-threaded in v3.0

## Core Capabilities

- **Collision detection**:
  - Discrete and continuous collision detection
  - Sensors (overlap detection without physics response)
  - Contact callbacks with detailed collision information
  - Stable contact solver prevents tunneling
- **Supported geometries**:
  - Circles
  - Convex polygons
  - Edge chains
  - Capsules (pills)

## Ecosystem

- **Language ports/wrappers**: JavaScript (Box2D.js), C#, Java, Python, ActionScript
- **Usage**: Unity 2D, SpriteKit (iOS), countless indie games
- **Forks**: LiquidFun (Google, adds fluids)
- **Integration**: Godot, LibGDX, Phaser, Unity
- **Community**: Massive, with extensive tutorials and examples

## Best For

- **2D game development** (platformers, puzzle games, top-down games)
- **Mobile games** with 2D physics requirements
- **Learning physics engines** (cleanly written, excellent documentation)
- **Browser games** (via JavaScript ports)
- **Prototyping** 2D physics concepts

## Trade-offs

**Strengths**:
- Reference-quality implementation (clean, well-documented)
- v3.0 rewrite delivers major performance gains
- Stable solver, excellent for stacking and complex scenes
- Continuous collision detection prevents fast-object tunneling
- Massive ecosystem and community knowledge
- Proven in thousands of shipped games

**Limitations**:
- 2D only (not suitable for 3D applications)
- No built-in spatial queries for arbitrary shapes
- v3.0 API changes require migration from v2.x
- Limited to rigid body physics (no soft bodies or fluids in core)

## When to Choose Box2D

Choose Box2D when:
- Building any 2D game with physics requirements
- Need stable, predictable collision and physics behavior
- Want extensive documentation and community support
- Require continuous collision detection for 2D fast-moving objects
- Need proven reliability (it's the 2D reference standard)
- Working with game engines that integrate Box2D

---

# Bullet Physics

## Overview

Comprehensive physics engine with advanced collision detection, used in AAA games, visual effects, and robotics. Can be used standalone as a collision detection library.

## Key Stats

- **GitHub Stars**: 12.3k
- **Language**: C++
- **Maturity**: Battle-tested (15+ years, used in major games and films)
- **License**: zlib

## Performance Profile

- **Speed**: Near-PhysX CPU performance (5-8x faster than older alternatives)
- **Dimensions**: 2D and 3D
- **Algorithms**: GJK, EPA, SAT, continuous collision detection
- **Broad-phase**: Multiple options (SAP, DBVT)

## Core Capabilities

- **Collision detection modes**:
  - Discrete collision detection
  - Continuous collision detection (CCD) for fast-moving objects
  - Raycast, sweep tests, overlap queries
- **Supported geometries**:
  - Primitives (sphere, box, cylinder, cone)
  - Convex hulls
  - Concave triangle meshes
  - Compound shapes

## Ecosystem

- **Language bindings**: Python (PyBullet), C#, Java
- **Usage**: Commercial games, VFX, robotics simulation
- **Integration**: Unity, Blender, Maya, ROS
- **Community**: Large, active ecosystem

## Best For

- **Game development** requiring both physics and collision detection
- **Robotics simulation** (PyBullet for reinforcement learning)
- **VFX production** with physics requirements
- **Applications** needing continuous collision detection

## Trade-offs

**Strengths**:
- Production-grade stability and performance
- Can use collision detection without full physics simulation
- Extensive documentation and examples
- Multi-platform support
- Large community and integrations

**Limitations**:
- Complex API for simple collision-only use cases
- Large codebase if you only need collision detection
- Learning curve steeper than specialized libraries
- Overkill for 2D-only applications

## When to Choose Bullet

Choose Bullet when:
- Building games or simulations requiring physics + collision
- Need continuous collision detection for fast-moving objects
- Want production-tested reliability
- Require Python bindings (PyBullet) for robotics/ML
- Need extensive shape support including concave meshes

---

# dyn4j

## Overview

Pure Java 2D collision detection and physics engine, designed to be fast, stable, and easy to use without native dependencies.

## Key Stats

- **GitHub Stars**: 280+
- **Language**: 100% Java
- **Maturity**: Stable (10+ years of development)
- **License**: BSD-3-Clause

## Performance Profile

- **Speed**: Good Java performance (within JVM constraints)
- **Dimensions**: 2D only
- **Algorithms**: SAT, GJK, EPA for collision detection
- **Broad-phase**: Dynamic AABB tree

## Core Capabilities

- **Collision detection**:
  - Broad-phase and narrow-phase detection
  - Continuous collision detection
  - Ray casting and shape casting
  - Convex shape support
- **Supported geometries**:
  - Circles
  - Polygons (convex)
  - Segments
  - Capsules
  - Composite shapes

## Ecosystem

- **Platform**: JVM (Java, Kotlin, Scala)
- **Usage**: Desktop Java games, Android games, simulations
- **Integration**: LibGDX, custom Java game engines
- **Documentation**: Comprehensive API docs and tutorials

## Best For

- **Java desktop games** requiring 2D physics
- **Android game development** without NDK
- **Educational projects** in Java
- **Applications** requiring pure Java (no native dependencies)
- **Server-side physics** (headless JVM simulation)

## Trade-offs

**Strengths**:
- Pure Java (no JNI or native libraries)
- Cross-platform JVM compatibility
- Clean, well-documented API
- Active maintenance
- Good performance within Java constraints
- Suitable for Android without NDK complexity

**Limitations**:
- Java performance ceiling (slower than C++ engines)
- 2D only
- Smaller community than Box2D or Matter.js
- Limited to JVM ecosystem
- Not suitable for performance-critical 3D or large-scale simulations

## When to Choose dyn4j

Choose dyn4j when:
- Building Java desktop or Android games
- Require pure Java without native dependencies
- Need server-side physics simulation on JVM
- Want clean Java API without JNI complexity
- Working with LibGDX or Java game frameworks
- Performance requirements fit within JVM constraints

---

# FCL (Flexible Collision Library)

## Overview

C++ library for collision detection and distance computation, supporting both geometric primitives and arbitrary triangle meshes.

## Key Stats

- **GitHub Stars**: 1.6k
- **Language**: C++
- **Maturity**: Established (research origins from UNC Chapel Hill)
- **License**: BSD-3-Clause

## Performance Profile

- **Speed**: High-performance C++ implementation
- **Dimensions**: 2D and 3D
- **Algorithms**: Hierarchical bounding volumes, GJK for convex shapes
- **Broad-phase**: Dynamic AABB tree

## Core Capabilities

- **Collision detection**: Detects overlaps, returns all overlapping triangles
- **Distance queries**: Computes minimum distance between model pairs
- **Supported geometries**:
  - Primitives (boxes, spheres, cylinders)
  - Arbitrary triangle meshes
  - Convex hulls

## Ecosystem

- **Python bindings**: python-fcl (BerkeleyAutomation)
- **Usage**: Robotics, path planning, manipulation research
- **Integration**: Used in robotics frameworks

## Best For

- **Robotics applications** requiring precise collision and distance queries
- **Path planning** systems
- **Research projects** needing validated collision detection
- **Applications** requiring both collision and proximity information

## Trade-offs

**Strengths**:
- Accurate distance computation (not just collision yes/no)
- Well-documented and cleanly implemented
- Proven in academic and robotics contexts
- Python bindings available

**Limitations**:
- Smaller ecosystem compared to full physics engines
- No physics simulation (collision detection only)
- Setup complexity for basic game development needs
- Less community content compared to game engines

## When to Choose FCL

Choose FCL when:
- You need accurate distance computation, not just collision detection
- Working on robotics or path planning
- Require precise geometric queries without full physics simulation
- Need C++ performance with optional Python access

---

# Matter.js

## Overview

Popular 2D physics engine for JavaScript, designed for browser-based games and interactive visualizations with an emphasis on ease of use.

## Key Stats

- **GitHub Stars**: 16.5k+
- **Language**: JavaScript
- **Maturity**: Established (active since 2014)
- **License**: MIT

## Performance Profile

- **Speed**: ~40% of Box2D.js performance
- **Dimensions**: 2D only
- **Algorithms**: Broad-phase detection with SAT narrow-phase
- **Browser-optimized**: Designed specifically for web environments

## Core Capabilities

- **Collision detection**:
  - Broad-phase detection using spatial hashing
  - SAT-based narrow-phase collision
  - Collision callbacks and events
  - Sensors for trigger areas
- **Supported geometries**:
  - Circles
  - Convex polygons
  - Compound bodies (combine shapes)
- **Notable**: No continuous collision detection (fast objects may tunnel through thin objects)

## Ecosystem

- **Integration**: p5.js, Phaser, native DOM
- **Usage**: Browser games, data visualization, creative coding, educational projects
- **Tooling**: Matter Tools for debugging and visualization
- **Community**: Large creative coding community

## Best For

- **Browser-based games** and interactive experiences
- **Creative coding** and generative art with physics
- **Data visualization** with physical interactions
- **Educational projects** teaching physics concepts
- **Rapid prototyping** of 2D physics ideas
- **Projects prioritizing ease of use** over maximum performance

## Trade-offs

**Strengths**:
- Very accessible API, gentle learning curve
- Excellent documentation with interactive demos
- Browser-native (no compilation or build tools required)
- Active community with many examples
- Good for creative coding and visualization
- Integrated debugging and visualization tools

**Limitations**:
- ~40% slower than Box2D.js
- No continuous collision detection (tunneling can occur)
- Limited to convex shapes (concave requires decomposition)
- Less accurate than Box2D for complex stacking
- Not suitable for performance-critical simulations

## When to Choose Matter.js

Choose Matter.js when:
- Building browser-based 2D games or interactions
- Prioritizing developer experience and ease of use
- Working on creative coding or data visualization
- Need rapid prototyping with simple API
- Don't require maximum performance or accuracy
- Want pure JavaScript without WebAssembly complexity
- Teaching or learning physics engine concepts

---

# p2.js

## Overview

Feature-rich 2D physics engine for JavaScript with multiple collision detection algorithms, designed for flexibility and educational value.

## Key Stats

- **GitHub Stars**: 2.6k+
- **Language**: JavaScript
- **Maturity**: Stable (established library)
- **License**: MIT

## Performance Profile

- **Speed**: Moderate (cold start performance similar to brute force)
- **Dimensions**: 2D only
- **Algorithms**: Multiple options - brute force, sweep-and-prune, grid-based
- **Broad-phase flexibility**: Choose algorithm based on use case

## Core Capabilities

- **Collision detection**:
  - Three broad-phase algorithms (brute force, sweep-and-prune, grid)
  - SAT for narrow-phase
  - Extensive collision callbacks
  - Sensors and collision groups
- **Supported geometries**:
  - Circles
  - Convex polygons
  - Planes
  - Capsules
  - Particles
- **Physics features**:
  - Constraints (revolute, prismatic, distance, etc.)
  - Springs and damping
  - Friction and restitution

## Ecosystem

- **Integration**: Phaser, PixiJS, standalone
- **Usage**: Browser games, physics demos, educational projects
- **Documentation**: Good API documentation with examples
- **Community**: Solid user base in web game development

## Best For

- **Browser games** needing varied physics features
- **Educational projects** demonstrating collision detection algorithms
- **Applications** requiring specific broad-phase algorithm selection
- **Games** with diverse physics constraints (vehicles, ragdolls, buoyancy)
- **Projects** using Phaser game framework

## Trade-offs

**Strengths**:
- Multiple collision detection algorithms to choose from
- Rich constraint system for complex physics
- Educational value (see algorithm options directly)
- Good demos showing capabilities (vehicles, ragdolls, buoyancy)
- Well-integrated with Phaser

**Limitations**:
- Sweep-and-prune has cold-start performance issues
- Generally slower than optimized alternatives
- Less polished developer experience than Matter.js
- Smaller community than Matter.js
- Performance varies significantly by algorithm choice

## When to Choose p2.js

Choose p2.js when:
- Using Phaser game framework
- Need rich constraint system (vehicles, machinery, ragdolls)
- Want to experiment with different collision detection algorithms
- Educational context (teaching collision detection approaches)
- Require specific features like buoyancy simulation
- Building browser game with complex physics interactions

---

# NVIDIA PhysX

## Overview

Enterprise-grade physics engine with GPU acceleration capabilities, widely used in commercial game development and industrial simulation.

## Key Stats

- **GitHub Stars**: 3.5k+ (NVIDIA-Omniverse/PhysX)
- **Language**: C++
- **Maturity**: Industry standard (20+ years, AAA game production)
- **License**: BSD-3-Clause (open source since 2018)

## Performance Profile

- **Speed**: Industry-leading CPU performance, GPU acceleration available
- **Dimensions**: 3D (with 2D support via constraints)
- **Algorithms**: GJK, EPA, SDF-based collision for non-convex shapes
- **Broad-phase**: Advanced spatial partitioning with multi-threading
- **GPU support**: CUDA-based GPU acceleration for massive simulations

## Core Capabilities

- **Collision detection**:
  - Signed Distance Field (SDF) collision for non-convex shapes (no decomposition)
  - Continuous collision detection
  - Spatial queries (raycast, overlap, sweep) with customizable filtering
- **Supported geometries**:
  - All primitives
  - Convex decomposition
  - Triangle meshes
  - Height fields
  - SDF representations

## Ecosystem

- **Platform support**: Windows, Linux, Android, iOS, PlayStation, Xbox
- **Usage**: Unreal Engine, Unity (optional), commercial games, industrial robotics
- **Integration**: Major game engines, simulation platforms
- **Language bindings**: C++, C#, limited Python community projects

## Best For

- **AAA game development** with performance requirements
- **Industrial simulation** (robotics, automotive, manufacturing)
- **Large-scale scenes** requiring GPU acceleration
- **Professional projects** needing multi-platform consistency
- **Advanced features** like SDF collision and soft body dynamics

## Trade-offs

**Strengths**:
- Industry-leading performance and stability
- GPU acceleration for massive simulations
- Multi-platform console and mobile support
- SDF collision eliminates convex decomposition pain
- Open source with NVIDIA support
- PhysX 5 includes Flex (fluids, cloth) and Blast (destruction)

**Limitations**:
- Complex API, steep learning curve
- Heavy dependency for simple projects
- GPU features require CUDA (NVIDIA hardware)
- C++ focused, limited high-level language bindings
- Overkill for 2D or simple collision detection

## When to Choose PhysX

Choose PhysX when:
- Targeting game consoles or mobile platforms
- Need GPU-accelerated physics for large-scale simulations
- Require industrial-grade simulation accuracy
- Building with Unreal Engine or need that level of capability
- Need advanced features (fluids, cloth, destruction)
- Want proven enterprise support and long-term stability

---

# Rapier

## Overview

Modern high-performance 2D and 3D physics engine written in 100% Rust, offering performance competitive with PhysX and Box2D.

## Key Stats

- **GitHub Stars**: 3.7k+
- **Language**: Rust (with WebAssembly, JavaScript, and Bevy bindings)
- **Maturity**: Production-ready (2020+, actively developed)
- **License**: Apache-2.0

## Performance Profile

- **Speed**: 5-8x faster than nphysics, competitive with PhysX CPU and Box2D
- **Dimensions**: Separate 2D (rapier2d) and 3D (rapier3d) libraries
- **Algorithms**: GJK, EPA, advanced broad-phase detection
- **Parallelization**: SIMD optimizations, optional multi-threading
- **Cross-platform**: Native and WebAssembly (browser)

## Core Capabilities

- **Collision detection**:
  - Broad-phase and narrow-phase collision detection
  - Contact and intersection events
  - Sensors for trigger volumes
  - Scene queries (ray-casting, shape-casting, intersection tests)
- **Supported geometries**:
  - All standard primitives
  - Convex polyhedra
  - Triangle meshes
  - Height fields

## Ecosystem

- **Language bindings**: JavaScript/TypeScript (via WASM), Bevy (Rust game engine)
- **Usage**: Rust game development, WebAssembly games, robotics
- **Integration**: Bevy game engine (official physics plugin)
- **Community**: Growing Rust gamedev community

## Best For

- **Rust applications** requiring native performance
- **WebAssembly games** needing high-performance physics in browsers
- **Bevy game engine** projects (official physics solution)
- **Cross-platform development** targeting native and web
- **Projects prioritizing memory safety** without garbage collection

## Trade-offs

**Strengths**:
- Rust memory safety guarantees
- Near-PhysX performance without C++ complexity
- Excellent WebAssembly support
- Modern API design
- Active development and responsive maintainers
- Strong performance in both 2D and 3D

**Limitations**:
- Smaller ecosystem compared to Box2D/Bullet/PhysX
- Rust-only native implementation (though WASM provides JS access)
- Fewer tutorials and learning resources
- Less mature than 15+ year old engines
- Limited integrations outside Rust ecosystem

## When to Choose Rapier

Choose Rapier when:
- Building games or simulations in Rust
- Targeting WebAssembly for browser-based physics
- Using Bevy game engine
- Want modern performance without C++ complexity
- Need memory-safe physics engine
- Require competitive performance with PhysX/Box2D
- Prefer actively developed modern libraries over legacy options

---

# S1 Rapid Recommendation

## Decision Matrix

| Language/Platform | Best Overall Choice | Performance Leader | Ease of Use |
|-------------------|---------------------|-------------------|-------------|
| **C++ / 3D** | Bullet | PhysX (GPU) | FCL (collision-only) |
| **C++ / 2D** | Box2D v3 | Box2D v3 | Box2D v3 |
| **Rust** | Rapier | Rapier | Rapier |
| **JavaScript / Browser** | Matter.js | Rapier (WASM) | Matter.js |
| **Java / Android** | dyn4j | dyn4j | dyn4j |
| **Python** | python-fcl | python-fcl | python-fcl |

## Quick Selection Guide

### By Use Case

**AAA Game Development**
→ **PhysX** (console/mobile), **Bullet** (cross-platform CPU)

**Indie 2D Games**
→ **Box2D** (any platform with wrappers)

**Browser Games / Creative Coding**
→ **Matter.js** (ease of use), **Rapier** (performance via WASM)

**Robotics / Path Planning**
→ **FCL** (C++), **python-fcl** (Python), **Bullet** (full simulation)

**Mobile Games**
→ **Box2D** (2D), **Bullet** (3D), **dyn4j** (Java/Android pure)

**Rust Ecosystem**
→ **Rapier** (modern, high-performance)

**Broad-Phase Only**
→ **box-intersect** (JavaScript AABB), custom spatial indexing (R-tree, Quadtree)

### By Priority

**Performance Above All**
1. PhysX (with GPU)
2. Rapier (CPU, modern)
3. Bullet (proven, multi-platform)
4. Box2D v3 (2D only)

**Ease of Integration**
1. Matter.js (JavaScript)
2. Box2D (extensive wrappers)
3. Rapier (Rust + WASM)
4. Bullet (Python via PyBullet)

**Production Stability**
1. Box2D (15+ years, reference quality)
2. PhysX (20+ years, AAA proven)
3. Bullet (15+ years, battle-tested)
4. Matter.js (10+ years, stable)

**Modern Development**
1. Rapier (Rust, 2020+)
2. PhysX 5 (recent major update)
3. Box2D v3 (2024 rewrite)
4. Matter.js (actively maintained)

## Common Pitfalls

❌ **Don't** use full physics engine if you only need collision detection
→ Consider FCL or box-intersect for collision-only requirements

❌ **Don't** use 3D engine for pure 2D games
→ Box2D and 2D-specific engines are significantly simpler and faster

❌ **Don't** assume JavaScript = slow
→ Rapier via WASM approaches native performance in browsers

❌ **Don't** ignore continuous collision detection needs
→ Fast-moving objects require CCD (Bullet, PhysX, Box2D, Rapier)

❌ **Don't** pick based on GitHub stars alone
→ Box2D (smaller stars) is more mature than Matter.js (larger stars)

## Migration Paths

**Prototyping → Production**
- Matter.js → Rapier (WASM) for browser games
- PyBullet → Bullet C++ for production systems
- Box2D v2 → Box2D v3 (API changes, but worth it)

**Language Changes**
- Python prototype → C++ (Bullet/FCL) for performance
- JavaScript → Rust (Rapier) for native + web
- Java → C++ (Bullet) for maximum performance

## Summary: The Safe Bets

**New project, unsure? Start with:**
- 2D game: **Box2D** (any language via wrappers)
- 3D game: **Bullet** (proven) or **PhysX** (cutting-edge)
- Browser: **Matter.js** (easy) or **Rapier** (fast)
- Rust: **Rapier** (only serious option)
- Robotics: **FCL** or **Bullet**

These libraries have the ecosystem, documentation, and community to support you when challenges arise.

</details>
<details>
<summary>S2: Comprehensive</summary>

# S2: Comprehensive Analysis Approach

## Research Method

Deep technical analysis of collision detection libraries, examining algorithms, architecture, API design, and performance characteristics.

## Analysis Dimensions

### 1. **Algorithmic Foundation**
- Broad-phase algorithms (spatial partitioning, sweep-and-prune)
- Narrow-phase algorithms (SAT, GJK/EPA, distance fields)
- Continuous collision detection approaches
- Optimization techniques (SIMD, multi-threading, GPU)

### 2. **API Design & Usability**
- Query patterns (ray casting, shape casting, overlap tests)
- Shape representation and composition
- Callback and event systems
- Integration patterns

### 3. **Performance Characteristics**
- Benchmarks across different scenarios
- Scaling behavior (objects, complexity)
- Memory footprint
- Platform-specific optimizations

### 4. **Feature Completeness**
- Geometry support (primitives, meshes, compounds)
- Advanced features (CCD, SDF, queries)
- Multi-threading and parallelism
- Debug visualization

## Comparative Framework

Each library analysis includes:
- **Architecture**: Core design and component organization
- **Algorithms**: Specific implementations and variants
- **API patterns**: Minimal code examples showing usage patterns
- **Performance data**: Benchmarks and scaling characteristics
- **Trade-off analysis**: Where the library excels and where it struggles

## Scope

Focus on technical decision-making factors:
- Which algorithm implementations are used?
- How do APIs differ in complexity and expressiveness?
- What are the performance implications?
- Where are the architectural trade-offs?

This pass enables informed technical evaluation beyond surface-level comparisons.

---

# Box2D - Comprehensive Analysis

## Architecture Evolution

**Box2D v3.0 (2024)**: Complete rewrite from C++ to C, delivering major performance improvements and API changes.

### Core Components

**Collision Module** (`b2_collision.h`):
- Shape definitions
- Distance computation
- Overlap testing
- Geometric utilities

**World System** (`b2_world.h`):
- Broad-phase management
- Contact solver
- Island-based simulation

**Dynamics** (`b2_body.h`, `b2_contact.h`):
- Rigid body dynamics
- Contact management
- Constraint solving

## Collision Detection Pipeline

### 1. Broad-Phase: Incremental Sweep-and-Prune

**Algorithm**: Maintains sorted lists of AABB endpoints on each axis.

**Process**:
- Objects sorted by min/max AABB bounds on each axis
- Overlaps detected when sorted intervals intersect on all axes
- Incremental updates: only re-sort moved objects

**Performance**:
- **Best case**: O(n) when objects barely move
- **Worst case**: O(n²) for all-overlap scenarios
- **Typical**: O(n log n + k) where k = overlap pairs

**Why It Works for Games**: Most game objects have temporal coherence (move slowly between frames).

### 2. Narrow-Phase: SAT (Separating Axis Theorem)

**For Polygon-Polygon**:
- Tests axes perpendicular to each edge
- Early exit when separating axis found
- Returns contact manifold (up to 2 points for polygons)

**For Circle-Circle**:
- Analytical distance test (fastest case)

**For Circle-Polygon**:
- Voronoi region testing
- 1 contact point maximum

### 3. Continuous Collision Detection

**Conservative Advancement**:
- Time-of-impact (TOI) calculation
- Sub-stepping for fast-moving objects
- Prevents tunneling through thin obstacles

**Activation**:
- Enabled per-body via bullet flag
- Automatic for fast-moving bodies
- More expensive: use strategically

## Performance Characteristics

### v3.0 Performance Improvements

| Scenario | v2.4 | v3.0 | Speedup |
|----------|------|------|---------|
| Tumbler (many contacts) | 8.2ms | 2.9ms | 2.8x |
| Pyramid stack (600 boxes) | 5.1ms | 2.5ms | 2.0x |
| Many shapes (dynamic) | 12.4ms | 4.8ms | 2.6x |

*Single-threaded, desktop CPU*

### Multi-Threading (v3.0)

**Task-Based Parallelism**:
- Contact generation parallelized
- Island solving parallelized
- Near-linear scaling up to 8 cores

**Scaling**:
- 1 core: baseline
- 4 cores: 3.2x speedup
- 8 cores: 5.8x speedup

### Memory Efficiency

- **v3.0**: Pool allocators, reduced fragmentation
- **Typical usage**: ~100-200 bytes per body
- **Large worlds**: 10,000 bodies ≈ 2-3 MB

## API Patterns (v3.0)

### World Creation

```c
// v3.0 C API
b2WorldDef worldDef = b2DefaultWorldDef();
worldDef.gravity = (b2Vec2){0.0f, -10.0f};

b2WorldId worldId = b2CreateWorld(&worldDef);
```

### Body and Shape Creation

```c
// Create dynamic body
b2BodyDef bodyDef = b2DefaultBodyDef();
bodyDef.type = b2_dynamicBody;
bodyDef.position = (b2Vec2){0.0f, 4.0f};

b2BodyId bodyId = b2CreateBody(worldId, &bodyDef);

// Attach polygon shape
b2Polygon polygon = b2MakeBox(1.0f, 1.0f);

b2ShapeDef shapeDef = b2DefaultShapeDef();
shapeDef.density = 1.0f;
shapeDef.friction = 0.3f;

b2CreatePolygonShape(bodyId, &shapeDef, &polygon);
```

### Collision Filtering

```c
// Collision categories (16 bits)
shapeDef.filter.categoryBits = 0x0002; // Player category
shapeDef.filter.maskBits = 0x000C;     // Collides with enemies (0x0004) and world (0x0008)
```

### Contact Callbacks

```c
// Implement contact listener
void BeginContact(b2ShapeId shapeIdA, b2ShapeId shapeIdB, b2Manifold* manifold, void* context) {
    // Collision started
    b2Vec2 normal = manifold->normal;
    int pointCount = manifold->pointCount;
    // ... handle collision
}

// Register callbacks
worldDef.beginContactFcn = BeginContact;
worldDef.endContactFcn = EndContact;
```

### Sensors (Triggers)

```c
// Create sensor shape (no collision response)
shapeDef.isSensor = true;
b2CreatePolygonShape(bodyId, &shapeDef, &polygon);

// Sensor contacts reported via callbacks
// but don't affect physics simulation
```

### Ray Casting

```c
b2RayCastInput input = {
    .origin = {0.0f, 10.0f},
    .translation = {0.0f, -20.0f},
    .maxFraction = 1.0f
};

b2CastOutput output = b2World_CastRayClosest(
    worldId, input.origin, input.translation);

if (output.hit) {
    b2Vec2 hitPoint = b2MulAdd(input.origin,
        output.fraction, input.translation);
    // output.normal: surface normal at hit
    // output.fraction: parametric hit time [0, 1]
}
```

## Shape Support

### Supported Geometries

| Shape | Description | Performance | Use Cases |
|-------|-------------|-------------|-----------|
| Circle | Radius-based | Fastest | Balls, wheels, projectiles |
| Capsule | Two circles + rectangle | Fast | Characters, rounded objects |
| Polygon | Convex, up to 8 vertices | Fast | Boxes, platforms, general shapes |
| Edge Chain | Connected line segments | Fast | Terrain, boundaries |
| Segment | Single line | Fastest | Sensors, thin obstacles |

### Shape Constraints

- **Polygons**: Must be convex (concave requires decomposition)
- **Max vertices**: 8 (sufficient for most game shapes)
- **Edge chains**: Can be open or closed loops

## Advanced Features

### Compound Shapes

```c
// Multiple shapes on single body
b2CreatePolygonShape(bodyId, &shapeDef, &polygon1);
b2CreateCircleShape(bodyId, &shapeDef, &circle);
// Efficient: single body, multiple fixtures
```

### Contact Modification

```c
// Adjust contact properties before solving
void PreSolve(b2ShapeId shapeIdA, b2ShapeId shapeIdB,
              b2Manifold* manifold, void* context) {
    // Modify friction, restitution per contact
    // Or disable contact selectively
}
```

### One-Way Platforms

```c
// Implement via contact callbacks
void PreSolve(b2ShapeId shapeIdA, b2ShapeId shapeIdB,
              b2Manifold* manifold, void* context) {
    // Disable contact if moving upward through platform
    if (playerVelocity.y > 0.0f) {
        // disable contact
    }
}
```

## Trade-Off Analysis

### Strengths

**Reference Quality**: Cleanest, most readable physics engine code. Extensively commented, excellent for learning.

**2D Optimization**: Purpose-built for 2D. No 3D overhead, simpler API, faster than 3D engines constrained to 2D.

**Stability**: Contact solver is extremely stable. Handles complex stacking without explosions.

**CCD Quality**: Best-in-class continuous collision detection for 2D. Fast projectiles never tunnel.

**v3.0 Performance**: Rewrite delivers 2-3x speed improvements with multi-threading.

**Ecosystem**: Massive. Wrappers for every language, integrated in major engines (Unity 2D, Godot, LibGDX).

### Limitations

**2D Only**: Not suitable for 3D applications (obviously).

**Convex Shapes**: Concave polygons require decomposition. Not automatic.

**v3.0 Migration**: API breaking changes from v2.x. Migration effort required.

**No Soft Bodies**: Rigid bodies only. LiquidFun fork adds fluids but separate project.

**Shape Vertex Limit**: 8 vertices max per polygon. Rarely a problem but worth noting.

## When Technical Requirements Favor Box2D

Choose Box2D when:
- **2D game development** (any genre: platformer, puzzle, top-down)
- **Stable physics simulation** with complex stacking or piles
- **Continuous collision detection** critical for 2D fast-moving objects
- **Learning physics engines** (best-in-class code quality and docs)
- **Multi-platform** including mobile (optimized performance)
- **Integration** with existing game engines (Unity 2D, Godot, etc.)

Avoid Box2D when:
- Need 3D collision detection or physics
- Only need collision detection without physics (FCL, box-intersect)
- Require soft body simulation (LiquidFun fork or different engine)
- Need concave shapes without decomposition

## v2.x vs v3.0

**Should you migrate?**

**Yes, for new projects**: v3.0 performance and multi-threading worth it.

**Maybe, for existing projects**: Evaluate:
- Performance gains justify migration effort?
- API changes require significant refactoring?
- Existing wrappers support v3.0 yet?

**Key changes**:
- C API instead of C++ (bindings still possible)
- Task-based parallelism
- Handle-based object references (no raw pointers)
- 2-3x performance improvement

---

# Bullet Physics - Comprehensive Analysis

## Architecture

Bullet is a modular physics engine where collision detection is a distinct subsystem that can be used independently.

### Module Organization

**btCollision**: Core collision detection (can be used standalone)
- Broad-phase collision detection
- Narrow-phase algorithms
- Shape definitions and queries

**btDynamics**: Physics simulation (optional)
- Rigid body dynamics
- Constraint solvers
- Integration

**btSoftBody**: Deformable objects (optional)

## Collision Detection Pipeline

### 1. Broad-Phase

**Multiple Algorithms Available**:

**Dynamic AABB Tree (btDbvt)**:
- Default, balanced performance
- O(log n) insertion/removal
- Good for dynamic scenes

**Sweep and Prune (btAxisSweep3)**:
- Efficient for coherent motion
- Three 1D sorts on axes
- Best for clustered objects

**GPU Broad-Phase**:
- CUDA-accelerated for massive scenes
- Requires NVIDIA GPU

### 2. Narrow-Phase

**Algorithm Selection by Shape Pair**:

| Shape Combination | Algorithm | Performance |
|-------------------|-----------|-------------|
| Convex-Convex | GJK/EPA | Fast |
| Convex-Mesh | GJK + Triangle test | Moderate |
| Mesh-Mesh | BVH traversal | Slower |
| Sphere-Sphere | Analytical | Fastest |
| Box-Box | SAT | Fast |

### 3. Continuous Collision Detection

**Conservative Advancement**:
- Sweeps convex shape along trajectory
- Finds time-of-impact (TOI)
- Prevents tunneling for fast objects

**When CCD Activates**:
- Object velocity exceeds threshold
- Shape marked with CCD flag
- More expensive (use selectively)

## Performance Characteristics

### Benchmark Comparisons

**Rigid Body Simulation** (1000 objects, complex stacking):
- Bullet: ~16ms per frame (60 FPS achievable)
- PhysX (CPU): ~14ms per frame
- Box2D equivalent 2D: ~4ms per frame

**Collision Queries** (10,000 ray casts):
- Bullet: ~2.5ms
- FCL: ~3.2ms
- PhysX: ~2.1ms

### Scaling Behavior

| Objects | Frame Time | Memory | Notes |
|---------|------------|--------|-------|
| 100 | ~1ms | ~10MB | Trivial |
| 1,000 | ~8ms | ~80MB | Smooth |
| 5,000 | ~35ms | ~350MB | Challenging |
| 10,000 | ~120ms | ~700MB | Requires optimization |

## API Patterns

### Basic Collision World

```cpp
// Setup collision-only world
btDefaultCollisionConfiguration* config =
    new btDefaultCollisionConfiguration();
btCollisionDispatcher* dispatcher =
    new btCollisionDispatcher(config);
btBroadphaseInterface* broadphase =
    new btDbvtBroadphase();

btCollisionWorld* world = new btCollisionWorld(
    dispatcher, broadphase, config);

// Add objects
btCollisionShape* shape = new btBoxShape(btVector3(1, 1, 1));
btCollisionObject* obj = new btCollisionObject();
obj->setCollisionShape(shape);
world->addCollisionObject(obj);

// Detect collisions
world->performDiscreteCollisionDetection();
```

### Contact Iteration

```cpp
int numManifolds = dispatcher->getNumManifolds();
for (int i = 0; i < numManifolds; i++) {
    btPersistentManifold* manifold =
        dispatcher->getManifoldByIndexInternal(i);

    const btCollisionObject* objA = manifold->getBody0();
    const btCollisionObject* objB = manifold->getBody1();

    int numContacts = manifold->getNumContacts();
    for (int j = 0; j < numContacts; j++) {
        btManifoldPoint& pt = manifold->getContactPoint(j);
        btVector3 posA = pt.getPositionWorldOnA();
        btVector3 posB = pt.getPositionWorldOnB();
        btVector3 normal = pt.m_normalWorldOnB;
        btScalar distance = pt.getDistance();
    }
}
```

### Ray Casting

```cpp
btVector3 from(0, 10, 0);
btVector3 to(0, -10, 0);

btCollisionWorld::ClosestRayResultCallback rayCallback(from, to);
world->rayTest(from, to, rayCallback);

if (rayCallback.hasHit()) {
    btVector3 hitPoint = rayCallback.m_hitPointWorld;
    btVector3 hitNormal = rayCallback.m_hitNormalWorld;
    const btCollisionObject* hitObj = rayCallback.m_collisionObject;
}
```

## Shape Support

### Primitives
- Sphere, Box, Capsule, Cone, Cylinder
- Convex hull (computed from vertices)

### Complex Shapes
- **btBvhTriangleMeshShape**: Static concave meshes with BVH
- **btGImpactMeshShape**: Dynamic concave meshes (more expensive)
- **btHeightfieldTerrainShape**: Heightmap terrains
- **btCompoundShape**: Hierarchical composition

### Shape Performance

| Shape Type | Collision Cost | Best Use |
|------------|----------------|----------|
| Sphere | Fastest | Projectiles, particles |
| Box | Fast | Buildings, containers |
| Capsule | Fast | Characters, rounded objects |
| Convex hull | Moderate | Complex convex objects |
| Triangle mesh | Slow | Static environment geometry |

## Advanced Features

### Collision Filtering

```cpp
// Collision groups and masks
obj->setCollisionFlags(btCollisionObject::CF_NO_CONTACT_RESPONSE);

// Custom filtering
short collisionGroup = 1 << 0;  // Player
short collisionMask = 1 << 1;   // Enemies only
world->addCollisionObject(obj, collisionGroup, collisionMask);
```

### Ghost Objects

For trigger volumes without physics response:

```cpp
btGhostObject* trigger = new btGhostObject();
trigger->setCollisionShape(shape);
trigger->setCollisionFlags(
    btCollisionObject::CF_NO_CONTACT_RESPONSE);
world->addCollisionObject(trigger);

// Query overlaps
int numOverlaps = trigger->getNumOverlappingObjects();
```

### Convex Casting (Shape Sweeping)

```cpp
btConvexShape* convexShape = new btSphereShape(1.0);
btTransform from, to;
from.setIdentity();
to.setIdentity();
to.setOrigin(btVector3(10, 0, 0));

btCollisionWorld::ClosestConvexResultCallback callback(
    from.getOrigin(), to.getOrigin());

world->convexSweepTest(convexShape, from, to, callback);
```

## Trade-Off Analysis

### Strengths

**Production Proven**: 15+ years in AAA games, VFX, robotics. Battle-tested reliability.

**Comprehensive Features**: From simple overlap tests to continuous collision, convex casting, and complex mesh handling.

**Modular Design**: Use collision detection without physics simulation.

**PyBullet**: Python bindings make it accessible for ML/robotics research.

**Cross-Platform**: Windows, Linux, macOS, iOS, Android, consoles.

### Limitations

**API Complexity**: Verbose C++ API with manual memory management. Steeper learning curve than game-oriented engines.

**Overkill for 2D**: Full 3D engine with 3D overhead. Box2D is simpler and faster for pure 2D.

**Documentation**: Comprehensive but scattered. API docs exist but fewer narrative tutorials than Unity/Unreal.

**Modern C++ Standards**: Predates C++11/14 idioms. Manual pointer management.

## When Technical Requirements Favor Bullet

Choose Bullet when:
- **Need both collision detection and physics** in one package
- **3D game or simulation** with complex requirements
- **Continuous collision detection** is critical (fast projectiles, vehicles)
- **Python integration** via PyBullet for ML/robotics
- **Production reliability** matters more than cutting-edge features
- **Collision-only mode** for separating collision from physics

Avoid Bullet when:
- Pure 2D game (Box2D is better)
- Only need collision detection (FCL is lighter)
- Modern C++ idioms are required
- Prefer simpler API (Matter.js, Rapier)

---

# FCL (Flexible Collision Library) - Comprehensive Analysis

## Architecture

FCL is built around hierarchical spatial data structures for both broad-phase and narrow-phase collision detection.

### Core Components

**Spatial Structures**:
- **Dynamic AABB Tree**: Self-balancing tree for broad-phase
- **Bounding Volume Hierarchies (BVH)**: Multiple types (AABB, OBB, RSS, kDOP)
- **Octree**: Alternative spatial partitioning

**Collision Algorithms**:
- **GJK (Gilbert-Johnson-Keerthi)**: Distance computation between convex shapes
- **EPA (Expanding Polytope Algorithm)**: Penetration depth calculation
- **Triangle-based**: Direct mesh collision testing

## Algorithm Details

### Broad-Phase: Dynamic AABB Tree

Self-balancing binary tree where each node represents an AABB:
- **Insertion**: O(log n) with tree rebalancing
- **Query**: O(log n + k) where k is number of overlaps
- **Updates**: Incremental updates for moving objects

### Narrow-Phase: GJK + EPA

**GJK for Distance**:
- Iteratively constructs simplex in Minkowski difference
- Terminates when distance converges
- Returns closest points on both objects

**EPA for Penetration**:
- Expands GJK simplex to find penetration depth
- Provides normal and depth for collision response
- More expensive than GJK but necessary for overlapping objects

### Distance Computation

FCL's strength: accurate distance queries, not just collision boolean.

```cpp
// Typical distance query pattern
fcl::DistanceRequest request;
fcl::DistanceResult result;

fcl::distance(object1, object2, request, result);
// result.min_distance: exact distance between objects
// result.nearest_points: closest points on each object
```

## Performance Characteristics

### Scalability

| Object Count | Query Time (avg) | Memory Overhead |
|--------------|------------------|-----------------|
| 100 | ~0.1ms | ~50KB |
| 1,000 | ~0.5ms | ~500KB |
| 10,000 | ~3ms | ~5MB |
| 100,000 | ~35ms | ~50MB |

*Approximate values, varies by scene configuration*

### Optimization Features

- **Query caching**: Exploits temporal coherence
- **BVH refit**: Updates hierarchy without full rebuild
- **SIMD**: Some operations vectorized (platform-dependent)

## API Patterns

### Basic Collision Test

```cpp
fcl::CollisionRequest request;
fcl::CollisionResult result;

// Test two collision objects
fcl::collide(object1, object2, request, result);

if (result.isCollision()) {
    // Access contact information
    for (const auto& contact : result.getContacts()) {
        // contact.pos: contact point
        // contact.normal: collision normal
        // contact.penetration_depth: overlap amount
    }
}
```

### Distance Query

```cpp
// Find minimum distance and closest points
fcl::DistanceRequest dist_request;
dist_request.enable_nearest_points = true;

fcl::DistanceResult dist_result;
fcl::distance(obj1, obj2, dist_request, dist_result);

double min_dist = dist_result.min_distance;
fcl::Vec3f point_on_obj1 = dist_result.nearest_points[0];
fcl::Vec3f point_on_obj2 = dist_result.nearest_points[1];
```

## Shape Support

### Primitives
- Sphere, Box, Capsule, Cone, Cylinder
- Plane, Half-space

### Complex Geometries
- **Convex hulls**: Efficient for convex shapes
- **Triangle meshes**: Full support with BVH acceleration
- **Octrees**: Voxelized representations

### Compound Shapes
- Hierarchical composition of multiple geometries
- Separate BVH for each component

## Advanced Features

### Continuous Collision Detection

Limited native CCD support. For fast-moving objects:
- Manual time-of-impact queries
- Shape casting (sweep tests)
- External CCD layer often needed

### Broad-Phase Options

Multiple spatial structures available:
- Dynamic AABB tree (default, balanced)
- Brute force (O(n²), small scenes)
- Spatial hashing (custom implementation)

## Trade-Off Analysis

### Strengths

**Distance Queries**: FCL excels where you need precise distance computation, not just boolean collision. Critical for:
- **Path planning**: Need clearance distances
- **Robot motion**: Maintain safety margins
- **Proximity reasoning**: "How close can I get?"

**Accuracy**: Research-grade precision for geometric queries.

**Flexibility**: Multiple BVH types and query patterns.

### Limitations

**No Physics Integration**: Collision detection only. Need separate solver for:
- Collision response
- Constraint solving
- Rigid body dynamics

**CCD Not Core**: Continuous collision requires additional work.

**API Complexity**: More verbose than game-oriented engines.

**Smaller Ecosystem**: Fewer tutorials, primarily robotics-focused.

## When Technical Requirements Favor FCL

Choose FCL when requirements include:
- **Accurate distance computation** (not just collision boolean)
- **Geometric reasoning** about proximity and clearance
- **Robotics applications** (path planning, manipulation)
- **Research context** needing validated geometric algorithms
- **Collision detection without physics** (decouple systems)

Avoid FCL when:
- Need integrated physics simulation
- Building games (simpler APIs available)
- Continuous collision detection is critical
- Community size and tutorials matter

---

# Feature Comparison Matrix

## Algorithmic Capabilities

| Feature | FCL | Bullet | PhysX | Box2D | Rapier | Matter.js |
|---------|-----|--------|-------|-------|--------|-----------|
| **Broad-Phase** | Dynamic AABB tree | DBVT, SAP, GPU | Advanced + GPU | Sweep-and-prune | Advanced | Spatial hash |
| **Narrow-Phase** | GJK/EPA | GJK/EPA, SAT | GJK/EPA, SDF | SAT | GJK/EPA | SAT |
| **CCD** | Manual | Yes | Yes | Yes (excellent) | Yes | No |
| **Distance Queries** | ✓ Precise | ✓ Basic | ✓ Basic | ✓ Basic | ✓ Basic | ✗ |
| **GPU Acceleration** | ✗ | CUDA (optional) | CUDA | ✗ | ✗ | ✗ |

## Shape Support

| Shape Type | FCL | Bullet | PhysX | Box2D | Rapier | Matter.js |
|------------|-----|--------|-------|-------|--------|-----------|
| **Primitives** | ✓ Full | ✓ Full | ✓ Full | ✓ 2D only | ✓ Full | ✓ 2D only |
| **Convex Hulls** | ✓ | ✓ | ✓ | ✓ (8 verts) | ✓ | ✓ Limited |
| **Concave Meshes** | ✓ BVH | ✓ BVH/GImpact | ✓ BVH/SDF | ✗ | ✓ BVH | ✗ |
| **Height Fields** | ✗ | ✓ | ✓ | ✗ (N/A 2D) | ✓ | ✗ |
| **Signed Distance Fields** | ✗ | ✗ | ✓ | ✗ | ✗ | ✗ |
| **Compound Shapes** | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |

## Performance Profiles

### Scalability (Frame Budget at 60 FPS)

| Library | 100 Objects | 1,000 Objects | 10,000 Objects |
|---------|-------------|---------------|----------------|
| **PhysX (GPU)** | `<0.1`ms | 1ms | 8ms |
| **PhysX (CPU)** | 0.5ms | 4ms | 45ms |
| **Bullet** | 0.6ms | 5ms | 55ms |
| **Rapier** | 0.4ms | 4ms | 48ms |
| **Box2D v3** | 0.3ms (2D) | 2.5ms (2D) | 28ms (2D) |
| **FCL** | 0.2ms | 2ms | 25ms (query-only) |
| **Matter.js** | 1.2ms | 12ms | 140ms |

*Approximate values, varies by scenario*

### Algorithm Performance (Relative)

| Operation | Best | Good | Moderate | Slow |
|-----------|------|------|----------|------|
| **AABB Overlap** | box-intersect | All | - | - |
| **Convex-Convex** | GJK (all C++) | Rapier | Matter.js, p2.js | Python |
| **Convex-Mesh** | PhysX SDF | Bullet BVH | FCL BVH | - |
| **Ray Casting** | PhysX, Bullet | Rapier | Box2D | Matter.js |
| **Distance Query** | FCL | Bullet, PhysX | Rapier | N/A (Matter.js, Box2D) |

## API Complexity

| Library | Verbosity | Learning Curve | Memory Management | Type Safety |
|---------|-----------|----------------|-------------------|-------------|
| **FCL** | High | Steep | Manual C++ | Static |
| **Bullet** | Very High | Steep | Manual C++ | Static |
| **PhysX** | Very High | Very Steep | Manual C++ | Static |
| **Box2D v3** | Moderate | Moderate | Manual C | Static |
| **Rapier** | Low | Gentle | Automatic (Rust) | Static + Borrow Checker |
| **Matter.js** | Low | Gentle | Automatic (GC) | Dynamic (JS) |
| **p2.js** | Moderate | Moderate | Automatic (GC) | Dynamic (JS) |

## Integration & Ecosystem

| Library | Language Bindings | Game Engine Integration | Community Size | Documentation Quality |
|---------|-------------------|------------------------|----------------|----------------------|
| **Bullet** | C++, Python, C#, Java | Unity, Blender, Maya | Very Large | Good |
| **Box2D** | All major languages | Unity 2D, Godot, LibGDX | Massive | Excellent |
| **PhysX** | C++, C# (limited) | Unreal, Unity (optional) | Large | Good (technical) |
| **Rapier** | Rust, JS (WASM) | Bevy | Growing | Good |
| **Matter.js** | JavaScript only | Phaser, p5.js | Large | Excellent |
| **FCL** | C++, Python | ROS, custom robotics | Small | Academic |

## Advanced Features

| Feature | FCL | Bullet | PhysX | Box2D | Rapier | Matter.js |
|---------|-----|--------|-------|-------|--------|-----------|
| **Multi-Threading** | ✗ | ✓ | ✓ Advanced | ✓ (v3) | ✓ | ✗ |
| **SIMD** | Partial | ✓ | ✓ | ✓ (v3) | ✓ | ✗ |
| **Sensors/Triggers** | ✗ | ✓ | ✓ | ✓ | ✓ | ✓ |
| **Collision Callbacks** | Basic | ✓ Full | ✓ Full | ✓ Rich | ✓ Full | ✓ Basic |
| **Shape Casting** | ✓ | ✓ | ✓ | ✓ | ✓ | ✗ |
| **Convex Decomposition** | External | External | Automatic | External | External | External |

## Platform Support

| Platform | FCL | Bullet | PhysX | Box2D | Rapier | Matter.js |
|----------|-----|--------|-------|-------|--------|-----------|
| **Windows** | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |
| **Linux** | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |
| **macOS** | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |
| **iOS** | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |
| **Android** | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |
| **WebAssembly** | ✗ | Limited | ✗ | ✓ Ports | ✓ Native | ✓ Native |
| **Consoles** | ✗ | ✓ | ✓ | ✓ | ✓ | ✗ |

## Licensing

| Library | License | Commercial Use | Attribution Required |
|---------|---------|----------------|---------------------|
| **FCL** | BSD-3-Clause | ✓ Free | ✓ |
| **Bullet** | zlib | ✓ Free | ✓ |
| **PhysX** | BSD-3-Clause | ✓ Free | ✓ |
| **Box2D** | MIT | ✓ Free | ✓ |
| **Rapier** | Apache-2.0 | ✓ Free | ✓ |
| **Matter.js** | MIT | ✓ Free | ✓ |

All listed libraries are open source and free for commercial use.

## Maintenance & Activity

| Library | First Release | Latest Major Update | GitHub Activity | Bus Factor |
|---------|---------------|---------------------|-----------------|------------|
| **Bullet** | 2005 | Ongoing | Moderate | High (Erwin Coumans) |
| **Box2D** | 2007 | 2024 (v3.0) | Active | Medium (Erin Catto) |
| **PhysX** | 2005 | 2023 (v5.0) | Active | Very High (NVIDIA) |
| **FCL** | ~2012 | Ongoing | Low | Medium |
| **Rapier** | 2020 | Active | Very Active | Medium (Dimforge) |
| **Matter.js** | 2014 | Moderate | Moderate | Medium (liabru) |

## Dimension Support

| Library | 2D | 3D | Notes |
|---------|----|----|-------|
| **FCL** | ✓ | ✓ | Unified API |
| **Bullet** | Via constraints | ✓ Native | 2D via 3D with constraints |
| **PhysX** | Via constraints | ✓ Native | 2D via 3D with constraints |
| **Box2D** | ✓ Native | ✗ | Pure 2D, exceptional |
| **Rapier** | ✓ (rapier2d) | ✓ (rapier3d) | Separate crates |
| **Matter.js** | ✓ Native | ✗ | Pure 2D |
| **p2.js** | ✓ Native | ✗ | Pure 2D |

---

# S2 Comprehensive Recommendation

## Technical Decision Framework

### By Performance Requirements

**Highest Performance (10,000+ objects)**
1. **PhysX with GPU**: CUDA acceleration, best for massive simulations
2. **PhysX CPU**: Industry-leading CPU performance
3. **Rapier**: Modern, competitive with PhysX CPU
4. **Bullet**: Proven, near-PhysX performance

**Good Performance (1,000-10,000 objects)**
1. **Rapier**: Excellent performance/complexity ratio
2. **Bullet**: Battle-tested reliability
3. **Box2D v3** (2D only): 2D performance leader
4. **FCL** (collision-only): Query performance

**Adequate Performance (`<1`,000 objects)**
- Any library works
- Choose based on ecosystem/API preferences

### By Algorithmic Requirements

**Need Precise Distance Queries**
→ **FCL** (designed for this), **Bullet** (basic support)

**Need Continuous Collision Detection**
→ **Box2D** (best for 2D), **Bullet**, **PhysX**, **Rapier**
→ **Avoid**: Matter.js (no CCD)

**Need Concave Mesh Support**
→ **PhysX** (SDF, no decomposition needed), **Bullet** (BVH or GImpact)
→ **Avoid**: Box2D, Matter.js (2D, convex only)

**Need GPU Acceleration**
→ **PhysX** (CUDA required), **Bullet** (limited GPU support)

**Need Multi-Threading**
→ **PhysX** (excellent), **Box2D v3** (task-based), **Bullet**, **Rapier**

### By API Complexity Tolerance

**Want Simple API**
1. **Matter.js**: Easiest, best docs for beginners
2. **Rapier**: Modern Rust API, clean design
3. **Box2D v3**: Well-documented, moderate complexity

**Accept Complex API for Features**
1. **PhysX**: Most comprehensive features
2. **Bullet**: Full-featured, modular
3. **FCL**: Precise geometric queries

### By Language/Platform

**C++ Native, Maximum Control**
→ **Bullet** (proven), **PhysX** (cutting-edge), **FCL** (collision-only)

**Rust Native**
→ **Rapier** (only serious option)

**Python**
→ **PyBullet** (robotics, ML), **python-fcl** (path planning)

**JavaScript/Browser**
→ **Rapier** (via WASM, best performance), **Matter.js** (easiest, pure JS)

**Java**
→ **dyn4j** (pure Java), **JBullet** (Bullet port)

**2D Only**
→ **Box2D** (reference standard), any 2D-specific engine

### By Integration Requirements

**Unity**
→ **PhysX** (built-in 3D), **Box2D** (Unity 2D default)

**Unreal**
→ **PhysX** (built-in, deeply integrated)

**Godot**
→ **Box2D** (2D), **Bullet** (3D, built-in)

**Bevy (Rust)**
→ **Rapier** (official physics plugin)

**Custom Engine**
→ Choose based on language and performance needs

## Common Technical Pitfalls

### Performance Pitfalls

❌ **Using full physics engine for collision-only needs**
→ FCL or box-intersect sufficient, less overhead

❌ **Not enabling CCD for fast objects**
→ Bullets, projectiles tunnel without CCD

❌ **Concave meshes without decomposition or SDF**
→ PhysX SDF eliminates decomposition; others need preprocessing

❌ **JavaScript assumption = slow**
→ Rapier WASM approaches native performance in browsers

### API Pitfalls

❌ **Bullet API: Manual memory management**
→ Leaks common for beginners, use smart pointers

❌ **Box2D v3: Breaking changes from v2**
→ Migration required, not drop-in replacement

❌ **PhysX: Steep learning curve**
→ Complex API, significant ramp-up time

❌ **Matter.js: No CCD**
→ Fast objects tunnel through thin obstacles

### Architecture Pitfalls

❌ **2D game using 3D engine**
→ Box2D simpler and faster for pure 2D

❌ **Assuming newer = better**
→ Box2D (older) more mature than Matter.js (newer)

❌ **Ignoring Bus Factor**
→ Single-maintainer projects risk abandonment

## Algorithm Selection Guide

### Broad-Phase Choice

| Scenario | Best Algorithm | Libraries |
|----------|----------------|-----------|
| **Static world, dynamic objects** | Dynamic AABB tree | FCL, Bullet DBVT |
| **Coherent motion (games)** | Sweep-and-prune | Box2D, Bullet SAP |
| **Massive scenes** | GPU broad-phase | PhysX GPU |
| **Uniformly distributed** | Spatial hashing | Matter.js |

### Narrow-Phase Choice

| Shape Pair | Best Algorithm | When to Use |
|------------|----------------|-------------|
| **Convex-Convex** | GJK/EPA | General purpose |
| **Primitives** | Analytical | Maximum performance |
| **Polygon-Polygon** | SAT | 2D games |
| **Convex-Concave** | BVH + GJK | Static meshes |
| **Any-Concave** | SDF | PhysX only, no decomposition |

## Feature Necessity Checklist

Before choosing, determine actual requirements:

**Do you need physics simulation or just collision detection?**
- Just collision → FCL, box-intersect, use collision module only
- Full simulation → Bullet, PhysX, Box2D, Rapier

**Is continuous collision detection critical?**
- Fast projectiles, bullets, vehicles → Yes, CCD required
- Slow-moving objects, turn-based → No, discrete sufficient

**What dimensions?**
- Pure 2D → Box2D (best), Matter.js, p2.js
- 3D or mixed → Bullet, PhysX, Rapier

**How many objects?**
- `<1`,000 → Any library works
- 1,000-10,000 → Bullet, Rapier, Box2D, PhysX
- `>10`,000 → PhysX GPU, optimized configurations

**What shapes?**
- Primitives only → Any library
- Convex meshes → All modern libraries
- Concave meshes → PhysX (SDF), Bullet (BVH), requires decomposition elsewhere

**Platform targets?**
- Desktop only → Any C++/Rust library
- Browser → Rapier (WASM), Matter.js
- Consoles → PhysX, Bullet, Box2D
- Mobile → Optimized configurations, consider battery

## Migration Guidance

### From Prototyping to Production

**Matter.js → Rapier (browser)**
- Significant performance gain
- API rewrite required
- Use when prototyping validates concept

**PyBullet → Bullet C++**
- Python prototyping → C++ production
- Similar API concepts
- 10-100x performance improvement

**Box2D v2 → v3**
- 2-3x performance gain
- Breaking API changes
- Worth migrating for new projects

### Language Transitions

**Python → C++**
- python-fcl → FCL (collision)
- PyBullet → Bullet (physics)

**JavaScript → Native**
- Matter.js → Rapier Rust (WASM still available)
- p2.js → Box2D (2D)

### Engine Switches

**Unity → Custom**
- PhysX knowledge transfers
- Box2D for 2D

**Custom → Unreal**
- PhysX experience valuable
- Bullet experience partially transfers

## Technical Verdict by Scenario

### Robotics Path Planning
**Winner**: FCL
**Why**: Distance queries, precision over performance, Python bindings

### AAA Console Game
**Winner**: PhysX
**Why**: GPU acceleration, console support, vendor backing

### Indie 2D Platformer
**Winner**: Box2D v3
**Why**: Reference quality, CCD, ecosystem, performance

### Browser Game
**Winner**: Rapier (WASM) for performance, Matter.js for simplicity
**Why**: Native WASM vs pure JS trade-off

### Rust Game Engine
**Winner**: Rapier
**Why**: Only native Rust option, excellent performance

### Physics Sandbox Simulation
**Winner**: Bullet or PhysX
**Why**: Comprehensive features, proven stability

## The Bottom Line

**For production reliability**: Box2D (2D), Bullet or PhysX (3D)
**For maximum performance**: PhysX with GPU
**For modern development**: Rapier (Rust), Box2D v3 (C)
**For ease of use**: Matter.js (JS), Rapier (Rust)
**For precision queries**: FCL

Choose based on actual requirements, not marketing or popularity. Every listed library is production-grade in its domain.

</details>
<details>
<summary>S3: Need-Driven</summary>

# S3: Need-Driven Discovery Approach

## Research Method

Starting with user personas and specific requirements, identify optimal collision detection solutions for real-world scenarios.

## Selection Framework

### 1. **User Persona Definition**
- Who needs collision detection?
- What are they building?
- What constraints do they face?

### 2. **Requirements Mapping**
- Performance requirements (objects, frame rate)
- Dimensional needs (2D vs 3D)
- Platform constraints (browser, mobile, desktop, console)
- Team capabilities (language, complexity tolerance)

### 3. **Solution Validation**
- Does the solution meet performance requirements?
- Is the API complexity appropriate?
- Does the ecosystem support the use case?
- Are there production examples?

## Use Case Coverage

This pass examines:
- **Game developers** across different scales (indie 2D, AAA 3D, browser)
- **Robotics engineers** (path planning, manipulation)
- **Simulation developers** (physics, training, visualization)
- **Creative technologists** (installations, generative art)

## Format

Each use case file follows the structure:
- **## Who Needs This**: Persona definition
- **## Why**: Specific requirements and constraints
- **## Requirements**: Technical needs
- **## Solution**: Recommended library with rationale
- **## Alternative**: Backup options
- **## When NOT to Use**: Anti-patterns for this persona

---

# S3 Need-Driven Recommendation

## Decision Matrix by Persona

| Persona | Primary Solution | Alternative | When to Switch |
|---------|------------------|-------------|----------------|
| **Indie 2D Game** | Box2D | Matter.js (browser-first) | Never (Box2D is correct choice) |
| **Robotics Engineer** | FCL | Bullet (if need physics) | When simulating dynamics, not just planning |
| **AAA Game Studio** | PhysX (Unreal), Bullet (custom) | Engine-provided physics | Never (use what engine provides) |
| **Browser Creative Coder** | Matter.js | Rapier (WASM, performance) | When profiling shows perf bottleneck |

## Requirement-to-Solution Mapping

### By Primary Constraint

**Constraint: Browser-Only**
→ Matter.js (ease) or Rapier (performance)

**Constraint: 2D Game**
→ Box2D (any platform), Matter.js (browser), p2.js (Phaser)

**Constraint: 3D Game**
→ PhysX (AAA), Bullet (proven), Rapier (modern)

**Constraint: Robotics/Planning**
→ FCL (path planning), Bullet (simulation)

**Constraint: Python Required**
→ python-fcl (planning), PyBullet (simulation)

**Constraint: Rust Required**
→ Rapier (only serious option)

### By Performance Requirement

**`<100` objects**
→ Any library works, choose by ecosystem/API preference

**100-1,000 objects**
→ Box2D (2D), Bullet/Rapier (3D), Matter.js (browser if `<500`)

**1,000-10,000 objects**
→ PhysX CPU, Bullet, Rapier, Box2D v3 (2D)

**`>10`,000 objects**
→ PhysX GPU (CUDA required), specialized solutions

### By Development Speed Priority

**Fastest prototyping**:
1. Matter.js (browser, 5min setup)
2. Box2D (2D, excellent docs)
3. Rapier (modern API, good docs)

**Proven reliability**:
1. Box2D (2D reference)
2. Bullet (battle-tested 3D)
3. PhysX (industry standard)

### By Technical Depth Required

**Precision geometric queries**
→ FCL (distance, clearance, closest points)

**Continuous collision detection**
→ Box2D (best 2D), Bullet/PhysX/Rapier (3D)

**GPU acceleration**
→ PhysX (only option with mature GPU support)

**Advanced physics (destruction, fluids)**
→ PhysX 5 (Flex, Blast integrated)

## Use Case Anti-Patterns

### What NOT to Do

❌ **Indie 2D game using PhysX**
→ Overkill, use Box2D (simpler, faster for 2D)

❌ **Robotics using Matter.js**
→ No distance queries, browser-focused, use FCL

❌ **Browser game using Bullet**
→ WebAssembly port exists but Matter.js or Rapier better

❌ **3D game using Box2D**
→ Box2D is 2D only (obviously wrong)

❌ **Collision-only needs using full physics engine**
→ Use FCL or box-intersect, avoid physics overhead

❌ **Creative coding using PhysX**
→ Massive overkill, use Matter.js

## Migration Patterns

### Common upgrade paths:

**Prototyping → Production**:
- Matter.js → Rapier (browser performance)
- PyBullet → Bullet C++ (robotics simulation)
- Box2D v2 → Box2D v3 (performance gains)

**Platform expansion**:
- Unity 2D (Box2D) → Console → Keep Box2D (already using it)
- Browser prototype (Matter.js) → Native app → Rapier or Box2D

**Scale increase**:
- Indie game grows → More objects → Optimize or consider PhysX/Bullet
- Creative project → Installation → More complexity → Rapier WASM

### When NOT to migrate:

- **Box2D for 2D**: Already optimal, no better alternative
- **Robotics FCL**: Distance queries unique, no comparable alternative
- **Engine-integrated physics**: Unity/Unreal → Stay with engine's physics

## Validation Questions

Before finalizing library choice, ask:

**1. What dimensions?**
- 2D → Box2D, Matter.js, p2.js
- 3D → Bullet, PhysX, Rapier

**2. What platform?**
- Browser → Matter.js, Rapier WASM
- Native → Bullet, PhysX, Box2D, Rapier
- Consoles → PhysX, Bullet, Box2D

**3. What performance target?**
- `<500` objects → Any library works
- 500-5,000 → Modern engines (Bullet, Rapier, PhysX, Box2D)
- `>5`,000 → PhysX GPU or specialized

**4. Physics or collision only?**
- Collision only → FCL, box-intersect
- Physics needed → Bullet, PhysX, Box2D, Rapier, Matter.js

**5. What's team expertise?**
- C++ → Bullet, PhysX, FCL, Box2D
- Rust → Rapier
- Python → python-fcl, PyBullet
- JavaScript → Matter.js, Rapier WASM

**6. Continuous collision detection critical?**
- Yes → Box2D (2D), Bullet/PhysX/Rapier (3D)
- No → Any library

**7. Distance queries needed?**
- Yes → FCL (best), Bullet (basic)
- No → Any collision library

## Summary by Context

**Game Development**:
- 2D indie → Box2D
- 3D indie → Bullet or Rapier
- AAA → PhysX or engine-provided
- Browser → Matter.js or Rapier

**Robotics**:
- Path planning → FCL
- Simulation → Bullet or PyBullet
- Research → python-fcl or PyBullet

**Creative/Educational**:
- Browser → Matter.js
- Desktop → Box2D or Rapier
- Interactive art → Matter.js

**Simulation/Research**:
- Accurate physics → PhysX or Bullet
- ML training → PyBullet
- Custom requirements → Assess case-by-case

## The Safe Defaults

If still unsure after analysis:

**Safe default for 2D**: Box2D
**Safe default for 3D**: Bullet
**Safe default for browser**: Matter.js
**Safe default for robotics**: FCL (planning) or PyBullet (simulation)

These choices minimize risk while covering most requirements. Can always optimize or specialize later if specific needs emerge.

---

# Use Case: AAA Game Studio (3D Console/PC Game)

## Who Needs This

Mid-to-large game studio developing AAA 3D game targeting consoles and PC, with significant performance and visual quality requirements.

**Example personas**:
- Technical director evaluating physics middleware
- Lead engine programmer optimizing collision detection
- Studio considering Unreal vs custom engine
- Team building open-world action game

## Why

**Primary needs**:
- **Console performance**: 60 FPS on PlayStation, Xbox, Nintendo platforms
- **Large-scale worlds**: Open worlds, massive battle scenes
- **Visual quality**: Accurate physics for AAA standards
- **Production reliability**: Can't risk game-breaking physics bugs
- **Team scale**: Multiple programmers, content creators working with physics

**Constraints**:
- Must ship on consoles (certification requirements)
- Performance budget tight (graphics + physics + gameplay)
- Team expertise varies (engine programmers vs gameplay programmers)
- Support and documentation critical for large team
- Long-term maintenance (patches, expansions, sequels)

## Requirements

**Technical**:
- 3D collision detection and physics simulation
- Console platform support (PS5, Xbox Series X/S, Switch)
- 60 FPS with 1,000-5,000 physics objects (context-dependent)
- Complex shapes (characters, vehicles, environment)
- Continuous collision detection (fast projectiles, vehicles)
- Advanced features (destruction, ragdolls, vehicles)

**Production**:
- Proven in AAA games (risk mitigation)
- Active vendor support (urgent issues need resolution)
- Team training available (ramp up new hires)
- Tools integration (content pipeline, editor)
- Debugger/profiler support

**Business**:
- Console certification compliance
- Licensing acceptable (free or reasonable cost)
- Long-term support (5+ years for franchise)

## Solution: PhysX (if using Unreal) or Bullet/PhysX (custom engine)

### Option A: Unreal Engine → Use Built-In PhysX

**Why PhysX via Unreal is optimal**:

**1. Technical Fit**
- **Industry-leading performance**: GPU acceleration available
- **Console proven**: Every major console game uses PhysX or similar
- **Feature completeness**: Destruction (Blast), vehicles, ragdolls, cloth
- **SDF collision**: No convex decomposition needed for complex meshes
- **Continuous collision**: Essential for fast-moving gameplay elements

**2. Production Fit**
- **Deep Unreal integration**: Mature tooling, content pipeline, debugging
- **NVIDIA support**: Backed by major vendor with AAA studio relationships
- **Training available**: Unreal documentation, GDC talks, vendor training
- **Community**: Massive Unreal community for troubleshooting

**3. Business Fit**
- **Cost**: Free with Unreal (included in engine)
- **Console support**: Full PlayStation, Xbox, Switch support
- **Certification**: Proven through certification on all platforms
- **Long-term**: NVIDIA commitment to Unreal ecosystem

### Option B: Custom Engine → PhysX or Bullet

**PhysX** (Cutting-Edge):
- **Pros**: GPU acceleration, SDF collision, latest features (PhysX 5)
- **Cons**: Complex integration, C++-heavy API, learning curve
- **Use when**: Need maximum performance, GPU acceleration, or cutting-edge features

**Bullet** (Proven Reliability):
- **Pros**: Battle-tested, simpler than PhysX, strong community
- **Cons**: No GPU acceleration, older codebase, manual convex decomposition
- **Use when**: Prefer proven reliability over cutting-edge, CPU-only acceptable

## Implementation Path

**Unreal Engine Path**:
1. Use built-in PhysX (default)
2. Configure collision channels, complexity, CCD settings
3. Leverage Unreal's physics asset pipeline
4. Profile and optimize (LOD, sleeping, culling)

**Custom Engine Path**:
1. **Evaluate**: Test PhysX and Bullet with representative scene
2. **Integrate**: Build collision world, loading pipeline
3. **Optimize**: Profile, tune broad-phase, sleeping, island management
4. **Tools**: Build editor integration, debug visualization
5. **Content pipeline**: Convex decomposition, collision mesh authoring

## Alternative 1: Unity (Uses PhysX by Default)

**When to choose Unity**:
- Prefer Unity's development workflow
- Team expertise in C# vs C++
- Mid-tier AAA or AA game scope

**Trade-offs**:
- Unity's PhysX integration less customizable than Unreal
- Performance ceiling lower than custom Unreal/native engine
- Good for AA/indie with AAA aspirations

## Alternative 2: Godot (Uses Bullet for 3D)

**When to choose Godot**:
- Open-source engine requirement
- Lower-budget AAA or AA scope
- Want more control than Unity, simpler than custom engine

**Trade-offs**:
- Smaller console support (some platforms require porting)
- Less AAA-proven than Unreal/Unity
- Bullet integration solid but less cutting-edge than PhysX

## When NOT to Use PhysX

**Don't use PhysX when**:

❌ **2D game**: PhysX is 3D-focused. Use Box2D (Unity 2D, Godot 2D).

❌ **No GPU available**: If targeting low-end hardware without CUDA, PhysX GPU features unavailable. Bullet may be simpler.

❌ **Team lacks C++ expertise**: PhysX is C++-heavy. If team struggles, use engine abstraction (Unreal, Unity) instead of direct integration.

❌ **Indie budget, custom engine**: Integration cost may exceed budget. Use engine with built-in physics instead.

## Performance Considerations

**Console performance targets**:
- **60 FPS**: ~4-6ms physics budget (out of 16.6ms total frame)
- **30 FPS**: ~8-12ms physics budget (out of 33.3ms total frame)

**Object complexity scaling**:

| Object Count | PhysX (CPU) | PhysX (GPU) | Bullet | Notes |
|--------------|-------------|-------------|--------|-------|
| 100 | `<0.5`ms | `<0.2`ms | ~0.6ms | Trivial |
| 1,000 | ~4ms | ~1ms | ~5ms | Comfortable |
| 5,000 | ~20ms | ~5ms | ~25ms | Challenging |
| 10,000 | ~45ms | ~12ms | ~55ms | GPU needed |

**Optimization strategies**:
- Sleeping bodies (inactive objects don't simulate)
- Broad-phase culling (distant objects ignored)
- LOD physics (simplified collision for distant objects)
- Async simulation (physics on separate thread)

## Risk Mitigation

**AAA-specific risks**:
- **Late performance issues**: Profile early, throughout production
- **Platform certification**: Test on target hardware continuously
- **Physics bugs near launch**: Use proven libraries, avoid custom solutions
- **Team knowledge silos**: Train multiple programmers on physics system

**Mitigation strategies**:
- Choose battle-tested library (PhysX, Bullet)
- Use engine's built-in physics when possible (Unreal, Unity)
- Profile and optimize throughout production
- Build debug tools early (visualization, profiling)

## Validation Checklist

Before committing to PhysX or Bullet:
- [ ] 3D game (not 2D)
- [ ] Targeting consoles (PS5, Xbox, Switch)
- [ ] Performance budget allows 4-6ms physics (60 FPS target)
- [ ] Team has C++ expertise (if custom engine)
- [ ] Need advanced features (destruction, vehicles, ragdolls)
- [ ] Budget for integration and optimization time
- [ ] Proven library preferred over experimental

If using Unreal or Unity: use their built-in physics (PhysX or Bullet).
If custom engine: PhysX for cutting-edge, Bullet for proven reliability.

## Success Stories

**AAA games using PhysX**:
- Countless Unreal Engine games
- Fortnite, Gears of War (Unreal + PhysX)
- Many major franchises (licensed middleware)

**AAA games using Bullet**:
- Grand Theft Auto V (Rage engine + Bullet)
- Red Dead Redemption
- Many custom engines

---

# Use Case: Browser Game / Creative Coder

## Who Needs This

Creative technologist, web developer, or indie developer building interactive browser-based experiences with physics.

**Example personas**:
- Creative coder building generative art installations
- Web developer creating interactive portfolio piece
- Indie developer prototyping browser game concept
- Educator building physics visualization for students
- Artist creating interactive museum installation

## Why

**Primary needs**:
- **Browser-native**: Runs in any modern browser without plugins
- **Quick setup**: Minimal configuration, fast iteration
- **Visual output**: Easily render physics simulation to canvas
- **Accessible API**: No PhD in physics required
- **Shareable**: Deploy to web, anyone can access

**Constraints**:
- JavaScript environment (browser or Node.js)
- Performance limited by browser (no native threads, GC pauses)
- User experience: must load quickly, run smoothly
- May not have computer science background
- Often working solo, need good documentation

## Requirements

**Technical**:
- JavaScript/TypeScript native
- 2D collision and physics (3D rare for browser creative coding)
- Canvas or WebGL rendering integration
- 100-500 objects at 30-60 FPS
- Reasonably intuitive API

**Development**:
- Quick setup (minutes, not hours)
- Good examples to learn from
- Visual debugging helpful
- npm installable or CDN available

**User Experience**:
- Fast load times (`<2`s)
- Smooth frame rates on average hardware
- Mobile-friendly (touch support)

## Solution: Matter.js (Creative/Accessible) or Rapier (Performance)

### Option A: Matter.js (Recommended for Most)

**Why Matter.js is optimal for creative coding**:

**1. Accessibility Fit**
- **Gentle learning curve**: Intuitive API, easy to understand
- **Excellent documentation**: Interactive demos, clear examples
- **Quick setup**: `npm install matter-js` or CDN, working in minutes
- **Visual tools**: Matter Tools for debugging and visualization

**2. Browser Integration**
- **Pure JavaScript**: No build tools required (though npm available)
- **Canvas/WebGL ready**: Easy rendering integration
- **Event system**: Simple collision callbacks
- **Mobile support**: Touch events, responsive performance

**3. Creative Coding Fit**
- **Rapid prototyping**: Iterate ideas quickly
- **Tweakable physics**: Easy to adjust gravity, friction, bounciness
- **Composable**: Combine shapes to create complex visuals
- **Community**: Large creative coding community (p5.js, Processing forums)

**4. Example Projects**
- Generative art with physics
- Interactive data visualizations
- Portfolio interactive pieces
- Educational physics demos

**Setup speed**:
```javascript
// Working physics simulation in ~20 lines
const engine = Matter.Engine.create();
const render = Matter.Render.create({
    element: document.body,
    engine: engine
});

// Add objects, run simulation
Matter.Engine.run(engine);
Matter.Render.run(render);
```

### Option B: Rapier (WASM - When Performance Critical)

**When to choose Rapier instead**:
- **Performance critical**: Need native-level speed in browser
- **Many objects**: 500+ objects, complex simulations
- **WebAssembly acceptable**: Build step okay
- **Modern development**: TypeScript, bundler workflow standard

**Trade-offs**:
- More complex setup (WASM, bundler)
- Slightly steeper learning curve
- Smaller community in creative coding
- But 5-10x faster than Matter.js

**Use for**: Performance-demanding browser games, complex simulations, professional interactive experiences

## Implementation Path

**Matter.js Path (Beginner-Friendly)**:
1. Include via CDN or `npm install matter-js`
2. Create engine, renderer
3. Add shapes (boxes, circles, polygons)
4. Run simulation, render to canvas
5. Add interaction (mouse constraints, keyboard)

**Rapier Path (Performance-Focused)**:
1. `npm install @dimforge/rapier2d-compat`
2. Initialize WASM module (async)
3. Set up physics world
4. Add bodies and colliders
5. Step simulation, render manually (Three.js, PixiJS, etc.)

## Alternative 1: p2.js (Phaser Integration)

**When to choose p2.js**:
- Using Phaser game framework
- Need specific physics features (vehicles, constraints)
- Educational context (demonstrate different broad-phase algorithms)

**Trade-offs**:
- Slower than Matter.js
- Less polished API
- Good Phaser integration though

## Alternative 2: Box2D.js (Maximum Compatibility)

**When to choose Box2D.js**:
- Need Box2D specifically (porting desktop game to web)
- Want most battle-tested 2D physics
- Continuous collision detection critical

**Trade-offs**:
- More complex API than Matter.js
- C++ port feel (less JavaScript-native)
- Excellent stability and accuracy

## When NOT to Use Matter.js

**Don't use Matter.js when**:

❌ **Performance critical**: If needing 1,000+ objects or very fast simulation, use Rapier (WASM).

❌ **Fast projectiles**: Matter.js lacks CCD, fast objects tunnel through thin obstacles.

❌ **Production game**: If building serious browser game, Rapier offers better performance ceiling.

❌ **3D**: Matter.js is 2D only. For 3D browser physics, use cannon.js, Ammo.js, or Rapier3D.

## Success Stories

**Matter.js creative projects**:
- Countless generative art pieces
- Interactive portfolios (Bruno Simon's portfolio)
- Educational visualizations
- Museum installations
- Browser game prototypes

## Validation Checklist

Before committing to Matter.js:
- [ ] Browser-based project (web deployment)
- [ ] 2D physics (not 3D)
- [ ] Object count `<500`
- [ ] Fast projectiles not critical (or acceptable limitations)
- [ ] Rapid prototyping important
- [ ] Accessible API preferred (team skill level)
- [ ] Creative/educational focus (not production AAA game)

If most checked, Matter.js is appropriate for browser creative coding.

## When to Start with Matter.js and Migrate

**Prototyping path**:
1. **Prototype**: Matter.js for rapid idea validation
2. **Validate concept**: Prove the experience works
3. **Profile**: Identify performance bottlenecks
4. **Migrate**: Rapier if performance becomes limiting

This path minimizes initial friction while leaving upgrade path if needed.

## Learning Resources

**Matter.js**:
- Official examples (brm.io/matter-js)
- Coding Train tutorials (YouTube)
- p5.js + Matter.js examples
- MDN Web Docs collision detection guides

**Rapier (WASM)**:
- Official documentation (rapier.rs)
- Three.js + Rapier examples
- PixiJS integration examples

## Mobile Considerations

**Matter.js mobile tips**:
- Reduce object count (200-300 max)
- Lower physics iterations (trade accuracy for performance)
- Use sleeping bodies aggressively
- Simplify shapes (circles and boxes faster than complex polygons)

**Touch interaction**:
- Matter.js mouse constraint works with touch
- Implement mobile-friendly controls
- Test on actual devices (performance varies widely)

## The Creative Coder's Verdict

**For most creative coding use cases**: Matter.js
- Quickest setup
- Easiest to learn
- Best documentation and examples
- Sufficient performance for typical projects

**For performance-critical browser experiences**: Rapier WASM
- Near-native performance
- Handles complex simulations
- Worth the extra setup complexity

Choose based on actual requirements, not assumptions about performance. Start with Matter.js unless you know you need Rapier's speed.

---

# Use Case: Indie 2D Game Developer

## Who Needs This

Solo developer or small team building a 2D platformer, puzzle game, or top-down action game. Limited budget and team size, targeting desktop and mobile platforms.

**Example personas**:
- Indie developer building a precision platformer
- Two-person team creating a physics-based puzzle game
- Student team prototyping a 2D action game

## Why

**Primary needs**:
- **Stable physics**: Objects stack, platforms work reliably, no "explosions"
- **Fast-moving object support**: Projectiles, fast characters don't tunnel through walls
- **Cross-platform**: Windows, macOS, Linux, iOS, Android
- **Good documentation**: Small team can't afford weeks debugging physics
- **Proven reliability**: Can't risk game-breaking bugs near launch

**Constraints**:
- Limited development time (months, not years)
- Small or no budget for commercial middleware
- Need to ship on multiple platforms
- May use game engine (Unity, Godot) or custom tech

## Requirements

**Technical**:
- 2D collision detection and physics
- Continuous collision detection (CCD) for projectiles
- Stable contact solver (stacking, complex scenes)
- 60 FPS with 200-1,000 dynamic objects
- Mobile-friendly performance

**Development**:
- API complexity: Moderate acceptable
- Documentation: Must be excellent
- Community: Need active forums/Discord for help
- Examples: Need working demos to learn from

**Platform**:
- Desktop (Windows, macOS, Linux)
- Mobile (iOS, Android) likely target
- Browser (nice to have for web demos)

## Solution: Box2D

**Why Box2D is optimal**:

**1. Technical Fit**
- **2D-native**: No 3D overhead, simpler than 3D engines constrained to 2D
- **CCD**: Best-in-class continuous collision detection for 2D
- **Stability**: Reference-quality contact solver, handles stacking perfectly
- **Performance**: 200-1,000 objects easily within 60 FPS budget

**2. Development Fit**
- **Documentation**: Exceptionally well-documented with extensive comments
- **Learning curve**: Moderate (not trivial, but manageable for small team)
- **Community**: Massive user base, active forums, countless tutorials
- **Examples**: Thousands of shipped games to learn from

**3. Ecosystem Fit**
- **Game engine integration**: Unity 2D (built-in), Godot (built-in), LibGDX
- **Language wrappers**: C++, C#, Java, JavaScript, Python, Go, Rust
- **Cross-platform**: Proven on every major platform
- **Cost**: Free, MIT license, no royalties

**4. Production Reality**
- **Proven**: Thousands of shipped games (desktop, mobile, console)
- **Indie-friendly**: Used by countless successful indie games
- **Long-term**: 15+ years old, v3.0 (2024) ensures future support

## Implementation Path

**If using game engine**:
1. Unity 2D → Box2D integrated, use native Unity physics
2. Godot → Box2D integrated, use GDScript physics APIs
3. LibGDX (Java) → Box2D wrapper included

**If building custom engine**:
1. Use C++ Box2D directly, or
2. Use language-specific wrapper (Box2D.js for JavaScript, etc.)

**Learning resources**:
- iforce2d tutorials (comprehensive)
- Official documentation (excellent)
- "2D Game Physics for Dummies" (book)

## Alternative: Matter.js (Browser-First Games)

**When to choose Matter.js instead**:
- **Browser-first**: Targeting web/HTML5 as primary platform
- **Simpler API needed**: Team wants gentler learning curve
- **Prototype speed**: Rapid iteration more important than max performance
- **Creative coding focus**: Physics as creative tool, not game mechanic

**Trade-offs**:
- ~40% slower than Box2D.js
- No CCD (fast objects may tunnel)
- Less accurate for complex stacking

**Good for**: Browser games, prototypes, creative projects
**Not good for**: Performance-critical, precision platformers, mobile

## When NOT to Use This Solution

**Don't use Box2D when**:

❌ **3D game**: Box2D is 2D only. Use Bullet, PhysX, or Rapier instead.

❌ **Collision-only needs**: If you only need collision detection without physics simulation, Box2D is overkill. Use simpler library.

❌ **Ultra-low complexity requirement**: If team struggles with Box2D's API, use Matter.js (though performance/accuracy suffer).

❌ **Massive object count**: If needing `>10`,000 simultaneous objects, consider spatial partitioning or different approach.

## Success Stories

**Proven indie games using Box2D**:
- Angry Birds (mobile physics gameplay)
- Limbo (precision platformer)
- World of Goo (physics puzzle)
- Countless others (Box2D is the 2D physics standard)

## Validation Checklist

Before committing to Box2D:
- [ ] Confirmed 2D game (not 3D)
- [ ] Need physics simulation (not just collision detection)
- [ ] Target platforms supported (nearly universal)
- [ ] Team comfortable with moderate API complexity
- [ ] Performance requirement: `<1`,000 objects at 60 FPS
- [ ] Need reliable CCD (projectiles, fast movement)

If all checked, Box2D is the safe choice.

---

# Use Case: Robotics Engineer (Path Planning & Manipulation)

## Who Needs This

Robotics engineer or researcher building autonomous systems requiring collision-free motion planning and manipulation.

**Example personas**:
- Research lab developing autonomous manipulation algorithms
- Industrial robotics company building pick-and-place systems
- PhD student working on path planning for mobile robots
- Warehouse automation team building navigation systems

## Why

**Primary needs**:
- **Distance computation**: Not just "collision yes/no" but "how far apart?"
- **Clearance checking**: Maintain safety margins around obstacles
- **Path validation**: Check if planned trajectory is collision-free
- **Manipulation planning**: Verify gripper paths, check reachability
- **Fast queries**: Real-time or near-real-time for reactive planning

**Constraints**:
- Accuracy critical (collision = damage to robot or environment)
- Need geometric reasoning (distances, closest points, clearances)
- Often using Python (ROS, research prototyping)
- May need C++ for production deployment
- Real-time requirements for reactive systems

## Requirements

**Technical**:
- **Distance queries**: Precise minimum distance between shapes
- **Closest points**: Where are the nearest points on each object?
- **Clearance checking**: Maintain safety margins
- **Ray casting**: Sensor simulation, line-of-sight checks
- **Mesh support**: CAD models, complex robot geometries
- **3D**: Robot manipulation is inherently 3D

**Performance**:
- Query latency: `<10`ms for interactive planning
- Batch queries: Thousands per second for sampling-based planners
- Memory efficient: Large workspace models

**Development**:
- Python bindings (prototyping, ROS integration)
- C++ available (production, real-time systems)
- ROS integration (common in robotics)

## Solution: FCL (Flexible Collision Library)

**Why FCL is optimal**:

**1. Technical Fit**
- **Distance computation**: FCL's core strength, not just boolean collision
- **Closest points**: Returns exact nearest points on both objects
- **Geometric precision**: Research-grade accuracy for safety-critical applications
- **Mesh support**: CAD models, complex geometries via BVH

**2. Algorithm Fit**
- **GJK/EPA**: Precise distance and penetration depth
- **BVH acceleration**: Fast queries on complex meshes
- **Multiple BVH types**: AABB, OBB, RSS, kDOP for different scenarios

**3. Robotics Ecosystem Fit**
- **python-fcl**: Clean Python bindings for prototyping
- **ROS integration**: Used in MoveIt! and other planning frameworks
- **Research validation**: Widely used in academic robotics
- **Path planning libraries**: Integrates with OMPL, others

**4. Query Patterns Match Use Case**

```python
# Distance query (typical robotics usage)
result = fcl.distance(robot_geometry, obstacle_geometry)

if result.min_distance < safety_margin:
    # Too close, reject configuration
    return False

# Access closest points for visualization or reasoning
nearest_on_robot = result.nearest_points[0]
nearest_on_obstacle = result.nearest_points[1]
```

## Implementation Path

**Prototyping (Python)**:
1. Install python-fcl: `pip install python-fcl`
2. Load robot URDF → FCL collision objects
3. Build workspace obstacle models
4. Query distances during planning

**Production (C++)**:
1. Use FCL C++ library directly
2. Integrate with real-time control loop
3. Optimize BVH construction for workspace models

**ROS Integration**:
- MoveIt! uses FCL for collision checking
- Leverage existing integration
- Custom planning: use FCL directly via python-fcl or C++

## Alternative 1: Bullet (When Physics Simulation Needed)

**When to choose Bullet instead**:
- **Need physics simulation**: Grasping simulation, contact forces
- **Dynamic environments**: Objects moving, falling, rolling
- **PyBullet for RL**: Reinforcement learning robotics research
- **End-to-end simulation**: Robot dynamics + collision in one system

**Trade-offs**:
- Distance queries less precise than FCL
- More complex API (full physics engine)
- Better for simulation, FCL better for planning-only

**Use for**: RL robotics (PyBullet), simulation-based training, physics-heavy scenarios

## Alternative 2: Custom Spatial Indexing + Primitives

**When to choose custom solution**:
- **Simple geometries**: Only spheres, cylinders for collision checking
- **Ultra-low latency**: Need hand-optimized queries
- **Specialized workspace**: Can exploit structure (2.5D warehouse, grid)

**Trade-offs**:
- Development time (build collision detection yourself)
- Risk of bugs (collision detection is hard)
- No mesh support (only simple primitives)

**Use for**: Specialized applications, extreme performance requirements, research on collision detection itself

## When NOT to Use FCL

**Don't use FCL when**:

❌ **Need full physics simulation**: FCL is collision detection only. Use Bullet or PyBullet if simulating dynamics, contacts, grasping.

❌ **Only simple primitives**: If workspace is spheres/cylinders only, analytical methods or simple broad-phase may suffice.

❌ **2D navigation only**: If purely 2D (mobile robot on flat ground), 2D spatial indexing simpler.

❌ **Ultra-high frequency queries**: If needing 100,000+ queries per second, GPU-based methods (PhysX) or specialized solutions needed.

## Success Stories

**Robotics projects using FCL**:
- **MoveIt!** (ROS motion planning framework)
- **OMPL integration** (path planning library)
- Academic research (UNC, Berkeley, others)
- Industrial manipulation planning systems

## Validation Checklist

Before committing to FCL:
- [ ] Need distance queries (not just collision boolean)
- [ ] 3D manipulation or navigation
- [ ] Working with complex geometries (meshes, CAD models)
- [ ] Python prototyping or C++ production acceptable
- [ ] Performance requirement: `<10`ms per query
- [ ] Collision detection decoupled from physics simulation
- [ ] Safety margins and clearances critical

If most checked, FCL is the appropriate choice for robotics path planning.

## When to Start with FCL and Migrate Later

**Prototyping path**:
1. **Start**: python-fcl for algorithm prototyping
2. **Validate**: Test planning algorithms, verify collision checking works
3. **Optimize**: Profile, identify bottlenecks
4. **Migrate**: C++ FCL for real-time deployment if Python too slow

This path minimizes risk while enabling rapid iteration during research phase.

</details>
<details>
<summary>S4: Strategic</summary>

# S4: Strategic Selection Approach

## Research Method

Analyzing collision detection libraries from a long-term architectural perspective, considering maintenance, ecosystem evolution, team scaling, and strategic positioning.

## Strategic Dimensions

### 1. **Longevity & Maintenance**
- Project age and maturity
- Vendor backing vs community-driven
- Release cadence and roadmap
- Historical stability

### 2. **Ecosystem Positioning**
- Market adoption and momentum
- Integration with major platforms
- Competitive landscape evolution
- Migration paths (in and out)

### 3. **Team & Organization Fit**
- Hiring and training considerations
- Knowledge transferability
- Documentation and support infrastructure
- Community health and responsiveness

### 4. **Technology Trajectory**
- Modern vs legacy architecture
- Performance optimization trends (SIMD, GPU, multi-threading)
- API evolution and breaking changes
- Platform support roadmap

### 5. **Risk Assessment**
- Bus factor (key person dependency)
- Licensing and legal considerations
- Vendor lock-in potential
- Competitive displacement risk

## Analysis Framework

Each library evaluated for:
- **5-year viability**: Will this library still be maintained and relevant?
- **Ecosystem alignment**: Does it align with broader technology trends?
- **Team scalability**: Can we hire for this? Train for this?
- **Exit strategy**: What if we need to migrate away?

## Scope

Strategic considerations beyond technical features:
- Is this library's ecosystem growing or declining?
- What's the opportunity cost of choosing this?
- How does this affect our options in 3-5 years?
- What strategic partnerships or platform alignments does this enable?

This pass informs architectural decisions with multi-year consequences.

---

# Box2D - Strategic Viability Assessment

## 5-Year Outlook: Strong

**Verdict**: Box2D will remain the 2D physics reference standard through 2030+. Recent v3.0 rewrite demonstrates long-term commitment.

## Maturity & Maintenance

**Age**: 18 years (2007-present)
**Status**: Active development, major v3.0 update (2024)

### Historical Track Record
- **Consistent evolution**: Steady improvements over 18 years
- **v3.0 rewrite**: Complete C rewrite in 2024 shows long-term vision
- **Erin Catto**: Original author still maintaining (dedicated steward)
- **Documentation**: Consistently excellent across versions

### Future Trajectory
**Strong indicators**:
- v3.0 rewrite extends relevance 5-10 years
- Performance improvements (2-3x) make it competitive with newer alternatives
- MIT license change (2020) improves commercial flexibility

**Risks**:
- Single-person dependency (Erin Catto)
- Community contributions limited (design by committee avoided)
- Successor risk (if Erin Catto stops maintaining)

**Mitigation**: Box2D's simplicity and maturity mean even without updates, it remains viable. Fork risk low (mature, well-understood code).

## Ecosystem Position

### Market Adoption
**Dominant in 2D**:
- Unity 2D (built-in)
- Godot (built-in)
- LibGDX (integrated)
- Countless custom engines

**Adoption trend**: Stable. Not growing rapidly (market saturated) but not declining.

### Competitive Landscape
**No serious 2D challengers**:
- Matter.js (browser-focused, less accurate)
- p2.js (smaller ecosystem)
- Chipmunk (less documented, smaller community)

Box2D is the *de facto* 2D physics standard. This position unlikely to change.

### Platform Support
- Desktop: Universal
- Mobile: Universal (iOS, Android)
- Consoles: Supported (through engines)
- Browser: Ports exist (Box2D.js, Box2D-wasm)

**Trend**: Expanding (v3.0 performance enables more platforms)

## Team & Organization Fit

### Hiring & Training
**Knowledge availability**: Widespread
- Box2D commonly taught in game dev curricula
- Thousands of tutorials, courses, books
- "Learn Box2D" = standard education path

**Hiring pool**: Large
- Any 2D game programmer familiar with Box2D
- Easy to find expertise
- Junior developers can ramp up quickly (good docs)

**Training cost**: Low
- Excellent documentation
- Many free tutorials
- Mature knowledge base (Stack Overflow, forums)

### Team Scaling
**Solo to 50+ person teams**: Scales well
- Simple enough for solo developer
- Modular enough for team specialization
- No complex enterprise licensing or deployment

### Knowledge Transferability
**High portability**: Box2D knowledge transfers across:
- Game engines (Unity, Godot concepts similar)
- Platforms (API consistent)
- Projects (Box2D everywhere in 2D games)

Understanding Box2D = understanding 2D physics generally.

## Technology Trajectory

### Modernization
**v3.0 (2024)**: Major modernization
- C language (interop with everything)
- Task-based parallelism (multi-core)
- 2-3x performance improvement
- Handle-based API (safer than raw pointers)

**Impact**: Extends relevance 5-10 years without fundamental redesign.

### Performance Evolution
**Current state**: Competitive with any 2D physics engine
**Headroom**: Multi-threading scaling continues to improve

**GPU physics**: Unlikely for Box2D (2D doesn't need it, CPU sufficient)

### API Stability
**Breaking changes**: v2.x → v3.0 broke API
**Future**: v3.x likely stable for years (major rewrite just completed)

**Migration risk**: v3.0 is the "new foundation." Expect stability now.

## Risk Assessment

### Bus Factor: Medium-Low Risk
**Key person**: Erin Catto (original author, sole maintainer)

**Mitigation factors**:
- Code is clean, well-documented, understandable
- Mature (few changes needed for stability)
- Fork potential high (clear code, permissive license)
- Erin Catto active and committed (v3.0 rewrite shows dedication)

**Worst case**: If Erin Catto stops maintaining, community could fork successfully. Code quality makes this feasible.

### Vendor Lock-In: Minimal
**Open source**: MIT license (permissive)
**Platform independence**: Runs everywhere
**Data format**: Physics parameters, no proprietary formats

**Migration away**: Possible but painful (physics tuning non-transferable)
- Could migrate to custom physics
- Or different engine (Matter.js, p2.js)
- Physics "feel" requires re-tuning

**Lock-in reality**: Practical lock-in via content tuning, not technical

### Competitive Displacement: Very Low Risk
**Position**: De facto standard for 2D physics
**Challenger risk**: None visible

For Box2D to be displaced, a new library would need:
- Significantly better performance (v3.0 already fast)
- Better documentation (Box2D already excellent)
- Larger ecosystem (Box2D already everywhere)

**Verdict**: Displacement highly unlikely in 5-year horizon.

### Licensing: No Risk
**MIT license** (since v2.4):
- Commercial use freely allowed
- No royalties
- No attribution requirements in binary
- Fork and modify freely

**Legal clarity**: Excellent. No license uncertainty.

## Strategic Recommendations

### When Box2D is Strategically Sound

**Strong fit**:
- **Long-term 2D game projects**: Box2D will outlive your project
- **Multi-project studios**: Box2D knowledge transfers across projects
- **Training investment**: Learning Box2D pays off across careers
- **Stable technology stack**: v3.0 provides 5-10 year foundation

**Strategic benefits**:
- Hiring easier (Box2D well-known)
- Knowledge stable (docs, tutorials won't become outdated)
- Platform flexibility (runs everywhere)
- Risk minimal (mature, forked, stable)

### When to Consider Alternatives Strategically

**Weak fit**:
- **Browser-first strategy**: Matter.js or Rapier WASM better aligned with web ecosystem
- **3D expansion plans**: If planning 3D sequel, using 3D engine from start may unify stack
- **Cutting-edge positioning**: Box2D is "mature" not "cutting-edge" (strategic perception)

**Not technical reasons, strategic reasons**.

## 5-Year Scenarios

### Optimistic Scenario (70% probability)
- v3.x continues incremental improvements
- Performance optimizations (SIMD, multi-threading)
- Ecosystem stable, Unity/Godot continue integration
- Box2D remains 2D standard

### Realistic Scenario (25% probability)
- v3.0 is final major release (Erin Catto reduces activity)
- Maintenance mode (bug fixes, no major features)
- Box2D still viable (mature enough to not need updates)
- Community forks emerge for specialized needs

### Pessimistic Scenario (5% probability)
- Erin Catto stops maintaining entirely
- No community fork succeeds
- Box2D becomes legacy library
- Replacement emerges (unlikely, but possible)

**Even pessimistic scenario**: Box2D remains usable (just no updates). Mature libraries can survive without updates for years.

## Strategic Decision Framework

**Choose Box2D strategically when**:
- Building 2D game or physics simulation
- Need long-term stable foundation
- Hiring and training considerations important
- Platform flexibility required
- Risk minimization prioritized

**Reconsider strategically when**:
- Browser-only (web ecosystem alignment matters)
- Cutting-edge positioning critical (marketing/branding)
- Need GPU physics (not applicable to 2D currently)

**Bottom line**: Box2D is the *strategically sound* choice for 2D physics. Mature, stable, well-supported, low-risk.

---

# Rapier - Strategic Viability Assessment

## 5-Year Outlook: Strong Growth Trajectory

**Verdict**: Rapier represents the modern Rust physics ecosystem. Positioned for growth with Rust adoption, particularly in Bevy ecosystem. Higher risk than mature alternatives but significant upside.

## Maturity & Maintenance

**Age**: 4 years (2020-present)
**Status**: Active, rapid development

### Historical Track Record
- **Rapid iteration**: Frequent releases, responsive to community
- **Performance focus**: Consistently improving benchmarks
- **Dimforge backing**: Company behind Rapier (nalgebra, Parry)
- **Rust ecosystem alignment**: Part of growing Rust gamedev wave

### Future Trajectory
**Growth indicators**:
- Bevy adoption accelerating (Bevy = leading Rust game engine)
- WebAssembly performance competitive with native in browsers
- Rust language momentum (increasing adoption in games, simulation)
- Active development (commits monthly, issues addressed quickly)

**Risks**:
- Young library (4 years vs 15-20 for Bullet/Box2D)
- Smaller team (Dimforge small company)
- Rust ecosystem still maturing (fewer production games shipped)
- Bevy itself still pre-1.0 (ecosystem coupled to Bevy's maturity)

**Mitigation**: Rust language guarantees (memory safety), clean architecture, and open-source nature reduce technical debt risk.

## Ecosystem Position

### Market Adoption
**Growing but niche**:
- **Bevy**: Official physics plugin (strong positioning)
- **WebAssembly**: Excellent performance in browsers (Rapier.js)
- **Rust gamedev**: De facto choice (no serious Rust alternatives)

**Adoption trend**: Rapid growth from small base
- Rust adoption in games increasing
- Bevy momentum strong (downloads, community)
- WebAssembly use cases expanding

### Competitive Landscape
**In Rust**: Dominant
- No competing Rust-native physics engine with similar features
- heron (physics integration for Bevy) uses Rapier

**Cross-language**:
- Competes with Bullet, PhysX for native performance
- Performance competitive (5-8x faster than older nphysics)
- Missing ecosystem maturity of older engines

### Platform Support
- **Desktop**: Excellent (Windows, Linux, macOS native)
- **Mobile**: Good (iOS, Android via Rust)
- **Browser**: Excellent (WebAssembly, near-native performance)
- **Consoles**: Possible but less proven (Rust console tooling maturing)

**Trend**: Expanding as Rust platform support improves

## Team & Organization Fit

### Hiring & Training
**Knowledge availability**: Limited but growing
- Rust gamedev community smaller than C++
- Rapier-specific knowledge rare (library young)
- Rust expertise increasingly available (language growing)

**Hiring pool**: Small but growing
- Rust developers in high demand (generalist, not game-specific)
- Bevy/Rapier expertise rare (can train)
- Rust learning curve steeper than JavaScript, similar to C++

**Training cost**: Medium-High
- Rust language learning curve (ownership, borrowing)
- Rapier docs good but less extensive than Box2D/Bullet
- Fewer tutorials, courses, books

### Team Scaling
**Solo to ~10 person teams**: Good fit
- Rust memory safety reduces bugs (valuable for small teams)
- Clean API supports collaboration

**Large teams (10+)**: Unproven
- Few large production games using Rapier
- Tooling and workflow less established than Unity/Unreal

### Knowledge Transferability
**Mixed**:
- **Within Rust ecosystem**: High (Rapier knowledge transfers to other Rust projects)
- **Outside Rust**: Low (Rust-specific, doesn't transfer to C++/Unity/Unreal jobs)

**Strategic consideration**: Betting on Rust ecosystem growth. If Rust game development becomes mainstream, Rapier knowledge valuable. If Rust stays niche, knowledge less transferable.

## Technology Trajectory

### Modernization
**Born modern**:
- Rust memory safety (no manual memory management bugs)
- SIMD optimizations (built-in, platform-adaptive)
- Multi-threading (safe concurrency via Rust)
- WebAssembly-native (excellent browser support)

**Advantage**: No legacy baggage. Can adopt modern techniques from day one.

### Performance Evolution
**Current state**: Competitive with PhysX CPU, Bullet
**Trajectory**: Continuing optimization (SIMD improvements, algorithm refinements)

**WASM performance**: Near-native in browsers (major advantage over JavaScript)

### API Stability
**Breaking changes**: Occasional (young library, API still evolving)
**Future**: Stability improving (approaching API maturity)

**Risk**: Expect more breaking changes than Box2D/Bullet (part of young library reality)

**Mitigation**: Changes well-documented, migration guides provided

## Risk Assessment

### Bus Factor: Medium Risk
**Key team**: Dimforge (Sébastien Crozet primary author)
**Company status**: Small company, not NVIDIA/AAA studio backing

**Mitigation factors**:
- Open source (Apache-2.0, fork possible)
- Clean Rust code (easier to maintain than C++)
- Dimforge has multi-year track record (nalgebra older, stable)
- Rust community could fork if needed

**Comparison**: Higher risk than PhysX (NVIDIA), lower than FCL (academic project)

### Vendor Lock-In: Low
**Open source**: Apache-2.0 license (permissive)
**Rust ecosystem**: Knowledge transfers within Rust
**WebAssembly**: Can deploy same code to browser and native

**Migration away**:
- To Rust alternative: Minimal (no alternatives exist)
- To C++ (Bullet/PhysX): Possible, requires rewrite
- Rust knowledge valuable beyond Rapier

**Lock-in reality**: Rust language choice more significant than Rapier specifically

### Competitive Displacement: Medium Risk
**Position**: Leading Rust physics engine
**Challenger risk**: Another Rust physics library could emerge

**Displacement scenarios**:
- PhysX or Bullet get Rust bindings (exists but unofficial, low quality)
- New Rust physics engine emerges (possible but unlikely soon)
- Bevy adopts different physics backend (unlikely, Rapier official)

**Verdict**: Moderate risk. Position strong but market still forming.

### Licensing: No Risk
**Apache-2.0 license**:
- Commercial use freely allowed
- Patent grant included
- Fork and modify freely

**Legal clarity**: Excellent. Standard OSS license.

## Strategic Recommendations

### When Rapier is Strategically Sound

**Strong fit**:
- **Rust-first strategy**: Already using Rust or committed to Rust adoption
- **Bevy game engine**: Rapier is official physics plugin
- **Browser + Native**: WebAssembly performance critical
- **Modern tech stack**: Value memory safety, modern tooling
- **Long-term Rust bet**: Believe Rust gamedev will grow

**Strategic benefits**:
- Rust ecosystem growth (early positioning)
- Memory safety reduces bugs (valuable long-term)
- WebAssembly performance (competitive advantage in browsers)
- Modern architecture (technical debt minimized)

### When to Consider Alternatives Strategically

**Weak fit**:
- **Mature ecosystem required**: Need extensive tutorials, courses, community
- **Large team hiring**: Rust developers harder to hire than C++/C#
- **Console-first**: Console Rust tooling less mature than C++
- **Risk aversion**: Prefer 15-year track record over 4-year
- **Unity/Unreal pipeline**: Using existing engines with built-in physics

**Not technical limitations, strategic considerations**.

## 5-Year Scenarios

### Optimistic Scenario (40% probability)
- Rust gamedev ecosystem matures significantly
- Bevy reaches 1.0+, gains major adoption
- Rapier becomes standard physics for Rust (already there)
- WebAssembly performance advantage drives browser adoption
- Team scales, commercial backing increases
- Rapier in same tier as Bullet/Box2D for modern projects

### Realistic Scenario (45% probability)
- Rust gamedev grows steadily but remains niche
- Bevy community strong, some commercial games ship
- Rapier remains best Rust option
- WebAssembly use cases expand
- Moderate adoption, stable development
- Niche but viable choice

### Pessimistic Scenario (15% probability)
- Rust gamedev momentum slows
- Dimforge reduces development (business reasons)
- Alternative emerges or PhysX Rust bindings mature
- Rapier becomes maintenance mode
- Fork or migration needed

**Risk level**: Medium. Young library risk higher than mature alternatives, but Rust ecosystem momentum positive signal.

## Strategic Decision Framework

**Choose Rapier strategically when**:
- Committed to Rust ecosystem (language choice made)
- Using Bevy game engine (natural integration)
- Value modern architecture and memory safety
- Browser + native deployment planned (WASM advantage)
- Willing to bet on Rust gamedev growth

**Reconsider strategically when**:
- Team lacks Rust expertise (training cost)
- Need maximum ecosystem maturity (Box2D/Bullet safer)
- Targeting consoles primarily (C++ tooling more mature)
- Risk-averse organization (prefer proven libraries)
- Using Unity/Unreal (built-in physics better integrated)

**Bottom line**: Rapier is the *strategic bet on modern Rust ecosystem*. Higher risk than mature alternatives, but aligned with Rust language momentum and modern development practices. Choose if Rust investment already made or planned.

## Comparison to Mature Alternatives

| Factor | Rapier | Bullet/Box2D |
|--------|--------|--------------|
| **Maturity** | 4 years | 15-18 years |
| **Track record** | Growing | Proven |
| **Bus factor risk** | Medium | Low-Medium |
| **Ecosystem size** | Small, growing | Large, stable |
| **Hiring pool** | Small | Large |
| **Technology** | Modern | Mature |
| **Performance** | Excellent | Excellent |
| **Memory safety** | Guaranteed (Rust) | Manual (C/C++) |
| **WebAssembly** | Native | Ports exist |

**Strategic trade-off**: Modern tech + growth potential vs proven reliability + large ecosystem.

---

# S4 Strategic Recommendation

## Strategic Positioning Matrix

| Library | Market Position | 5-Year Viability | Risk Level | Strategic Value |
|---------|-----------------|------------------|------------|-----------------|
| **Box2D** | 2D Standard | Very High | Very Low | Stable Foundation |
| **Bullet** | 3D Proven | High | Low | Battle-Tested |
| **PhysX** | AAA Standard | Very High | Very Low | Enterprise Grade |
| **Rapier** | Rust Leader | Medium-High | Medium | Modern Bet |
| **Matter.js** | Browser Standard | Medium-High | Low | Web Focused |
| **FCL** | Robotics Tool | Medium | Medium | Niche Excellence |

## Long-Term Strategic Guidance

### By Organizational Risk Tolerance

**Risk-Averse Organizations** (Enterprise, AAA Studios)
**Choose**: PhysX (3D), Box2D (2D)
**Why**: Proven track record, vendor backing, minimal displacement risk
**Time horizon**: 5-10 years stable

**Moderate Risk Tolerance** (Established Indie, Mid-Size Studios)
**Choose**: Bullet (3D), Box2D (2D), Rapier (if Rust-committed)
**Why**: Balance of maturity and modern capabilities
**Time horizon**: 3-7 years stable

**Risk-Tolerant / Early Adopters** (Startups, Research, Cutting-Edge)
**Choose**: Rapier (Rust ecosystem), Cutting-edge features (PhysX 5)
**Why**: Positioned for ecosystem growth, modern architecture
**Time horizon**: 2-5 years, willing to adapt

### By Technology Stack Evolution

**Mature, Stable Stack** (Unity, Unreal, Established Engines)
→ **Use engine's built-in physics** (PhysX, Bullet, Box2D)
**Strategic advantage**: Integration, support, team knowledge

**Modern Stack** (Rust, Bevy, WebAssembly-First)
→ **Rapier**
**Strategic advantage**: Language alignment, WebAssembly performance

**Browser-First** (Web Games, Creative Tools, Visualization)
→ **Matter.js** (ease) or **Rapier** (performance)
**Strategic advantage**: Ecosystem alignment, deployment simplicity

**Robotics/Research** (ROS, Academia, Path Planning)
→ **FCL** (planning) or **PyBullet** (simulation)
**Strategic advantage**: Domain-specific capabilities

### By Team Growth Plans

**Small Team Staying Small** (1-5 people)
- **Prefer**: Simple APIs (Matter.js, Box2D) or memory-safe (Rapier)
- **Avoid**: Complex APIs requiring specialists (raw PhysX)
- **Strategy**: Reduce bug surface, maximize productivity

**Scaling Team** (Planning to hire significantly)
- **Prefer**: Well-known libraries (Box2D, Bullet, PhysX)
- **Reason**: Easier hiring, transferable knowledge
- **Strategy**: Common knowledge reduces onboarding time

**Specialized Team** (Expert programmers)
- **Prefer**: Best-in-class tools (PhysX GPU, Rapier, FCL)
- **Reason**: Can leverage advanced features
- **Strategy**: Maximum capability extraction

## Ecosystem Momentum Analysis

### Growing Ecosystems (Invest Now)

**Rapier + Rust**:
- **Momentum**: Strong (Rust adoption, Bevy growth, WASM performance)
- **Time to mainstream**: 2-4 years (estimate)
- **Strategic value**: Early positioning in growing ecosystem
- **Risk**: May not reach critical mass

**WebAssembly Physics**:
- **Momentum**: Strong (browser performance improvements, Rapier WASM)
- **Time to mainstream**: Already mainstream for certain use cases
- **Strategic value**: Browser-native performance without JavaScript limits
- **Risk**: Browser standards evolution

### Stable Ecosystems (Safe Bet)

**Box2D + 2D Game Engines**:
- **Momentum**: Stable (saturated but not declining)
- **Longevity**: 5-10+ years certain
- **Strategic value**: Reliable foundation for 2D projects
- **Risk**: Minimal (mature, proven)

**PhysX + AAA Engines**:
- **Momentum**: Stable (industry standard, NVIDIA backing)
- **Longevity**: 5-10+ years (PhysX 5 roadmap)
- **Strategic value**: Enterprise-grade reliability
- **Risk**: Minimal (corporate backing)

**Bullet + Custom Engines**:
- **Momentum**: Stable (proven, widely used)
- **Longevity**: 5-10+ years (mature, community can fork if needed)
- **Strategic value**: Independent of commercial engine dependencies
- **Risk**: Low-Medium (single maintainer but mature codebase)

### Declining/Stagnant Ecosystems (Caution)

**Older JavaScript Physics** (p2.js, older Matter.js equivalents):
- **Momentum**: Declining (Rapier WASM offers better performance)
- **Strategic consideration**: Still viable but being outpaced

**Pure Python Implementations**:
- **Momentum**: Minimal (performance limitations clear)
- **Strategic consideration**: Prototyping only, not production

## Hiring & Talent Strategy

### Talent Availability (5-year horizon)

| Skill | Current Availability | 2029 Forecast | Strategic Implication |
|-------|---------------------|---------------|----------------------|
| Box2D | High | High (stable) | Easy hiring |
| Bullet | Medium-High | Medium-High | Moderate hiring |
| PhysX | Medium | Medium | Specialist hiring |
| Rust/Rapier | Low | Medium (growing) | Investment in training |
| Matter.js | Medium | Medium-High | Web developer crossover |

**Hiring strategy implications**:
- **Box2D/Bullet**: Broad hiring pool
- **PhysX**: Specialists or train internally
- **Rapier**: Hire Rust developers, train on Rapier (Rust harder than Rapier)
- **Matter.js**: Hire web developers, easier transition to physics

### Knowledge Transfer Risk

**High Transfer** (Knowledge moves with employee):
- Box2D → Understood across industry
- PhysX/Bullet → Common in AAA/simulation

**Medium Transfer** (Some specialization):
- Rapier → Rust-specific but Rust knowledge growing
- FCL → Robotics domain-specific

**Low Transfer** (Specialized):
- Custom implementations
- Heavily modified forks

**Strategic consideration**: Common libraries reduce "hero programmer" dependency.

## Platform Evolution Risk

### Console Generations

**PhysX**: Proven across console generations (safe bet)
**Bullet**: Supported on consoles (through engines)
**Box2D**: Universal console support
**Rapier**: Rust console tooling maturing (medium risk)

**Strategy**: If console-critical, choose proven (PhysX, Bullet, Box2D).

### Browser Evolution

**WebAssembly momentum**: Strong
**Rapier WASM**: Positioned well for future
**Matter.js**: JavaScript will always work but performance ceiling lower

**Strategy**: If browser-future bet, Rapier WASM strategically aligned.

### Mobile Platforms

**All major libraries**: Mobile support good
**Performance considerations**: Native (C++, Rust) better than JavaScript for performance

**Strategy**: Mobile-first → Native libraries (Box2D, Bullet, Rapier)

## Exit Strategy Assessment

### Migration Difficulty (if library abandoned)

**Easiest to migrate away from**:
- **Matter.js / p2.js**: Pure JavaScript, could rewrite or swap
- **box-intersect**: Narrow scope, replaceable

**Moderate migration difficulty**:
- **Box2D**: Physics tuning non-transferable, but alternatives exist
- **Rapier**: Rust rewrite required if moving to C++
- **Bullet**: Similar to Box2D, alternatives exist

**Hardest to migrate away from**:
- **PhysX (via Unreal)**: Engine deeply integrated
- **FCL**: Distance query focus unique, no direct replacement

**Strategic consideration**: Deeper integration = harder exit but often worth it for benefits.

### Forking Viability

**Easy to fork** (if abandoned):
- **Box2D**: Clean C code, well-documented
- **Rapier**: Modern Rust, good architecture
- **Bullet**: Larger codebase but community capable

**Difficult to fork**:
- **PhysX**: Massive codebase, NVIDIA-specific optimizations
- **FCL**: Academic context, smaller community

**Strategic consideration**: Permissive license + clean code = fork insurance.

## Strategic Recommendations by Scenario

### Startup Building Browser Game
**Choose**: Rapier (WASM) for performance or Matter.js for speed
**Rationale**: WebAssembly-aligned, rapid iteration, modern stack
**Risk**: Acceptable (startups optimize for speed and modern tech)

### Indie Studio (Established, 2D Game)
**Choose**: Box2D v3
**Rationale**: Proven, excellent docs, risk minimization for commercial project
**Risk**: Minimal (safe choice for revenue-critical project)

### AAA Studio (New 3D Franchise)
**Choose**: PhysX (if Unreal) or engine-provided physics
**Rationale**: Industry standard, support, proven at scale
**Risk**: Minimal (betting on NVIDIA/Epic/Unity long-term commitment)

### Robotics Company (Path Planning Product)
**Choose**: FCL (C++/Python)
**Rationale**: Distance queries essential, robotics ecosystem standard
**Risk**: Acceptable (domain-specific, no better alternative)

### Research Lab (Experimental Rust Project)
**Choose**: Rapier
**Rationale**: Modern architecture, Rust ecosystem alignment, research cutting-edge
**Risk**: Acceptable (research context, flexibility to adapt)

## The Strategic Bottom Line

**Most Strategically Sound Overall**:
1. **Box2D** (2D) - Minimal risk, maximum ecosystem
2. **PhysX** (3D AAA) - Industry standard, vendor backing
3. **Bullet** (3D Independent) - Proven reliability, community

**Highest Growth Potential**:
1. **Rapier** - Rust ecosystem momentum
2. **WebAssembly Physics** (Rapier WASM) - Browser performance future

**Best Risk/Reward by Context**:
- **Enterprise**: PhysX (minimize risk)
- **Indie**: Box2D (2D) or Bullet (3D) (proven + accessible)
- **Startup**: Rapier or Matter.js (modern + fast iteration)
- **Robotics**: FCL (specialized capability)

Choose based on organizational risk tolerance, technology stack, and ecosystem alignment—not just technical features. Strategic fit matters as much as performance benchmarks.

</details>
