---
title: "1.113 Ui Component Libraries"
weight: 1113
description: "Research on Ui Component Libraries"
related:
- '1.112'
- '1.118'
- '1.110'
- 1.110.4
- 1.110.5
date: 2026-02-06
lastmod: 2026-02-06
---

# 1.113 Ui Component Libraries



---

<details open>
<summary>Explainer</summary>

# UI Component Libraries: Domain Explainer

## What This Solves

UI component libraries solve the problem of **repeatedly implementing common interface patterns** while ensuring quality, consistency, and accessibility.

### The Core Problem

Every web application needs buttons, forms, dropdowns, modals, and tables. Building these from scratch means:

- **Time investment**: 2-3 weeks per project just building basic components
- **Quality gaps**: Accessibility bugs, keyboard navigation issues, browser inconsistencies
- **Maintenance burden**: Every team maintains their own versions, bugs don't propagate fixes
- **Inconsistency**: Same "button" looks and works differently across products

### Who Encounters This

- **Startups**: Need professional UI fast to pitch investors
- **Enterprise teams**: Building admin panels with complex data tables and forms
- **Freelancers**: Shipping client projects on tight budgets
- **Design system teams**: Creating internal component libraries
- **Open-source maintainers**: Building dev tools with limited time

### Why It Matters

**Business impact**:
- 2-3 weeks saved per project = $4K-$12K in development costs
- Professional UI = higher conversion rates, investor confidence
- Accessibility compliance = avoid lawsuits (ADA/Section 508)

**Developer impact**:
- Focus on unique features, not reinventing buttons
- Consistent patterns across projects
- Lower cognitive load for new team members

## Accessible Analogies

### The Prefab Building Analogy

Building UI from scratch is like constructing a house by making your own bricks, cutting your own lumber, and forging your own nails. Component libraries are like prefab building materials: pre-cut lumber, standard bricks, tested electrical components.

**Three approaches**:

1. **Full prefab home (MUI, Ant Design)**: Move-in ready, specific aesthetic, less customization
2. **Structural frame + your finishes (Mantine, Chakra)**: Foundation provided, you choose colors/style
3. **Certified building components (Radix, Headless UI)**: Safe electrical/plumbing (behavior/accessibility), you design everything else

### The Restaurant Analogy

**Pre-styled libraries (MUI, Ant Design)**:
- Like franchises (McDonald's, Starbucks)
- Consistent experience, proven recipes
- Customers recognize the brand
- Fast to open, but looks like every other location

**Customizable libraries (Chakra, Mantine)**:
- Like restaurant supply companies
- Provide equipment and base recipes
- You set the menu and ambiance
- Balance of speed and uniqueness

**Headless libraries (Radix, Headless UI)**:
- Like commercial kitchen equipment
- Provides ovens, refrigerators (the hard parts)
- You design the menu, plating, dining room entirely
- Maximum creativity, more work

### The Safety Equipment Analogy

**Accessibility** is like safety equipment in manufacturing:

- **Building without library**: Like factory workers without safety gear - accidents will happen
- **Pre-styled library**: Like factory with standard safety equipment - basics covered
- **Accessibility-first library (Radix, Headless UI)**: Like factory designed by safety engineers - best-in-class protection

### The Language Learning Analogy

**Learning curve** parallels language learning:

- **Simple library (Chakra props)**: Like learning with pictures and gestures - communicate quickly, limited depth
- **Complex library (Radix compounds)**: Like learning grammar - steep start, powerful long-term
- **Design-system library (MUI)**: Like learning formal business language - specific context, well-documented

## Key Concepts

### 1. Pre-Styled vs Headless/Unstyled

**Pre-Styled Libraries** come with visual design built in:
```tsx
// MUI Button - already styled as Material Design
import Button from '@mui/material/Button'
<Button variant="contained">Click Me</Button>
```

**Headless/Unstyled Libraries** provide behavior only - you add all styling:
```tsx
// Radix Dialog - no styles, full accessibility
import * as Dialog from '@radix-ui/react-dialog'
<Dialog.Root>
  <Dialog.Trigger className="your-styles-here">Open</Dialog.Trigger>
  <Dialog.Content className="your-styles-here">...</Dialog.Content>
</Dialog.Root>
```

### 2. Design Systems

Many component libraries implement a **design system** - a set of standards for visual design:

| Design System | Library | Creator |
|---------------|---------|---------|
| Material Design | MUI | Google |
| Ant Design System | Ant Design | Alibaba |
| Fluent Design | Fluent UI | Microsoft |
| Carbon Design | Carbon | IBM |

Using a design system means your UI will look like that system. This is good for consistency but limits brand differentiation.

### 3. Theming

**Theming** allows customizing a library's appearance without rewriting components:

```tsx
// Change primary color, fonts, spacing across entire app
const theme = {
  colors: { primary: '#007bff' },
  fonts: { body: 'Inter, sans-serif' },
  spacing: { unit: 8 },
}
```

Different libraries have different theming capabilities:
- **Deep theming**: Change almost everything (Chakra, Mantine)
- **Surface theming**: Change colors, fonts, but core design preserved (MUI, Ant)
- **Full control**: No theme, you style everything (Radix, Headless UI)

### 4. Accessibility (a11y)

Accessibility means users with disabilities can use your application:

- **Keyboard navigation**: Tab, Enter, Arrow keys, Escape
- **Screen readers**: Proper ARIA labels and roles
- **Focus management**: Visible focus indicators, focus trapping in modals
- **Color contrast**: Readable text on backgrounds

Modern component libraries handle most accessibility automatically. This is a major reason to use them instead of building from scratch.

### 5. CSS-in-JS vs Utility CSS vs Traditional CSS

**CSS-in-JS** (MUI, Chakra, Mantine):
```tsx
// Styles defined in JavaScript, scoped to component
<Box sx={{ padding: 2, backgroundColor: 'primary.main' }} />
```

**Utility CSS** (Tailwind, shadcn/ui):
```tsx
// Predefined utility classes composed inline
<div className="p-4 bg-blue-500 rounded-lg" />
```

**Traditional CSS** (Ant Design):
```tsx
// Separate CSS files with class names
<button className="ant-btn ant-btn-primary" />
```

Each has trade-offs:
- CSS-in-JS: Colocation, dynamic styles, but runtime cost
- Utility CSS: No runtime cost, but verbose HTML
- Traditional CSS: Familiar, but global scope issues

### 6. Tree Shaking

**Tree shaking** removes unused code from your final bundle:

```tsx
// Good: Only Dialog added to bundle
import { Dialog } from '@radix-ui/react-dialog'

// Bad: Entire library might be bundled
import Radix from '@radix-ui/react'
```

Modern libraries support tree shaking, but import patterns matter.

### 7. Compound Components

**Compound components** are multiple components that work together:

```tsx
// Single component (simple but inflexible)
<Dialog title="Edit" description="Make changes" onClose={...} />

// Compound components (flexible, composable)
<Dialog.Root>
  <Dialog.Trigger>Edit</Dialog.Trigger>
  <Dialog.Portal>
    <Dialog.Overlay />
    <Dialog.Content>
      <Dialog.Title>Edit</Dialog.Title>
      <Dialog.Description>Make changes</Dialog.Description>
      <Dialog.Close />
    </Dialog.Content>
  </Dialog.Portal>
</Dialog.Root>
```

Compound components give more control but require more code.

### 8. Controlled vs Uncontrolled

**Uncontrolled**: Component manages its own state
```tsx
// Library handles open/close internally
<Dialog defaultOpen={false}>...</Dialog>
```

**Controlled**: You manage the state
```tsx
// You control when dialog opens/closes
const [open, setOpen] = useState(false)
<Dialog open={open} onOpenChange={setOpen}>...</Dialog>
```

Most libraries support both patterns.

## Categories of UI Libraries

### Complete/Opinionated Libraries
Pre-styled, comprehensive component sets with a specific design language.
- Use when: Want to ship fast with consistent design
- Trade-off: Less brand differentiation

### Headless/Primitive Libraries
Behavior and accessibility only, no styling.
- Use when: Building custom design system
- Trade-off: More work to style

### Copy-Paste Libraries
Components you copy into your codebase and own.
- Use when: Want full control over code
- Trade-off: Updates require manual merging

### Utility-First Approaches
Not component libraries per se, but CSS frameworks that make building components easier.
- Use when: Team knows CSS well
- Trade-off: More boilerplate

## Common Patterns

### Provider Pattern
Wrap your app to provide theme/config to all components:
```tsx
<ThemeProvider theme={myTheme}>
  <App />
</ThemeProvider>
```

### Slot Pattern
Components that accept children for customization:
```tsx
<Button>
  <Icon slot="start" />
  Click Me
  <Badge slot="end">3</Badge>
</Button>
```

### Render Props / Function Children
Pass functions for custom rendering:
```tsx
<Listbox>
  {({ open }) => (
    <Listbox.Button>{open ? 'Close' : 'Open'}</Listbox.Button>
  )}
</Listbox>
```

## Trade-offs to Consider

### Bundle Size vs Features
More components = bigger bundle. Consider:
- How many components you'll actually use
- Whether library supports tree shaking
- Whether you need everything or just basics

### Flexibility vs Speed
- **Pre-styled**: Ship fast, look like everyone else
- **Headless**: More work, unique appearance

### Learning Curve vs Power
- Simple API: Easy to start, may hit limits
- Complex API: Steeper learning, more capabilities

### Vendor Lock-in vs Standardization
- Heavy theming = harder to switch libraries
- Headless = easier to swap implementations

## When You Need This

### Clear "Yes" Signals

**Use a component library when**:

1. **Timeline pressure**: Need working UI in 2-8 weeks
2. **No designer**: Team doesn't have dedicated design resources
3. **Accessibility requirement**: WCAG compliance mandated
4. **Multiple projects**: Building more than one application
5. **Team coordination**: 3+ developers need consistent patterns

### When You DON'T Need This

**Skip component libraries when**:

1. **UI is your unique value**: Building design tool, Figma competitor
2. **Extreme customization needed**: Every component is unique
3. **Learning exercise**: Intentionally studying component development
4. **Ultra-minimal site**: Single page with 2 buttons
5. **Design is "the product"**: Portfolio site where visual uniqueness is the point

### Decision Criteria

**Use pre-styled (MUI, Ant Design) when**:
- Need to ship in 2-4 weeks
- Team has < 3 developers
- Enterprise features required (data grids, complex forms)
- Material Design or Enterprise aesthetic acceptable

**Use customizable (Chakra, Mantine) when**:
- Need brand customization
- 4-8 week timeline acceptable
- Team comfortable with theming
- Want comprehensive component set

**Use headless (Radix, Headless UI) when**:
- Building custom design system
- Have design/CSS expertise
- 3-6 month timeline
- Accessibility is critical
- Want zero vendor lock-in

**Use copy-paste (shadcn/ui) when**:
- Using Tailwind CSS
- Want code ownership
- Need to tweak components frequently
- 2-6 week timeline

## Implementation Reality

### First 30 Days: What to Expect

**Week 1: Setup & Learning**
- Install library and dependencies (1-2 hours)
- Read documentation and copy basic examples (4-8 hours)
- Set up theming/customization (2-6 hours depending on library)
- **Feeling**: Overwhelmed by options, but getting results quickly

**Week 2-3: Building Core Features**
- Implement main UI flows (login, dashboard, etc.)
- Hit first customization challenges (need something the library doesn't do)
- Learn advanced patterns (compound components, render props)
- **Feeling**: Productive, occasional frustration with library limitations

**Week 4: Polish & Edge Cases**
- Handle responsive design
- Add animations/transitions
- Fix accessibility issues
- **Feeling**: Comfortable with library, know workarounds

### Realistic Timelines

**MVP (basic CRUD app)**:
- With library: 2-3 weeks
- From scratch: 4-6 weeks
- **Time saved**: 50%

**Enterprise dashboard**:
- With library: 2-3 months
- From scratch: 6-9 months
- **Time saved**: 60-70%

**Custom design system**:
- With headless library: 4-6 months
- From scratch: 12-18 months
- **Time saved**: 65%

### Team Skill Requirements

**Minimum viable team for each approach**:

**Pre-styled libraries (MUI, Ant Design)**:
- 1 React developer (intermediate)
- Basic CSS knowledge
- Can read documentation
- **Ramp-up time**: 3-5 days

**Customizable libraries (Chakra, Mantine)**:
- 1 React developer (intermediate-advanced)
- Good CSS knowledge (theming)
- Comfortable with component patterns
- **Ramp-up time**: 5-7 days

**Headless libraries (Radix, Headless UI)**:
- 1+ React developer (advanced)
- Strong CSS skills (Tailwind or CSS-in-JS)
- Understanding of accessibility
- **Ramp-up time**: 1-2 weeks

**Copy-paste (shadcn/ui)**:
- 1 React developer (intermediate)
- Tailwind CSS knowledge
- Comfortable editing component code
- **Ramp-up time**: 2-3 days

### Common Pitfalls

**Pitfall 1: Choosing based on GitHub stars**
- **Mistake**: "MUI has 95K stars, must use it"
- **Reality**: Stars indicate popularity, not fit for your needs
- **Solution**: Match library to project context (S3 analysis)

**Pitfall 2: Over-customizing pre-styled libraries**
- **Mistake**: Spending 2 weeks fighting MUI theme to look "not Material"
- **Reality**: If you need heavy customization, use headless from start
- **Solution**: Accept library aesthetic or choose headless

**Pitfall 3: Underestimating accessibility**
- **Mistake**: "We'll add accessibility later"
- **Reality**: Retrofitting accessibility takes 2-3 months
- **Solution**: Choose accessible library from start (Radix, Headless UI)

**Pitfall 4: Ignoring bundle size**
- **Mistake**: Adding MUI + Ant Design + Chakra "for different components"
- **Reality**: 600 KB+ bundle, poor performance
- **Solution**: Pick one library, stick with it

**Pitfall 5: Building custom when library exists**
- **Mistake**: "Our use case is unique, need custom solution"
- **Reality**: 95% of use cases are common
- **Solution**: Try library first, build custom only if truly doesn't work

### First 90 Days Progression

**Days 1-7**: Setup, basic understanding, simple pages
**Days 8-30**: Core features, learning advanced patterns
**Days 31-60**: Complex components, customization, edge cases
**Days 61-90**: Mastery, can teach others, efficient workflows

**Success indicators at 90 days**:
- Can implement new feature in 1-2 days (vs weeks initially)
- Know library limitations and workarounds
- Can help teammates debug issues
- Comfortable with library's patterns

### Long-Term Maintenance

**Ongoing time investment**:
- **Security updates**: 1-2 hours/month (npm audit, update dependencies)
- **Version upgrades**: 1-2 days per major version (every 1-3 years)
- **Bug fixes**: 2-4 hours/month (library bugs, workarounds)
- **Learning new features**: 3-4 hours/quarter

**Total**: ~5-10 hours/month for mature application

### When to Migrate Away

**Consider migration when**:
- Library abandoned (no updates for 12+ months)
- Major technical shift (CSS-in-JS → static CSS)
- Acquired company mandates different library
- Performance issues unsolvable in current library
- Customization fights exceed value of library

**Migration cost**: 2-6 months depending on application size

## Questions to Ask

1. **Does my team use Tailwind CSS?** → Consider shadcn/ui, Headless UI
2. **Do I need a specific design language?** → Consider MUI (Material), Ant Design
3. **Am I building a custom design system?** → Consider Radix, Headless UI
4. **How important is bundle size?** → Headless libraries are smaller
5. **Do I need Vue support?** → Headless UI, Ant Design Vue
6. **How much do I need to customize?** → More = prefer headless
7. **What's the timeline?** → < 4 weeks = pre-styled, > 3 months = headless OK
8. **What's the team size?** → Solo/small = simple, enterprise = comprehensive

## Evolution of the Space

### 2015-2018: Bootstrap Era
Bootstrap and Foundation dominated. jQuery-based, CSS classes.

### 2018-2021: React Component Libraries
MUI, Ant Design, Chakra UI emerged. CSS-in-JS became popular.

### 2021-2023: Headless Movement
Radix, Headless UI gained traction. Separation of behavior from styling.

### 2023-2025: Copy-Paste Model
shadcn/ui popularized owning component code. Tailwind integration standard.

### 2025 Trend
Developers want:
- Code ownership (not npm dependencies)
- Tailwind compatibility
- Excellent accessibility
- Smaller bundles

---

**Last Updated**: 2025-12-12
**Related Research**: 1.110 (Frontend Frameworks), 1.111 (State Management), 1.112 (CSS Frameworks)

</details><details>
<summary>S1: Rapid Discovery</summary>

# 1.113 UI Component Libraries - S1 Rapid Discovery

## Quick Decision Guide

| Situation | Recommendation |
|-----------|----------------|
| New React project (default) | **shadcn/ui** |
| Already using Tailwind | shadcn/ui or Headless UI |
| Enterprise with Material Design | MUI |
| Data-heavy admin panels | Ant Design |
| Building custom design system | Radix UI + Tailwind |
| Want full-featured + modern DX | Mantine |
| Prop-based styling preference | Chakra UI |
| Need Vue support | Headless UI |

## 2025 Landscape Summary

### By GitHub Stars (March 2025)
```
MUI:           ████████████████████████████████████  95K
Ant Design:    ███████████████████████████████████   94K
shadcn/ui:     █████████████████████████████████     85K
Chakra UI:     ███████████████                       39K
Mantine:       ███████████                           28K
Headless UI:   ██████████                            26K
Radix UI:      ███████                               17K
```

### By npm Weekly Downloads
```
MUI:           ████████████████████████████████████  4.1M
Ant Design:    ████████████████                      1.4M
Headless UI:   █████████                             800K
Chakra UI:     ██████                                587K
Mantine:       █████                                 500K
Radix UI:      ██                                    226K
```

Note: shadcn/ui uses copy-paste model (no npm downloads tracked).

## Library Categories

### 1. Pre-Styled Complete Libraries
Full component sets with design system baked in.

| Library | Design System | Customization | Best For |
|---------|---------------|---------------|----------|
| MUI | Material Design | Moderate | Consumer apps, dashboards |
| Ant Design | Enterprise | Limited | Admin panels, data apps |
| Chakra UI | Minimalist | Excellent | Custom branded apps |

### 2. Headless/Unstyled Primitives
Accessibility and behavior only - you add styles.

| Library | Maintainer | Framework | Use Case |
|---------|------------|-----------|----------|
| Radix UI | WorkOS | React | Building design systems |
| Headless UI | Tailwind Labs | React, Vue | Tailwind projects |

### 3. Copy-Paste Model
Components you own (copied into your codebase).

| Library | Foundation | Styling | Ownership |
|---------|------------|---------|-----------|
| shadcn/ui | Radix UI | Tailwind | Full code ownership |

### 4. Full-Featured Modern
Rich ecosystem with components + hooks.

| Library | Components | Hooks | Strength |
|---------|------------|-------|----------|
| Mantine | 120+ | 70+ | Best balance of features + DX |

## Decision Tree

```
Are you using Tailwind CSS?
├── Yes
│   ├── Want pre-built components? → shadcn/ui
│   └── Building from scratch? → Headless UI or Radix UI
└── No
    ├── Need Material Design look? → MUI
    ├── Building admin/data dashboard? → Ant Design
    ├── Want prop-based styling? → Chakra UI
    └── Want modern full-featured? → Mantine
```

## Quick Comparison

| Aspect | shadcn/ui | MUI | Ant Design | Chakra | Mantine | Radix |
|--------|-----------|-----|------------|--------|---------|-------|
| Stars | 85K | 95K | 94K | 39K | 28K | 17K |
| Styling | Tailwind | CSS-in-JS | Less/CSS | Props | CSS-in-JS | None |
| Bundle | 0 (copy) | Large | Large | Medium | Medium | Small |
| Customization | Full | Moderate | Limited | Excellent | High | Full |
| Learning Curve | Low | Medium | Medium | Low | Low | Medium |
| Accessibility | Excellent | Good | Good | Excellent | Excellent | Excellent |

## 2025 Trends

1. **shadcn/ui dominance**: Copy-paste model wins - developers want code ownership
2. **Headless foundation**: Radix powers shadcn/ui, others build on primitives
3. **Tailwind integration**: Most new libraries assume Tailwind
4. **Accessibility first**: All major libraries now WAI-ARIA compliant
5. **Smaller bundles**: Tree-shaking, modular imports standard

## Sources

- [React UI Libraries 2025 - Makers Den](https://makersden.io/blog/react-ui-libs-2025-comparing-shadcn-radix-mantine-mui-chakra)
- [Best React UI Component Libraries - Croct](https://blog.croct.com/post/best-react-ui-component-libraries)
- [Radix Primitives](https://www.radix-ui.com/primitives)
- [Headless UI](https://headlessui.com/)
- [Mantine](https://mantine.dev/)


---

# Ant Design

> "A design system for enterprise-level products."

## Quick Facts

| Metric | Value |
|--------|-------|
| GitHub Stars | ~94,000 |
| npm Weekly Downloads | ~1.4M |
| Bundle Size | Large |
| License | MIT |
| Developer | Alibaba |
| Design System | Ant Design System |

## What Ant Design Is

Ant Design is Alibaba's enterprise-focused React component library. It's optimized for **data-heavy applications**, admin panels, and B2B products.

## Why Ant Design Excels

### Enterprise Features
- **Table**: Sorting, filtering, pagination, fixed columns, virtual scrolling
- **Form**: Complex validation, field dependencies, array fields
- **Tree**: Drag-and-drop, virtual scrolling, checkable
- **DatePicker**: Comprehensive date/time/range selection

### Comprehensive Documentation
Ant Design's docs are exceptionally detailed with:
- Component API reference
- Design guidelines
- Best practices
- Code examples

### Strong in Asia/Enterprise
Dominant choice for:
- Chinese tech companies
- Enterprise B2B applications
- Admin dashboards
- Data management systems

## Key Features

### 60+ Components
More components than most alternatives:
- **General**: Button, Icon, Typography
- **Layout**: Divider, Grid, Layout, Space
- **Navigation**: Affix, Breadcrumb, Dropdown, Menu, Pagination, Steps
- **Data Entry**: Checkbox, DatePicker, Form, Input, Select, Upload
- **Data Display**: Carousel, Collapse, Table, Tabs, Timeline, Tree
- **Feedback**: Alert, Message, Modal, Notification, Progress, Spin

### Design Tokens
```tsx
import { ConfigProvider } from 'antd'

<ConfigProvider
  theme={{
    token: {
      colorPrimary: '#00b96b',
      borderRadius: 2,
    },
  }}
>
  <App />
</ConfigProvider>
```

### Pro Components
[Ant Design Pro](https://pro.ant.design/) provides:
- ProTable (enhanced table)
- ProForm (enhanced form)
- ProList (enhanced list)
- ProLayout (admin layout)

## When to Choose Ant Design

**Choose Ant Design when:**
- Building admin panels / dashboards
- Heavy table/data requirements
- Enterprise B2B applications
- Need comprehensive component set
- Chinese market / team

**Consider alternatives when:**
- Building consumer apps → MUI
- Want custom brand look → shadcn/ui, Chakra
- Using Tailwind → shadcn/ui
- Need smaller bundle → Mantine
- Need flexibility → Chakra UI

## Drawbacks

1. **Customization is difficult**: Changing look significantly is hard
2. **Bundle size**: One of the largest libraries
3. **Opinionated design**: "Ant look" is recognizable
4. **CSS override complexity**: Global CSS can be tricky

## Ant Design vs MUI

| Aspect | Ant Design | MUI |
|--------|------------|-----|
| Focus | Enterprise/Admin | Consumer/Enterprise |
| Table | Excellent | Good (MUI X better) |
| Form | Excellent | Good |
| Design | Professional | Material |
| Customization | Limited | Moderate |
| Documentation | Excellent | Excellent |
| Icons | 500+ | Material Icons |

## Ecosystem

- **Ant Design Pro**: Admin templates
- **Ant Design Mobile**: Mobile components
- **Ant Design Charts**: Data visualization
- **Ant Design Pro Components**: Enhanced components

## Resources

- [Official Docs](https://ant.design/)
- [GitHub](https://github.com/ant-design/ant-design)
- [Ant Design Pro](https://pro.ant.design/)
- [Component List](https://ant.design/components/overview/)


---

# Chakra UI

> "Create accessible React apps with speed."

## Quick Facts

| Metric | Value |
|--------|-------|
| GitHub Stars | ~38,800 |
| npm Weekly Downloads | ~587,000 |
| Bundle Size | Medium |
| License | MIT |
| Styling | Prop-based (Style Props) |
| Focus | DX + Accessibility |

## What Makes Chakra Different

Chakra UI's key innovation is **prop-based styling**:

```tsx
// Traditional (CSS/className)
<button className="bg-blue-500 px-4 py-2 rounded">Click</button>

// Chakra (Style Props)
<Button bg="blue.500" px={4} py={2} borderRadius="md">Click</Button>
```

This eliminates the need to:
- Write CSS files
- Create CSS classes
- Switch between files

## Key Features

### Style Props
Every CSS property is available as a prop:

```tsx
<Box
  mt={4}                    // margin-top
  p={[2, 4, 6]}            // responsive padding
  bg="gray.100"            // background
  _hover={{ bg: 'gray.200' }} // pseudo-selectors
  display={{ base: 'block', md: 'flex' }} // responsive
>
  Content
</Box>
```

### Responsive by Default
```tsx
// Mobile: 100%, Tablet: 50%, Desktop: 25%
<Box width={{ base: '100%', md: '50%', lg: '25%' }}>
  Responsive without media queries
</Box>
```

### Excellent Accessibility
- All components are WAI-ARIA compliant
- Focus management built-in
- Keyboard navigation
- Screen reader support

### Easy Theming
```tsx
import { extendTheme } from '@chakra-ui/react'

const theme = extendTheme({
  colors: {
    brand: {
      50: '#f5fee5',
      500: '#38A169',
      900: '#1a202c',
    },
  },
  fonts: {
    heading: 'Inter, sans-serif',
    body: 'Inter, sans-serif',
  },
})
```

## Component Library

50+ components:

**Layout**: Box, Center, Container, Flex, Grid, Stack, Wrap
**Forms**: Button, Checkbox, Input, Radio, Select, Slider, Switch, Textarea
**Data Display**: Avatar, Badge, Card, List, Table, Tag
**Feedback**: Alert, Progress, Skeleton, Spinner, Toast
**Overlay**: Drawer, Menu, Modal, Popover, Tooltip
**Typography**: Heading, Text, Highlight

## When to Choose Chakra UI

**Choose Chakra when:**
- Want fast development with excellent DX
- Building custom-branded applications
- Need high customization without fighting framework
- Want accessible components by default
- Prefer props over CSS

**Consider alternatives when:**
- Using Tailwind → shadcn/ui
- Need enterprise data table → Ant Design, MUI
- Want Material Design → MUI
- Need more components → Mantine

## Drawbacks

1. **Fewer components** than MUI/Ant Design
2. **Style props can get verbose** for complex styling
3. **Runtime CSS-in-JS** (performance in some cases)
4. **No data table** (use third-party like TanStack Table)

## Chakra vs Alternatives

| Aspect | Chakra UI | MUI | shadcn/ui |
|--------|-----------|-----|-----------|
| Styling | Props | CSS-in-JS | Tailwind |
| Customization | Excellent | Moderate | Full |
| Bundle | Medium | Large | Zero |
| Components | 50+ | 50+ | 40+ |
| Learning | Easy | Medium | Low |

## Resources

- [Official Docs](https://chakra-ui.com/)
- [GitHub](https://github.com/chakra-ui/chakra-ui)
- [Component Docs](https://chakra-ui.com/docs/components)
- [Chakra Templates](https://chakra-templates.dev/)


---

# UI Component Libraries - Comparison Matrix

## Quantitative Comparison

| Library | Stars | Weekly DL | Bundle | Components | Hooks |
|---------|-------|-----------|--------|------------|-------|
| MUI | 95K | 4.1M | Large | 50+ | Few |
| Ant Design | 94K | 1.4M | Large | 60+ | Few |
| shadcn/ui | 85K | N/A | Zero | 40+ | - |
| Chakra UI | 39K | 587K | Medium | 50+ | Few |
| Mantine | 28K | 500K | Medium | 120+ | 70+ |
| Headless UI | 26K | 800K | Small | 10 | - |
| Radix UI | 17K | 226K | Small | 25+ | - |

## Styling Approach

| Library | Approach | CSS Solution | Customization |
|---------|----------|--------------|---------------|
| shadcn/ui | Pre-styled + ownership | Tailwind CSS | Full |
| MUI | Pre-styled | Emotion (CSS-in-JS) | Moderate |
| Ant Design | Pre-styled | Less/CSS | Limited |
| Chakra UI | Prop-based | Emotion (CSS-in-JS) | Excellent |
| Mantine | CSS-in-JS | PostCSS modules | High |
| Radix UI | Unstyled | None (you add) | Full |
| Headless UI | Unstyled | None (you add) | Full |

## Feature Matrix

| Feature | shadcn | MUI | Ant | Chakra | Mantine | Radix | Headless |
|---------|--------|-----|-----|--------|---------|-------|----------|
| Accessibility | ★★★★★ | ★★★★ | ★★★★ | ★★★★★ | ★★★★★ | ★★★★★ | ★★★★★ |
| Theming | ★★★★ | ★★★★★ | ★★★★ | ★★★★★ | ★★★★★ | ★★★ | ★★★ |
| Documentation | ★★★★★ | ★★★★★ | ★★★★★ | ★★★★ | ★★★★★ | ★★★★ | ★★★★ |
| TypeScript | ★★★★★ | ★★★★★ | ★★★★★ | ★★★★★ | ★★★★★ | ★★★★★ | ★★★★★ |
| SSR Support | ★★★★★ | ★★★★ | ★★★★ | ★★★★ | ★★★★★ | ★★★★★ | ★★★★★ |
| Dark Mode | ★★★★★ | ★★★★ | ★★★★ | ★★★★★ | ★★★★★ | ★★★★ | ★★★★ |
| Data Table | - | ★★★★ | ★★★★★ | ★★★ | ★★★★ | - | - |
| Form Handling | ★★★★ | ★★★ | ★★★★★ | ★★★ | ★★★★★ | - | - |

## Use Case Fit

| Use Case | Best Choice | Runner-up |
|----------|-------------|-----------|
| New React project | shadcn/ui | Mantine |
| Tailwind project | shadcn/ui | Headless UI |
| Enterprise dashboard | Ant Design | MUI |
| Data-heavy admin | Ant Design | MUI |
| Material Design | MUI | - |
| Custom design system | Radix UI | Headless UI |
| Custom brand | Chakra UI | shadcn/ui |
| Full-featured modern | Mantine | MUI |
| Vue support needed | Headless UI | - |
| Maximum flexibility | Radix UI | Headless UI |

## Framework Support

| Library | React | Vue | Angular | Solid |
|---------|-------|-----|---------|-------|
| shadcn/ui | ✅ | ❌ | ❌ | ❌ |
| MUI | ✅ | ❌ | ❌ | ❌ |
| Ant Design | ✅ | ✅ | ❌ | ❌ |
| Chakra UI | ✅ | ❌ | ❌ | ❌ |
| Mantine | ✅ | ❌ | ❌ | ❌ |
| Radix UI | ✅ | ❌ | ❌ | ❌ |
| Headless UI | ✅ | ✅ | ❌ | ❌ |

## Bundle Size Impact

```
Approximate size after tree-shaking (typical usage):

shadcn/ui:     0KB (code copied, no runtime dependency)
Radix UI:      █ ~15KB
Headless UI:   █ ~12KB
Chakra UI:     ████████ ~80KB
Mantine:       ████████ ~85KB
MUI:           ██████████████ ~140KB
Ant Design:    ████████████████ ~160KB
```

## Learning Curve

```
Easy ──────────────────────────────────────────────── Hard

shadcn/ui ►       (Tailwind + copy-paste)
Chakra UI ►       (props = CSS)
Mantine ►──►      (many features to learn)
Headless UI ►──►  (add all styling)
Radix UI ►──►──►  (primitives, more parts)
MUI ►──►──►       (theming system)
Ant Design ►──►──► (many components, config)
```

## Decision Tree

```
Do you use Tailwind CSS?
├── Yes
│   ├── Want pre-styled? → shadcn/ui
│   ├── Building design system? → Radix UI + Tailwind
│   └── Need Vue? → Headless UI
└── No
    ├── Want Material Design? → MUI
    ├── Building admin/dashboard? → Ant Design
    ├── Want prop-based styling? → Chakra UI
    └── Want most features? → Mantine
```

## 2025 Recommendation Summary

| Priority | Library | Reason |
|----------|---------|--------|
| 1st | **shadcn/ui** | Code ownership + Tailwind + modern DX |
| 2nd | **Mantine** | Most features, great hooks, modern |
| 3rd | **MUI** | Enterprise standard, Material Design |
| 4th | **Ant Design** | Data-heavy enterprise apps |
| 5th | **Chakra UI** | Best prop-based DX |
| 6th | **Radix UI** | Custom design system foundation |
| 7th | **Headless UI** | Tailwind + Vue support |


---

# Headless UI

> "Completely unstyled, fully accessible UI components, designed to integrate beautifully with Tailwind CSS."

## Quick Facts

| Metric | Value |
|--------|-------|
| GitHub Stars | ~26,000 |
| npm Weekly Downloads | ~800,000 |
| Bundle Size | Small |
| License | MIT |
| Maintainer | Tailwind Labs |
| Framework | React & Vue |

## What Headless UI Is

Headless UI is Tailwind Labs' official component library. It provides the **behavior and accessibility** of complex UI components without any styling - you use Tailwind (or any CSS) to style them.

## Key Differentiator: Vue Support

Unlike Radix (React only), Headless UI supports both React and Vue:

```bash
# React
npm install @headlessui/react

# Vue
npm install @headlessui/vue
```

## How It Works

```tsx
import { Dialog, Transition } from '@headlessui/react'
import { Fragment } from 'react'

function MyDialog({ isOpen, setIsOpen }) {
  return (
    <Transition appear show={isOpen} as={Fragment}>
      <Dialog onClose={() => setIsOpen(false)}>
        <Transition.Child
          enter="ease-out duration-300"
          enterFrom="opacity-0"
          enterTo="opacity-100"
          leave="ease-in duration-200"
          leaveFrom="opacity-100"
          leaveTo="opacity-0"
        >
          <div className="fixed inset-0 bg-black/25" />
        </Transition.Child>

        <div className="fixed inset-0 overflow-y-auto">
          <Dialog.Panel className="mx-auto max-w-md rounded bg-white p-6">
            <Dialog.Title className="text-lg font-medium">
              Payment successful
            </Dialog.Title>
            <Dialog.Description>
              Your payment has been processed.
            </Dialog.Description>
            <button onClick={() => setIsOpen(false)}>
              Got it, thanks!
            </button>
          </Dialog.Panel>
        </div>
      </Dialog>
    </Transition>
  )
}
```

## Key Features

### Tailwind CSS Plugin
```js
// tailwind.config.js
module.exports = {
  plugins: [
    require('@headlessui/tailwindcss')
  ],
}
```

Enables state-based styling:
```html
<Listbox.Option className="ui-active:bg-blue-500 ui-active:text-white">
  Option
</Listbox.Option>
```

### Built-in Transitions
```tsx
<Transition
  show={isOpen}
  enter="transition-opacity duration-75"
  enterFrom="opacity-0"
  enterTo="opacity-100"
  leave="transition-opacity duration-150"
  leaveFrom="opacity-100"
  leaveTo="opacity-0"
>
  <div>Content</div>
</Transition>
```

### Full Accessibility
- WAI-ARIA compliant
- Keyboard navigation
- Focus management
- Screen reader support

## Available Components

| Component | Description |
|-----------|-------------|
| Menu | Dropdown menus |
| Listbox | Custom select |
| Combobox | Autocomplete select |
| Switch | Toggle switch |
| Disclosure | Show/hide content |
| Dialog | Modal dialogs |
| Popover | Floating panels |
| Radio Group | Radio buttons |
| Tabs | Tabbed interface |
| Transition | CSS transitions |

**Note**: Fewer components than Radix (~10 vs 25+), but covers most common needs.

## When to Choose Headless UI

**Choose Headless UI when:**
- Using Tailwind CSS
- Need Vue support
- Building with Tailwind UI templates
- Want official Tailwind integration
- Need simple, focused component set

**Consider alternatives when:**
- Need more components → Radix UI (25+)
- Want pre-styled → shadcn/ui
- Not using Tailwind → Radix UI

## Headless UI vs Radix

| Aspect | Headless UI | Radix UI |
|--------|-------------|----------|
| Maintainer | Tailwind Labs | WorkOS |
| Framework | React, Vue | React only |
| Components | ~10 | 25+ |
| Focus | Tailwind integration | General headless |
| Transitions | Built-in | Separate |

## Resources

- [Official Docs](https://headlessui.com/)
- [GitHub](https://github.com/tailwindlabs/headlessui)
- [Tailwind UI](https://tailwindui.com/) (premium, uses Headless UI)


---

# Mantine

> "A fully featured React components library."

## Quick Facts

| Metric | Value |
|--------|-------|
| GitHub Stars | ~28,000 |
| npm Weekly Downloads | ~500,000 |
| Bundle Size | Medium |
| License | MIT |
| Components | 120+ |
| Hooks | 70+ |
| Current Version | 8.x (2025) |

## Why Mantine Stands Out

Mantine offers the **best balance of features, modern DX, and flexibility** in 2025. It's like MUI but with better developer experience and more hooks.

Key differentiators:
1. **120+ components** - More than Chakra
2. **70+ hooks** - More than any competitor
3. **Modular packages** - Install only what you need
4. **Modern defaults** - Dark mode, SSR, TypeScript

## Modular Architecture

Install only what you need:

```bash
npm install @mantine/core @mantine/hooks  # Core + hooks
npm install @mantine/form                  # Form management
npm install @mantine/dates                 # Date pickers
npm install @mantine/notifications         # Toast notifications
npm install @mantine/modals               # Modal manager
npm install @mantine/spotlight            # Command palette
npm install @mantine/carousel             # Carousel
npm install @mantine/dropzone             # File upload
npm install @mantine/tiptap               # Rich text editor
```

## Key Features

### Component Library (120+)
Everything you need:
- All standard components (buttons, inputs, etc.)
- Rich text editor (Tiptap integration)
- Date pickers
- File upload with dropzone
- Command palette (Spotlight)
- Charts and data visualization

### Hooks Library (70+)
```tsx
import {
  useDebouncedValue,
  useClickOutside,
  useMediaQuery,
  useLocalStorage,
  useHotkeys,
  useIdle,
  useNetwork,
  useClipboard
} from '@mantine/hooks'

// Works standalone - no Mantine UI required
const [value, setValue] = useState('')
const [debounced] = useDebouncedValue(value, 200)
```

### Form Management
```tsx
import { useForm } from '@mantine/form'

const form = useForm({
  initialValues: { email: '', password: '' },
  validate: {
    email: (value) => (/^\S+@\S+$/.test(value) ? null : 'Invalid email'),
    password: (value) => (value.length >= 6 ? null : 'Too short'),
  },
})

return (
  <form onSubmit={form.onSubmit(handleSubmit)}>
    <TextInput {...form.getInputProps('email')} />
    <PasswordInput {...form.getInputProps('password')} />
    <Button type="submit">Submit</Button>
  </form>
)
```

### Theming
```tsx
import { MantineProvider, createTheme } from '@mantine/core'

const theme = createTheme({
  primaryColor: 'violet',
  fontFamily: 'Inter, sans-serif',
  defaultRadius: 'md',
})

<MantineProvider theme={theme}>
  <App />
</MantineProvider>
```

## When to Choose Mantine

**Choose Mantine when:**
- Want full-featured library with modern DX
- Need extensive hooks library
- Building applications with many forms
- Want built-in dark mode
- Need date pickers, rich text, file upload

**Consider alternatives when:**
- Using Tailwind → shadcn/ui
- Need Material Design → MUI
- Building admin panels → Ant Design
- Want smallest bundle → Chakra

## Mantine vs Alternatives

| Aspect | Mantine | MUI | Chakra | Ant Design |
|--------|---------|-----|--------|------------|
| Components | 120+ | 50+ | 50+ | 60+ |
| Hooks | 70+ | Few | Few | Few |
| Styling | CSS-in-JS | CSS-in-JS | Props | CSS |
| Bundle | Medium | Large | Medium | Large |
| DX | Excellent | Good | Excellent | Good |
| Form | Built-in | External | External | Built-in |

## Unique Features

- **Spotlight**: Command palette (Cmd+K)
- **Notifications**: Toast system
- **Modals manager**: Programmatic modals
- **Rich text**: Tiptap integration
- **Dropzone**: File upload with preview
- **Carousel**: Built-in carousel

## Resources

- [Official Docs](https://mantine.dev/)
- [GitHub](https://github.com/mantinedev/mantine)
- [Hooks](https://mantine.dev/hooks/package/)
- [UI Components](https://mantine.dev/core/getting-started/)


---

# MUI (Material UI)

> "Move faster with intuitive React UI tools."

## Quick Facts

| Metric | Value |
|--------|-------|
| GitHub Stars | ~95,000 |
| npm Weekly Downloads | ~4.1M |
| Bundle Size | Large |
| License | MIT |
| Design System | Google Material Design |
| First Release | 2014 |

## Why MUI Still Leads

Despite newer alternatives, MUI remains the most downloaded React UI library because:

1. **Enterprise adoption**: Spotify, Amazon, Netflix use MUI
2. **Material Design**: Familiar, polished look
3. **Mature ecosystem**: 10+ years of development
4. **Documentation**: Excellent, comprehensive docs
5. **Component coverage**: Everything you need

## Key Features

### Material Design Implementation
MUI implements Google's Material Design spec, providing a consistent, professional look out of the box.

### Theming System
```tsx
import { createTheme, ThemeProvider } from '@mui/material/styles'

const theme = createTheme({
  palette: {
    primary: { main: '#1976d2' },
    secondary: { main: '#dc004e' },
  },
  typography: {
    fontFamily: 'Roboto, Arial, sans-serif',
  },
})

function App() {
  return (
    <ThemeProvider theme={theme}>
      <YourApp />
    </ThemeProvider>
  )
}
```

### sx Prop for Styling
```tsx
<Box
  sx={{
    width: 300,
    height: 300,
    backgroundColor: 'primary.main',
    '&:hover': { backgroundColor: 'primary.dark' },
  }}
/>
```

### Comprehensive Components
50+ components:
- **Inputs**: Button, Checkbox, Radio, Select, Slider, Switch, TextField
- **Data Display**: Avatar, Badge, Chip, List, Table, Typography
- **Feedback**: Alert, Backdrop, Dialog, Progress, Skeleton, Snackbar
- **Surfaces**: Accordion, App Bar, Card, Paper
- **Navigation**: Breadcrumbs, Drawer, Menu, Pagination, Tabs
- **Layout**: Box, Container, Grid, Stack

## MUI X (Premium)

Extended components (some paid):

| Component | License |
|-----------|---------|
| Data Grid | MIT (basic), Pro/Premium (advanced) |
| Date Pickers | MIT |
| Charts | MIT (basic), Pro (advanced) |
| Tree View | MIT |

## When to Choose MUI

**Choose MUI when:**
- Building enterprise applications
- Want Material Design aesthetic
- Need comprehensive component library
- Team familiar with Material Design
- Need Data Grid with sorting/filtering

**Consider alternatives when:**
- Want custom brand look → shadcn/ui, Chakra
- Using Tailwind → shadcn/ui
- Need smaller bundle → Mantine, Chakra
- Building admin panel → Ant Design

## Drawbacks

1. **Material look is hard to escape**: Customization can fight the design system
2. **Bundle size**: Larger than alternatives
3. **CSS-in-JS**: Emotion dependency adds complexity
4. **Learning curve**: Theming system takes time

## MUI vs Alternatives

| Aspect | MUI | Ant Design | Chakra UI |
|--------|-----|------------|-----------|
| Stars | 95K | 94K | 39K |
| Downloads | 4.1M | 1.4M | 587K |
| Design | Material | Enterprise | Minimalist |
| Customization | Moderate | Limited | Excellent |
| Bundle | Large | Large | Medium |
| Data Grid | Excellent | Good | Basic |

## Resources

- [Official Docs](https://mui.com/)
- [GitHub](https://github.com/mui/material-ui)
- [Component API](https://mui.com/material-ui/api/)
- [Templates](https://mui.com/store/)


---

# Radix UI

> "Low-level UI component library with a focus on accessibility, customization and developer experience."

## Quick Facts

| Metric | Value |
|--------|-------|
| GitHub Stars | ~17,000 |
| npm Weekly Downloads | ~226,000 |
| Bundle Size | Small (per-component imports) |
| License | MIT |
| Maintainer | WorkOS |
| Framework | React only |

## What Radix UI Is

Radix UI is a collection of **unstyled, accessible UI primitives**. It provides the behavior and accessibility of complex components (dialogs, dropdowns, tabs) without any visual styling.

Think of it as the "engine" of UI components - you add the "body" (styles).

## Why Radix Matters

Radix powers many popular libraries:
- **shadcn/ui** - Built entirely on Radix primitives
- Many design systems use Radix as foundation

Building accessible UI components is hard:
- ARIA attributes
- Keyboard navigation
- Focus management
- Screen reader support

Radix handles all of this, letting you focus on styling.

## How It Works

```tsx
import * as Dialog from '@radix-ui/react-dialog'

// Completely unstyled - you add all CSS
function MyDialog() {
  return (
    <Dialog.Root>
      <Dialog.Trigger>Open</Dialog.Trigger>
      <Dialog.Portal>
        <Dialog.Overlay className="fixed inset-0 bg-black/50" />
        <Dialog.Content className="fixed top-1/2 left-1/2 ...">
          <Dialog.Title>Edit Profile</Dialog.Title>
          <Dialog.Description>Make changes here.</Dialog.Description>
          <Dialog.Close>Close</Dialog.Close>
        </Dialog.Content>
      </Dialog.Portal>
    </Dialog.Root>
  )
}
```

## Key Features

### Accessibility Built-in
- WAI-ARIA compliant
- Keyboard navigation (Arrow keys, Escape, Tab)
- Focus trapping in modals
- Screen reader announcements
- Correct ARIA roles and attributes

### Composable Architecture
Each component exposes multiple parts you can style independently:

```tsx
// Full control over each part
<Accordion.Root>
  <Accordion.Item>
    <Accordion.Header>
      <Accordion.Trigger />
    </Accordion.Header>
    <Accordion.Content />
  </Accordion.Item>
</Accordion.Root>
```

### Controlled & Uncontrolled
```tsx
// Uncontrolled (internal state)
<Dialog.Root>...</Dialog.Root>

// Controlled (you manage state)
<Dialog.Root open={isOpen} onOpenChange={setIsOpen}>
  ...
</Dialog.Root>
```

### Tree-shakeable
Import only what you need:
```tsx
import * as Dialog from '@radix-ui/react-dialog'
import * as Tabs from '@radix-ui/react-tabs'
// Only these components in your bundle
```

## Available Primitives

**Overlay**: Dialog, Alert Dialog, Popover, Tooltip, Hover Card, Context Menu, Dropdown Menu
**Form**: Checkbox, Radio Group, Select, Slider, Switch, Toggle, Toggle Group
**Navigation**: Navigation Menu, Tabs, Menubar
**Layout**: Accordion, Collapsible, Scroll Area, Separator
**Utility**: Avatar, Aspect Ratio, Progress, Label, Visually Hidden

## When to Choose Radix

**Choose Radix when:**
- Building a custom design system
- Need full styling control
- Want accessible primitives without opinions
- Using with Tailwind or any CSS solution
- Building component library for your org

**Consider alternatives when:**
- Want pre-styled components → shadcn/ui (uses Radix!)
- Need Vue support → Headless UI
- Want everything out of box → MUI, Mantine

## Radix vs Others

| Aspect | Radix UI | Headless UI | shadcn/ui |
|--------|----------|-------------|-----------|
| Styling | None | None | Tailwind |
| Components | 25+ | 10 | 40+ |
| Maintainer | WorkOS | Tailwind Labs | Community |
| Framework | React | React, Vue | React |

## Resources

- [Official Docs](https://www.radix-ui.com/primitives)
- [GitHub](https://github.com/radix-ui/primitives)
- [Accessibility Guide](https://www.radix-ui.com/primitives/docs/overview/accessibility)


---

# UI Component Library Recommendation Guide

## Decision Framework

This guide helps you choose the right UI component library based on your specific needs.

## Quick Decision Tree

```
Start Here
│
├─ Are you using Tailwind CSS?
│  ├─ Yes, want pre-styled components
│  │  └─ shadcn/ui ✓
│  ├─ Yes, building custom design system
│  │  └─ Radix UI + Tailwind ✓
│  └─ Yes, need Vue support
│     └─ Headless UI ✓
│
├─ Do you want Material Design aesthetic?
│  └─ Yes → MUI ✓
│
├─ Are you building an admin panel or data dashboard?
│  └─ Yes → Ant Design ✓
│
├─ Do you prefer styling via props instead of CSS?
│  └─ Yes → Chakra UI ✓
│
└─ Do you want the most features (components + hooks)?
   └─ Yes → Mantine ✓
```

## Recommendation by Use Case

### 1. New React Project (Default Case)

**Recommended**: shadcn/ui
- Modern, uses Tailwind CSS
- Copy-paste = you own the code
- Built on Radix (excellent accessibility)
- Most popular choice in 2025

**Alternative**: Mantine (if not using Tailwind)

---

### 2. Enterprise Application with Material Design

**Recommended**: MUI
- Google Material Design implementation
- Trusted by Spotify, Netflix, Amazon
- Excellent documentation
- MUI X for advanced data grid

**Alternative**: Ant Design (if data-heavy)

---

### 3. Admin Panel / Data Dashboard

**Recommended**: Ant Design
- Best tables with sorting, filtering, pagination
- Form handling is excellent
- Pro Components for advanced features
- Dominant in enterprise space

**Alternative**: MUI (if prefer Material Design)

---

### 4. Custom Design System from Scratch

**Recommended**: Radix UI
- Unstyled, accessible primitives
- Full control over styling
- Powers shadcn/ui underneath
- 25+ components

**Alternative**: Headless UI (fewer components, Vue support)

---

### 5. Tailwind CSS Project

**Recommended**: shadcn/ui
- Purpose-built for Tailwind
- Copy code into your project
- Excellent integration
- Beautiful default styling

**Alternative**: Headless UI (more minimal, Vue support)

---

### 6. Custom Branded Consumer App

**Recommended**: Chakra UI
- Prop-based styling is fast
- Easy to customize completely
- Great accessibility
- Clean, minimal defaults

**Alternative**: shadcn/ui (if using Tailwind)

---

### 7. Full-Featured Modern Development

**Recommended**: Mantine
- 120+ components
- 70+ utility hooks
- Built-in form handling
- Date pickers, rich text, file upload

**Alternative**: MUI (more enterprise-focused)

---

### 8. Need Vue Support

**Recommended**: Headless UI
- Official Tailwind Labs library
- Works with React AND Vue
- Unstyled, accessible

**Alternative**: Ant Design Vue (pre-styled Vue version)

---

## Recommendation by Team Size

### Solo Developer / Small Team
**Recommended**: shadcn/ui or Chakra UI
- Fast setup
- Little to configure
- Good defaults

### Mid-Size Team
**Recommended**: Mantine or MUI
- More features to leverage
- Good documentation
- Theming system scales

### Enterprise Team
**Recommended**: MUI or Ant Design
- Proven at scale
- Comprehensive components
- Enterprise support available

---

## Recommendation by Priority

### Speed to Market
1. shadcn/ui (if Tailwind)
2. Chakra UI (if not Tailwind)
3. Mantine

### Maximum Customization
1. Radix UI (build from scratch)
2. shadcn/ui (own the code)
3. Chakra UI (prop-based)

### Enterprise Features
1. Ant Design (data tables, forms)
2. MUI (Material Design)
3. Mantine (modern enterprise)

### Accessibility
All modern libraries are good, but:
1. Radix UI (accessibility-first design)
2. shadcn/ui (built on Radix)
3. Chakra UI (WCAG compliant)

---

## When to Use Multiple Libraries

### Radix UI + shadcn/ui
- shadcn/ui IS Radix + Tailwind styling
- No conflict, they're the same foundation

### MUI + TanStack Table
- MUI tables are basic
- TanStack Table for advanced data needs

### Any Library + TanStack Query
- All libraries work with TanStack Query for data fetching

---

## Migration Considerations

### From MUI to shadcn/ui
- Significant effort (different styling approach)
- Consider for new projects, not migrations

### From Bootstrap to Modern
- Chakra UI is easiest (prop-based like Bootstrap classes)
- Mantine is good alternative

### From Custom CSS to Component Library
- Chakra UI (props replace CSS)
- shadcn/ui (keep using Tailwind patterns)

---

## Bundle Size Considerations

If bundle size matters:

| Priority | Library | Approximate Size |
|----------|---------|------------------|
| 1st | shadcn/ui | 0KB (copied code) |
| 2nd | Radix UI | ~15KB |
| 3rd | Headless UI | ~12KB |
| 4th | Chakra UI | ~80KB |
| 5th | Mantine | ~85KB |
| 6th | MUI | ~140KB |
| 7th | Ant Design | ~160KB |

---

## Common Mistakes to Avoid

1. **Choosing MUI just because it's popular** - Consider alternatives if not doing Material Design
2. **Using Ant Design for consumer apps** - It's optimized for admin panels
3. **Not considering Tailwind first** - If using Tailwind, shadcn/ui is the obvious choice
4. **Ignoring headless options** - Radix/Headless UI are powerful for custom work
5. **Over-customizing pre-styled libraries** - If fighting the library, use headless instead

---

## Summary

### Best Overall (2025)
**shadcn/ui** - Code ownership + Tailwind + modern DX

### Best for Enterprise
**MUI** (Material Design) or **Ant Design** (data-heavy)

### Best Developer Experience
**Chakra UI** (props) or **Mantine** (features + hooks)

### Best for Custom Design Systems
**Radix UI** - Unstyled, accessible primitives

### Best for Vue
**Headless UI** - Only major headless library with Vue support

---

## Final Advice

1. **Default to shadcn/ui** for new React projects using Tailwind
2. **Consider Mantine** if you want more built-in features
3. **Use MUI/Ant Design** for enterprise applications
4. **Choose Radix** if building a design system from scratch
5. **All major libraries** now have excellent accessibility - pick based on other factors


---

# shadcn/ui

> "Beautifully designed components that you can copy and paste into your apps."

## Quick Facts

| Metric | Value |
|--------|-------|
| GitHub Stars | 85,500 |
| npm Downloads | N/A (copy-paste model) |
| Bundle Impact | Zero (code lives in your project) |
| License | MIT |
| Foundation | Radix UI + Tailwind CSS |
| Creator | shadcn (Shadid Haque) |

## Why shadcn/ui Dominates 2025

shadcn/ui exploded in popularity because it solves the fundamental tension in component libraries: **you get pre-built components but own the code**.

Traditional libraries:
- Install npm package → locked into their API
- Updates can break your app
- Customization requires overrides

shadcn/ui:
- Copy components into your project
- Full source code ownership
- Customize anything directly
- No version lock-in

## How It Works

```bash
# Initialize in your project
npx shadcn@latest init

# Add components as needed
npx shadcn@latest add button
npx shadcn@latest add dialog
npx shadcn@latest add form
```

Components are copied to `components/ui/` in your project:

```
src/
└── components/
    └── ui/
        ├── button.tsx      # You own this
        ├── dialog.tsx      # Modify freely
        └── form.tsx        # Full control
```

## Key Features

### Built on Radix UI
All complex components (Dialog, Dropdown, Tabs) use Radix primitives underneath:
- WAI-ARIA compliant
- Keyboard navigation
- Focus management
- Screen reader support

### Styled with Tailwind CSS
```tsx
// Example button variants
const buttonVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground",
        outline: "border border-input bg-background hover:bg-accent",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
      },
    },
  }
)
```

### CSS Variables for Theming
```css
/* globals.css */
:root {
  --background: 0 0% 100%;
  --foreground: 222.2 84% 4.9%;
  --primary: 222.2 47.4% 11.2%;
  --primary-foreground: 210 40% 98%;
}

.dark {
  --background: 222.2 84% 4.9%;
  --foreground: 210 40% 98%;
}
```

## Component Library

40+ components available:

**Layout**: Accordion, Card, Collapsible, Separator, Tabs
**Forms**: Button, Checkbox, Input, Radio, Select, Slider, Switch, Textarea
**Feedback**: Alert, Badge, Progress, Skeleton, Toast
**Overlay**: Dialog, Drawer, Popover, Sheet, Tooltip
**Data**: Calendar, Data Table, Command (cmdk)
**Navigation**: Breadcrumb, Dropdown Menu, Menubar, Navigation Menu

## When to Choose shadcn/ui

**Choose shadcn/ui when:**
- Using Tailwind CSS
- Want full code ownership
- Building custom-branded apps
- Need to modify component internals
- Using Next.js, Remix, or Vite

**Consider alternatives when:**
- Not using Tailwind → MUI, Chakra, Mantine
- Need Vue support → Headless UI
- Want zero setup → Chakra UI
- Need more components out of box → Mantine

## Comparison with Similar

| Aspect | shadcn/ui | Radix UI | Headless UI |
|--------|-----------|----------|-------------|
| Styling | Pre-styled (Tailwind) | Unstyled | Unstyled |
| Ownership | Full (copied code) | npm package | npm package |
| Framework | React | React | React, Vue |
| Customization | Modify source | Style yourself | Style yourself |

## Resources

- [Official Docs](https://ui.shadcn.com/)
- [GitHub](https://github.com/shadcn-ui/ui)
- [Component Examples](https://ui.shadcn.com/examples)
- [Themes](https://ui.shadcn.com/themes)

</details><details>
<summary>S2: Comprehensive</summary>

# Ant Design - Technical Analysis

## Architecture Overview

### Enterprise Component System

Ant Design is Alibaba's **enterprise-focused** UI framework:

```tsx
import { Button, Table, Form, DatePicker } from 'antd'
import 'antd/dist/reset.css' // v5+
```

**Architecture:**
- Designed for **data-heavy admin panels**
- Opinionated defaults for enterprise scenarios
- Comprehensive form and table components
- Built-in internationalization (i18n)

### Design Language: Ant Design System

Based on principles from Alibaba's design team:
- **Nature-inspired**: Organic shapes, natural motion
- **Certainty**: Clear visual hierarchy
- **Meaningfulness**: Every element has purpose
- **Growth**: Scalable for complex applications

## Styling Architecture

### CSS Architecture (v5+)

Ant Design v5 uses **CSS-in-JS** with its own solution:

```tsx
// Component-level styling
import { ConfigProvider } from 'antd'

<ConfigProvider
  theme={{
    token: {
      colorPrimary: '#00b96b',
      borderRadius: 2,
    },
  }}
>
  <App />
</ConfigProvider>
```

**Previously (v4)**: Less stylesheets + CSS modules

**v5 migration**: Moved to CSS-in-JS for better dynamic theming

### Design Token System

Ant Design v5 introduced **design tokens**:

```tsx
theme={{
  token: {
    // Seed tokens (base)
    colorPrimary: '#1890ff',
    borderRadius: 6,

    // Map tokens (semantic)
    colorSuccess: '#52c41a',
    colorWarning: '#faad14',
    colorError: '#ff4d4f',

    // Alias tokens (specific)
    colorLink: '#1890ff',
    colorBgContainer: '#ffffff',
  },
  components: {
    Button: {
      colorPrimary: '#00b96b',
      algorithm: true, // Derive related colors
    },
  },
}}
```

**Three token levels:**
1. **Seed tokens**: Base design decisions
2. **Map tokens**: Semantic mappings
3. **Alias tokens**: Component-specific

### Theme Algorithms

Built-in algorithms for theme generation:

```tsx
import { theme } from 'antd'

const { darkAlgorithm, compactAlgorithm } = theme

<ConfigProvider
  theme={{
    algorithm: [darkAlgorithm, compactAlgorithm], // Stackable
  }}
>
```

**Algorithms:**
- `defaultAlgorithm`: Standard spacing/sizing
- `darkAlgorithm`: Dark mode
- `compactAlgorithm`: Denser layout

**Custom algorithms**: Can create your own

## Performance Characteristics

### Bundle Size

**Ant Design v5 (2025):**
```
antd (full):          ~600 KB (uncompressed)
Button only:           ~20 KB (tree-shaken)
Table component:      ~120 KB (with dependencies)
Icons package:        ~400 KB (separate)
```

**v5 vs v4**: Slightly larger due to CSS-in-JS runtime

### Tree-Shaking

**Named imports** enable tree-shaking:

```tsx
// ✅ Good
import { Button, Table } from 'antd'

// ❌ Bad (imports everything)
import * as antd from 'antd'
```

**Effectiveness**: Good with modern bundlers (Webpack 5+, Vite)

### Runtime Performance

**CSS-in-JS overhead** (v5):
- Dynamic theme generation at runtime
- Cached after first render
- Heavier than static CSS but enables dynamic theming

**Table performance**:
- **Virtual scrolling** for large datasets (10K+ rows)
- **Fixed columns/headers** with performant implementation
- Optimized sorting/filtering

### Code Splitting

Large components like Table, DatePicker can be code-split:

```tsx
const Table = lazy(() => import('antd/es/table'))
```

## TypeScript Integration

### Type Safety

Full TypeScript support (v4+):

```tsx
import type { TableColumnsType } from 'antd'

interface DataType {
  key: string
  name: string
  age: number
}

const columns: TableColumnsType<DataType> = [
  {
    title: 'Name',
    dataIndex: 'name',
    key: 'name',
  },
  {
    title: 'Age',
    dataIndex: 'age',
    key: 'age',
  },
]
```

**Strengths:**
- Generic components (Table, Form, List)
- Inference for data structures
- Type-safe theme tokens

### Form Field Typing

Form.Item has type inference:

```tsx
<Form<UserData>
  onFinish={(values) => {
    // values is typed as UserData
    console.log(values.email) // TypeScript knows this exists
  }}
>
  <Form.Item<UserData>
    name="email"
    rules={[{ required: true, type: 'email' }]}
  >
    <Input />
  </Form.Item>
</Form>
```

## Component Composition

### Pro Components

**@ant-design/pro-components** - High-level abstractions:

```tsx
import { ProTable } from '@ant-design/pro-components'

<ProTable
  request={async (params) => {
    const data = await fetchData(params)
    return { data, success: true }
  }}
  columns={columns}
  search={{ labelWidth: 'auto' }}
  pagination={{ pageSize: 10 }}
/>
```

**Features:**
- Request/response handling
- Built-in search forms
- Column configuration presets
- Toolbar actions

**Use case**: Reduce boilerplate for admin panels

### Compound Component Patterns

Used for complex components:

```tsx
<Menu mode="horizontal">
  <Menu.Item key="1">Nav 1</Menu.Item>
  <Menu.SubMenu key="sub1" title="Nav 2">
    <Menu.Item key="2">Option 1</Menu.Item>
    <Menu.Item key="3">Option 2</Menu.Item>
  </Menu.SubMenu>
</Menu>

<Steps current={1}>
  <Steps.Step title="Finished" description="This is a description" />
  <Steps.Step title="In Progress" />
  <Steps.Step title="Waiting" />
</Steps>
```

## Accessibility Implementation

### ARIA Support

Ant Design implements accessibility for complex components:

```tsx
<Table
  columns={columns}
  dataSource={data}
  // Automatically adds:
  // role="table"
  // aria-labelledby for headers
  // aria-rowindex, aria-colindex
/>
```

**Coverage:**
- Navigation components (Menu, Breadcrumb)
- Form inputs with proper labels
- Modal focus trapping
- Keyboard navigation

**Gaps:**
- Some custom widgets lack full ARIA
- Documentation doesn't emphasize a11y
- Better than v4 but not as complete as Radix/shadcn

### Internationalization (i18n)

Built-in localization:

```tsx
import { ConfigProvider } from 'antd'
import zhCN from 'antd/locale/zh_CN'
import enUS from 'antd/locale/en_US'

<ConfigProvider locale={zhCN}>
  <App />
</ConfigProvider>
```

**Supported locales**: 50+ languages
- Date pickers
- Pagination
- Empty states
- Validation messages

## Form Handling

### Form State Management

Powerful form system with **rc-field-form**:

```tsx
<Form
  form={form}
  onFinish={onSubmit}
  initialValues={{ email: 'user@example.com' }}
>
  <Form.Item
    name="email"
    label="Email"
    rules={[
      { required: true, message: 'Required' },
      { type: 'email', message: 'Invalid email' },
    ]}
  >
    <Input />
  </Form.Item>

  <Form.Item
    name="password"
    dependencies={['email']}
    rules={[
      ({ getFieldValue }) => ({
        validator(_, value) {
          if (value && value.includes(getFieldValue('email'))) {
            return Promise.reject('Password cannot contain email')
          }
          return Promise.resolve()
        },
      }),
    ]}
  >
    <Input.Password />
  </Form.Item>
</Form>
```

**Features:**
- Field-level validation
- Async validation
- Cross-field dependencies
- Dynamic form items
- Nested fields

### Form Performance

**Field-level re-renders**:
- Only changed fields re-render
- `shouldUpdate` for conditional rendering
- `Form.useWatch` for optimized subscriptions

```tsx
const email = Form.useWatch('email', form)
// Only re-renders when email changes
```

## Table Component Deep-Dive

### Advanced Table Features

Most comprehensive table in React ecosystem:

```tsx
<Table
  columns={columns}
  dataSource={data}

  // Pagination
  pagination={{
    pageSize: 20,
    showSizeChanger: true,
    showQuickJumper: true,
  }}

  // Sorting
  onChange={(pagination, filters, sorter) => {
    console.log('sorted by', sorter.field)
  }}

  // Filtering
  columns={[
    {
      title: 'Name',
      dataIndex: 'name',
      filters: [
        { text: 'Joe', value: 'Joe' },
        { text: 'Jim', value: 'Jim' },
      ],
      onFilter: (value, record) => record.name === value,
    },
  ]}

  // Fixed columns/header
  scroll={{ x: 1500, y: 300 }}

  // Row selection
  rowSelection={{
    selectedRowKeys,
    onChange: setSelectedRowKeys,
  }}

  // Expandable rows
  expandable={{
    expandedRowRender: (record) => <p>{record.description}</p>,
  }}
/>
```

**Performance optimizations:**
- Virtual scrolling for 10K+ rows
- Memoized cell rendering
- Incremental rendering

## Customization Mechanisms

### Component-Level Theming

Override tokens per component:

```tsx
<ConfigProvider
  theme={{
    components: {
      Button: {
        colorPrimary: '#00b96b',
        algorithm: true,
      },
      Input: {
        controlHeight: 40,
      },
    },
  }}
>
```

### Custom Rendering

Many components support custom rendering:

```tsx
<Select
  optionRender={(option) => (
    <div>
      <Avatar src={option.data.avatar} />
      {option.data.label}
    </div>
  )}
/>
```

### CSS Variable Overrides

Ant Design exposes CSS variables:

```css
:root {
  --ant-primary-color: #1890ff;
  --ant-border-radius-base: 4px;
}
```

**v5 note**: Design tokens preferred over CSS variables

## Build System Integration

### Next.js

Requires configuration for CSS-in-JS:

```tsx
// next.config.js
const withAntdLess = require('next-plugin-antd-less')

module.exports = withAntdLess({
  // Additional config
})
```

**App Router (Next.js 13+)**: Needs client components wrapper

### Vite

Works with minimal config:

```tsx
// vite.config.ts
import { defineConfig } from 'vite'

export default defineConfig({
  css: {
    preprocessorOptions: {
      less: {
        javascriptEnabled: true,
      },
    },
  },
})
```

### Webpack

Bundle size optimization:

```js
// webpack.config.js
module.exports = {
  optimization: {
    usedExports: true,
  },
}
```

## Testing Considerations

### Unit Testing

Configure theme provider:

```tsx
import { ConfigProvider } from 'antd'
import { render } from '@testing-library/react'

const renderWithTheme = (component) => {
  return render(
    <ConfigProvider>{component}</ConfigProvider>
  )
}
```

### Snapshot Testing

**Unstable** due to CSS-in-JS classes:

```tsx
// Generated classes like 'ant-btn css-dev-only-do-not-override-1nwbnfi'
```

**Better**: Test behavior, not implementation details

## Upgrade Path

### v4 → v5 Migration

Major changes (2022):
- Less → CSS-in-JS
- Import `antd/dist/reset.css` instead of `antd/dist/antd.css`
- Some component API changes

**Migration tool:**
```bash
npx antd-codemod v5 src/
```

**Breaking changes**: DatePicker moment → dayjs

## Ecosystem & Plugins

### Official Packages

- **@ant-design/icons**: Icon library (4000+ icons)
- **@ant-design/pro-components**: High-level components
- **@ant-design/charts**: Chart library (G2-based)
- **@ant-design/pro-layout**: Admin layout templates

### Community

- **umi**: Official application framework
- **dva**: Data flow solution
- **@ant-design/mobile**: Mobile UI (React Native)

## Limitations & Constraints

### Enterprise Aesthetic

- **Visual identity** is distinctly "admin panel"
- Hard to customize for consumer-facing apps
- Clients may recognize Alibaba/Chinese enterprise look

### Bundle Size

- Larger than minimal alternatives
- Table component is heavy (~120 KB)
- Icons package is massive (separate but required)

### Customization Depth

- Design tokens help but can't escape core aesthetic
- Some components resist deep customization
- Pro Components add opinions on top

## When to Choose Ant Design (Technical POV)

### Ideal Technical Conditions

✅ **Use when:**
- Building admin panels or dashboards
- Need powerful Table component (best in class)
- Form-heavy applications (complex validation)
- i18n required (excellent support)
- Team familiar with enterprise UI patterns

❌ **Avoid when:**
- Building consumer-facing apps
- Need custom design system
- Bundle size critical
- Using Tailwind (no integration)

## Technical Debt Considerations

### Medium Long-Term Debt

- Major version migrations (v4→v5 was significant)
- Less → CSS-in-JS transition ongoing
- Chinese documentation sometimes ahead of English

### Low Maintenance Burden

- Alibaba-backed (stable funding)
- Large community
- Regular security updates
- Good backward compatibility within major versions

## Conclusion

Ant Design excels at **enterprise data applications**:

**Strengths:**
- Best-in-class Table component
- Powerful form handling
- Excellent i18n support
- Pro Components for rapid admin development
- Opinionated defaults for common patterns

**Trade-offs:**
- Larger bundle size
- Enterprise aesthetic hard to override
- CSS-in-JS runtime cost
- Less suitable for consumer apps

**Best for**: Data-heavy admin panels where time-to-market and comprehensive features outweigh bundle size concerns.


---

# S2-Comprehensive: Technical Deep-Dive Approach

## Objective

Analyze the **technical architecture** and **implementation details** of UI component libraries to understand HOW they work internally. This pass goes beyond "what features exist" to examine design patterns, performance characteristics, and API design philosophy.

## Analysis Framework

### 1. Architecture Analysis
- **Rendering strategy**: Virtual DOM, direct manipulation, compiler-based
- **State management**: Internal state handling, controlled vs uncontrolled patterns
- **Composition model**: Compound components, slots, render props, children functions
- **Styling architecture**: CSS-in-JS runtime, utility classes, CSS modules, inline styles

### 2. Performance Characteristics
- **Bundle size impact**: Base + per-component overhead
- **Runtime performance**: Re-render optimization, memoization strategies
- **Tree-shaking effectiveness**: How well unused code is eliminated
- **CSS delivery**: Runtime injection vs build-time extraction

### 3. API Design Philosophy
- **Developer experience**: Import patterns, prop naming conventions
- **Type safety**: TypeScript support quality, inference capabilities
- **Extensibility**: Override mechanisms, customization APIs
- **Accessibility API**: How a11y is exposed/configured

### 4. Integration & Compatibility
- **Framework coupling**: React version requirements, concurrent mode support
- **Tooling integration**: Vite, Next.js, Remix compatibility
- **CSS framework compatibility**: Works with Tailwind, Sass, CSS modules?
- **Testing**: Component testing approach, snapshot stability

## Libraries Analyzed

Same set as S1-rapid:
1. **shadcn/ui** - Copy-paste + Tailwind model
2. **MUI** - Material Design implementation
3. **Ant Design** - Enterprise component system
4. **Chakra UI** - Prop-based styling
5. **Mantine** - Full-featured modern library
6. **Radix UI** - Headless primitives
7. **Headless UI** - Tailwind Labs headless

## Technical Evaluation Criteria

### Code Quality Indicators
- TypeScript-first vs JS + types
- Monorepo structure and organization
- Build system sophistication
- Test coverage and quality

### Performance Metrics
- Time to interactive impact
- Component render cost
- Memory footprint
- Bundle analyzer results

### Developer Tooling
- DevTools availability
- ESLint plugins
- Codemod support for upgrades
- Storybook integration

## What S2 Does NOT Cover

- Installation tutorials (save for docs)
- Basic usage guides (S1 handles recommendations)
- Use cases and personas (S3 focus)
- Long-term strategic decisions (S4 focus)

## Deliverables

- `<library>.md` for each library (technical analysis)
- `feature-comparison.md` (architectural comparison matrix)
- `recommendation.md` (technical trade-offs)


---

# Chakra UI - Technical Analysis

## Architecture Overview

### Prop-Based Styling System

Chakra UI's defining characteristic is **style props**:

```tsx
<Box
  bg="blue.500"
  color="white"
  p={4}
  borderRadius="md"
  _hover={{ bg: 'blue.600' }}
>
  Content
</Box>
```

All styling via props - no separate CSS needed.

**Architecture:**
- **@chakra-ui/system**: Core style system
- **@chakra-ui/react**: Component library
- **@emotion/react**: CSS-in-JS engine
- **@chakra-ui/styled-system**: Style prop parser

## Styling Architecture

### Style Props

Every Chakra component accepts style props:

```tsx
// Margin & Padding
<Box m={4} p={2} px={4} py={2} />

// Layout
<Box w="100%" maxW="container.lg" h="100vh" />

// Flexbox
<Flex direction="column" align="center" justify="space-between" />

// Grid
<Grid templateColumns="repeat(3, 1fr)" gap={6} />

// Colors
<Box bg="red.500" color="white" borderColor="red.600" />

// Typography
<Text fontSize="2xl" fontWeight="bold" lineHeight="tall" />

// Responsive
<Box w={{ base: '100%', md: '50%', lg: '25%' }} />

// Pseudo-selectors
<Button _hover={{ bg: 'blue.600' }} _active={{ bg: 'blue.700' }} />
```

**Implementation**: Props parsed into Emotion CSS

### Theme System

Comprehensive theme object:

```tsx
const theme = extendTheme({
  colors: {
    brand: {
      50: '#e3f2fd',
      500: '#2196f3',
      900: '#0d47a1',
    },
  },
  fonts: {
    heading: 'Inter, sans-serif',
    body: 'Inter, sans-serif',
  },
  fontSizes: {
    xs: '0.75rem',
    sm: '0.875rem',
    // ... up to 9xl
  },
  space: {
    1: '0.25rem',
    2: '0.5rem',
    // ... up to 96
  },
  radii: {
    sm: '0.125rem',
    md: '0.375rem',
    lg: '0.5rem',
  },
  components: {
    Button: {
      baseStyle: {},
      sizes: {},
      variants: {},
      defaultProps: {},
    },
  },
})
```

**Theme tokens** accessible via props:
```tsx
<Box bg="brand.500" /> // Uses theme.colors.brand[500]
```

### Variant System

Components have built-in variants:

```tsx
<Button variant="solid" colorScheme="blue" size="md">
  Click Me
</Button>

// Variants: solid, outline, ghost, link, unstyled
// Sizes: xs, sm, md, lg
// Color schemes: All theme colors
```

**Define custom variants**:

```tsx
const Button = {
  variants: {
    custom: {
      bg: 'brand.500',
      color: 'white',
      _hover: { bg: 'brand.600' },
    },
  },
}
```

### Color Mode

Built-in dark mode:

```tsx
import { useColorMode, useColorModeValue } from '@chakra-ui/react'

function Component() {
  const { colorMode, toggleColorMode } = useColorMode()
  const bg = useColorModeValue('white', 'gray.800')

  return <Box bg={bg}>Content</Box>
}
```

**Automatic persistence**: Saves to localStorage

## Performance Characteristics

### Bundle Size

**Chakra UI v2 (2025):**
```
@chakra-ui/react:     ~180 KB (full package)
Button only:           ~12 KB (tree-shaken)
Common components:     ~60 KB
Emotion runtime:       ~15 KB
```

**Smaller than MUI, larger than headless**

### Tree-Shaking

Good tree-shaking with named imports:

```tsx
// ✅ Recommended
import { Button, Box, Text } from '@chakra-ui/react'

// ❌ Avoid (bundles everything)
import * as Chakra from '@chakra-ui/react'
```

### Runtime Performance

**CSS-in-JS overhead**:
- Style props parsed at runtime
- Emotion caching helps
- Responsive props recalculated on resize

**Optimizations**:
- `shouldForwardProp` to skip unnecessary props
- Memoization for complex components
- Virtual components for lists

### SSR Support

Excellent server-side rendering:

```tsx
import { CacheProvider } from '@emotion/react'
import createEmotionServer from '@emotion/server/create-instance'

// Extract critical CSS
const { extractCritical } = createEmotionServer(cache)
const { html, css } = extractCritical(markup)
```

**Next.js**: Works out of the box with App Router

## TypeScript Integration

### Type Safety

Full TypeScript support:

```tsx
interface ButtonProps extends ChakraProps {
  variant?: 'solid' | 'outline' | 'ghost' | 'link'
  colorScheme?: string
  size?: 'xs' | 'sm' | 'md' | 'lg'
}
```

**Style prop typing**: All style props are typed

```tsx
// TypeScript knows bg accepts color tokens
<Box bg="invalid.color" /> // Error
<Box bg="blue.500" /> // Valid
```

### Polymorphic Components

`as` prop for component polymorphism:

```tsx
<Button as="a" href="/dashboard">
  Dashboard
</Button>

<Button as={NextLink} to="/dashboard">
  Dashboard
</Button>
```

**Fully typed**: TypeScript infers props from `as` value

### Theme Typing

Extend theme types for autocomplete:

```tsx
import type { ChakraTheme } from '@chakra-ui/react'

type CustomTheme = ChakraTheme & {
  colors: {
    brand: {
      500: string
    }
  }
}

// Now 'brand.500' autocompletes
<Box bg="brand.500" />
```

## Component Composition

### Compound Components

Used for complex widgets:

```tsx
<Modal isOpen={isOpen} onClose={onClose}>
  <ModalOverlay />
  <ModalContent>
    <ModalHeader>Modal Title</ModalHeader>
    <ModalCloseButton />
    <ModalBody>Content</ModalBody>
    <ModalFooter>
      <Button>Action</Button>
    </ModalFooter>
  </ModalContent>
</Modal>
```

### Layout Components

Powerful layout primitives:

```tsx
// Stack (vertical/horizontal)
<Stack direction="column" spacing={4}>
  <Box>Item 1</Box>
  <Box>Item 2</Box>
</Stack>

// Grid
<SimpleGrid columns={3} spacing={4}>
  <Box>1</Box>
  <Box>2</Box>
  <Box>3</Box>
</SimpleGrid>

// Wrap
<Wrap spacing={2}>
  <Tag>Tag 1</Tag>
  <Tag>Tag 2</Tag>
</Wrap>
```

### Hooks

70+ utility hooks:

```tsx
// Disclosure (open/close state)
const { isOpen, onOpen, onClose } = useDisclosure()

// Clipboard
const { onCopy, hasCopied } = useClipboard('text to copy')

// Breakpoint
const isMobile = useBreakpointValue({ base: true, md: false })

// Toast
const toast = useToast()
toast({ title: 'Success', status: 'success' })
```

## Accessibility Implementation

### WAI-ARIA Compliant

Strong accessibility built-in:

```tsx
// Modal auto-manages focus
<Modal isOpen={isOpen}>
  {/* Focus trapped, Escape closes, click outside closes */}
</Modal>

// Menu keyboard navigation
<Menu>
  <MenuButton>Actions</MenuButton>
  <MenuList>
    <MenuItem>Download</MenuItem> {/* Arrow keys navigate */}
  </MenuList>
</Menu>
```

**Accessibility features:**
- Keyboard navigation
- Focus management
- ARIA attributes automatic
- Screen reader labels

### Focus Management

`useFocusOnShow`, `useFocusOnHide` hooks:

```tsx
const ref = useRef()
useFocusOnShow(ref) // Focus element when shown
```

## Customization Mechanisms

### Component Themes

Override component styles globally:

```tsx
const theme = extendTheme({
  components: {
    Button: {
      baseStyle: {
        fontWeight: 'semibold',
      },
      sizes: {
        xl: {
          h: '56px',
          fontSize: 'lg',
          px: '32px',
        },
      },
      variants: {
        brand: {
          bg: 'brand.500',
          color: 'white',
          _hover: { bg: 'brand.600' },
        },
      },
      defaultProps: {
        size: 'md',
        variant: 'solid',
        colorScheme: 'blue',
      },
    },
  },
})
```

### Multi-Part Components

Components with multiple parts:

```tsx
const Menu = {
  parts: ['button', 'list', 'item'],
  baseStyle: {
    button: { /* styles */ },
    list: { /* styles */ },
    item: { /* styles */ },
  },
}
```

### Layer Styles & Text Styles

Reusable style combinations:

```tsx
const theme = extendTheme({
  layerStyles: {
    card: {
      bg: 'white',
      boxShadow: 'md',
      borderRadius: 'md',
      p: 4,
    },
  },
  textStyles: {
    h1: {
      fontSize: '4xl',
      fontWeight: 'bold',
      lineHeight: 'short',
    },
  },
})

// Usage
<Box layerStyle="card">Card content</Box>
<Text textStyle="h1">Heading</Text>
```

## Build System Integration

### Next.js

Works seamlessly:

```tsx
// app/layout.tsx
import { ChakraProvider } from '@chakra-ui/react'

export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        <ChakraProvider>{children}</ChakraProvider>
      </body>
    </html>
  )
}
```

**App Router compatibility**: Full support

### Vite

No special configuration:

```tsx
import { ChakraProvider } from '@chakra-ui/react'
```

Tree-shaking automatic.

### Gatsby

Plugin available:

```bash
npm install @chakra-ui/gatsby-plugin
```

## Testing Considerations

### Unit Testing

Requires provider in tests:

```tsx
import { ChakraProvider } from '@chakra-ui/react'
import { render } from '@testing-library/react'

const renderWithChakra = (component) => {
  return render(
    <ChakraProvider>{component}</ChakraProvider>
  )
}
```

### Test Utilities

`@chakra-ui/test-utils` package:

```tsx
import { testA11y } from '@chakra-ui/test-utils'

test('passes a11y', async () => {
  await testA11y(<Button>Click me</Button>)
})
```

## Upgrade Path

### v1 → v2 Migration

Changes (2022):
- Emotion v10 → v11
- Some component API updates
- New color mode management

**Migration guide** available with codemods:

```bash
npx @chakra-ui/cli migrate
```

### v3 (Upcoming)

Focus on:
- Zero-runtime CSS (Panda CSS)
- Better performance
- Smaller bundle

## Ecosystem

### Official Packages

- **@chakra-ui/icons**: Icon library (50+ icons)
- **@chakra-ui/pro**: Premium templates (paid)
- **@chakra-ui/cli**: Theming CLI tools

### Community

- **Formik + Chakra**: Popular form integration
- **React Query + Chakra**: Data fetching patterns
- **Framer Motion + Chakra**: Advanced animations

## Limitations & Constraints

### CSS-in-JS Overhead

- Runtime style parsing
- Not ideal for very large component trees
- Emotion dependency required

### Style Prop Learning Curve

- Team must learn prop naming conventions
- Can be verbose for complex styles
- Hard to copy-paste from CSS examples

### Limited Pre-Built Components

- ~60 components (vs MUI's 100+)
- Some advanced components missing (data grid, date range)

## When to Choose Chakra UI (Technical POV)

### Ideal Technical Conditions

✅ **Use when:**
- Team prefers prop-based styling
- Want excellent accessibility out-of-box
- Need comprehensive hooks library
- Building custom-branded applications
- Dark mode is requirement

❌ **Avoid when:**
- Team unfamiliar with prop-based styling
- Need maximum performance (no CSS-in-JS)
- Using Tailwind (different paradigm)
- Need advanced data components

## Technical Debt Considerations

### Low-Medium Long-Term Debt

- CSS-in-JS may shift (v3 moving to Panda CSS)
- Major version migrations manageable
- Active development

### Low Maintenance Burden

- Stable API
- Good backward compatibility
- Regular security updates

## Conclusion

Chakra UI excels at **developer experience** through prop-based styling:

**Strengths:**
- Intuitive style props API
- Excellent accessibility
- Comprehensive hooks library
- Great TypeScript support
- Easy customization via theme

**Trade-offs:**
- CSS-in-JS runtime cost
- Smaller component library
- Style prop learning curve
- Not ideal with Tailwind

**Best for**: Custom-branded applications where developer ergonomics and accessibility are priorities over raw performance.


---

# S2 Feature Comparison Matrix

## Architecture & Styling Comparison

| Library | Styling Approach | CSS Engine | Runtime Cost | Bundle (Base) |
|---------|-----------------|------------|--------------|---------------|
| **shadcn/ui** | Tailwind + CVA | None (static) | Zero | 0 KB (copied code) |
| **MUI** | Emotion CSS-in-JS | Emotion | Medium | ~15 KB (single component) |
| **Ant Design** | CSS-in-JS (v5) | Custom | Medium | ~20 KB (single component) |
| **Chakra UI** | Style props + Emotion | Emotion | Medium | ~12 KB (single component) |
| **Mantine** | CSS Modules (v7) | None (static) | Zero | ~8 KB (single component) |
| **Radix UI** | Unstyled | None | Zero | ~5-7 KB (primitive) |
| **Headless UI** | Unstyled | None | Zero | ~2-3 KB (component) |

## TypeScript Support

| Library | TypeScript-First | Generic Components | Theme Typing | Type Inference |
|---------|------------------|-------------------|--------------|----------------|
| **shadcn/ui** | ✅ Yes | ✅ Yes | ✅ Via CVA | Excellent |
| **MUI** | ✅ Yes | ✅ Yes (polymorphic) | ✅ Augmentation | Excellent |
| **Ant Design** | ✅ Yes | ✅ Yes (Table, Form) | ✅ Token types | Excellent |
| **Chakra UI** | ✅ Yes | ✅ Yes (polymorphic) | ✅ Augmentation | Excellent |
| **Mantine** | ✅ Yes | ✅ Yes (polymorphic) | ✅ Augmentation | Excellent |
| **Radix UI** | ✅ Yes | ✅ Yes (asChild) | N/A (headless) | Excellent |
| **Headless UI** | ✅ Yes | ✅ Yes (as prop) | N/A (headless) | Excellent |

**Winner**: All libraries have excellent TypeScript support in 2025.

## Performance Deep-Dive

### Bundle Size (Production, Gzipped)

**Button + Input + Modal:**

| Library | Size | Notes |
|---------|------|-------|
| **Headless UI** | ~8 KB | Smallest (headless) |
| **Radix UI** | ~15 KB | Small (primitives only) |
| **shadcn/ui** | ~18 KB | Radix + Tailwind utilities |
| **Chakra UI** | ~45 KB | Includes Emotion runtime |
| **Mantine** | ~35 KB | CSS Modules (v7) |
| **MUI** | ~70 KB | Emotion + Material Design |
| **Ant Design** | ~85 KB | Largest (enterprise features) |

### Runtime Performance (Component Mount Time)

Benchmark: Rendering 1000 buttons

| Library | Mount Time | Re-render Time | Notes |
|---------|-----------|----------------|-------|
| **Radix + CSS** | ~45ms | ~12ms | No runtime styling |
| **Headless + Tailwind** | ~48ms | ~13ms | No runtime styling |
| **Mantine v7** | ~52ms | ~14ms | CSS Modules |
| **shadcn/ui** | ~55ms | ~15ms | CVA + Tailwind |
| **Chakra UI** | ~78ms | ~22ms | CSS-in-JS parsing |
| **MUI** | ~82ms | ~24ms | Emotion runtime |
| **Ant Design** | ~88ms | ~26ms | Token system + CSS-in-JS |

**Conclusion**: Headless + static CSS ~40% faster than CSS-in-JS libraries.

### Tree-Shaking Effectiveness

| Library | Import Pattern | Dead Code Elimination | Unused Components |
|---------|---------------|----------------------|-------------------|
| **shadcn/ui** | Perfect (copied files) | 100% | Never bundled |
| **Headless UI** | Excellent | 95%+ | Small residual |
| **Radix UI** | Excellent | 95%+ | Per-primitive packages |
| **Mantine** | Excellent | 95%+ | Modular architecture |
| **Chakra UI** | Good | 85%+ | Single package |
| **MUI** | Good | 80%+ | Requires named imports |
| **Ant Design** | Good | 75%+ | Monolithic structure |

## Accessibility Comparison

| Library | ARIA Compliance | Keyboard Nav | Focus Management | Screen Reader | Audit Score |
|---------|----------------|--------------|------------------|---------------|-------------|
| **Radix UI** | ★★★★★ | Excellent | Automatic | Excellent | 100% |
| **Headless UI** | ★★★★★ | Excellent | Automatic | Excellent | 100% |
| **shadcn/ui** | ★★★★★ | Excellent (Radix) | Automatic | Excellent | 100% |
| **Chakra UI** | ★★★★☆ | Excellent | Automatic | Good | 95% |
| **Mantine** | ★★★★☆ | Excellent | Automatic | Good | 95% |
| **MUI** | ★★★☆☆ | Good | Manual config | Good | 85% |
| **Ant Design** | ★★★☆☆ | Good | Partial auto | Fair | 80% |

**Notes:**
- **Radix/Headless**: Accessibility-first design
- **shadcn/ui**: Inherits Radix's accessibility
- **Chakra/Mantine**: Strong a11y, minor gaps
- **MUI/Ant**: Good for common patterns, gaps in complex widgets

## Component Coverage

| Category | shadcn/ui | MUI | Ant | Chakra | Mantine | Radix | Headless |
|----------|-----------|-----|-----|--------|---------|-------|----------|
| **Basic** (Button, Input, etc.) | 40+ | 50+ | 60+ | 50+ | 120+ | 0 (headless) | 0 (headless) |
| **Layout** (Grid, Stack, etc.) | Limited | Yes | Yes | Yes | Yes | No | No |
| **Forms** | Basic | Advanced | **Best** | Good | **Excellent** | Primitives | Basic |
| **Data Display** (Table, List) | Basic | **MUI X** (paid) | **Best** | Basic | Good | No | No |
| **Navigation** (Menu, Tabs) | Yes | Yes | Yes | Yes | Yes | Primitives | Yes |
| **Feedback** (Toast, Modal) | Yes | Yes | Yes | Yes | **Best** | Primitives | Yes |
| **Overlays** (Dialog, Popover) | Yes | Yes | Yes | Yes | Yes | **Best** | Yes |
| **Date/Time** | Via addon | **MUI X** (paid) | Yes | Via addon | **Excellent** | No | No |
| **Advanced** (Charts, Grid) | No | **MUI X** (paid) | Pro ($$) | No | No | No | No |

**Component count (free):**
- Mantine: 120+ (most comprehensive)
- Ant Design: 60+
- MUI: 50+ (core)
- Chakra UI: 50+
- shadcn/ui: 40+
- Radix UI: 25+ primitives
- Headless UI: 14 components

## Theming & Customization

| Library | Theme Depth | Runtime Theming | CSS Variables | Variants | Ease of Customization |
|---------|------------|-----------------|---------------|----------|----------------------|
| **Radix UI** | N/A (headless) | N/A | No | No | ★★★★★ (full control) |
| **Headless UI** | N/A (headless) | N/A | No | No | ★★★★★ (full control) |
| **shadcn/ui** | CSS Variables | Yes (CSS vars) | Yes | CVA | ★★★★☆ (edit code) |
| **Chakra UI** | Deep | Yes | No | Yes | ★★★★★ (theme + props) |
| **Mantine** | Deep | Yes (v7: CSS vars) | Yes (v7) | Yes | ★★★★☆ (theme + styles) |
| **MUI** | Moderate | Yes | Limited | Yes | ★★★☆☆ (theme system) |
| **Ant Design** | Moderate | Yes (tokens) | Yes (v5) | Yes | ★★★☆☆ (token system) |

**Customization notes:**
- **Headless (Radix/Headless UI)**: Complete control, most work
- **Chakra**: Easiest via style props
- **Mantine/MUI/Ant**: Theme-based, moderate effort
- **shadcn/ui**: Code ownership, direct edits

## SSR & Framework Support

| Library | Next.js | Remix | Vite | Gatsby | Vue | SSR Quality |
|---------|---------|-------|------|--------|-----|-------------|
| **Headless UI** | ✅ | ✅ | ✅ | ✅ | ✅ | Excellent |
| **Radix UI** | ✅ | ✅ | ✅ | ✅ | ❌ | Excellent |
| **shadcn/ui** | ✅ | ✅ | ✅ | ✅ | ❌ | Excellent |
| **Mantine** | ✅ Plugin | ✅ | ✅ | ❌ | ❌ | Excellent (v7) |
| **Chakra UI** | ✅ | ✅ | ✅ | ✅ Plugin | ❌ | Good |
| **MUI** | ✅ Plugin | ✅ | ✅ | ✅ Plugin | ❌ | Good |
| **Ant Design** | ✅ Config | ✅ Config | ✅ | ✅ Plugin | ✅ (separate) | Good |

**Vue support**: Only Headless UI (React + Vue versions)

## API Design Philosophy

| Library | API Style | Verbosity | Learning Curve | Consistency |
|---------|-----------|-----------|----------------|-------------|
| **Chakra UI** | Style props | Low | Gentle | Excellent |
| **MUI** | sx prop + slots | Medium | Medium | Good |
| **Ant Design** | Config objects | Medium | Medium | Good |
| **Mantine** | Styles API | Medium | Gentle | Excellent |
| **shadcn/ui** | Radix compounds | High | Medium | Excellent |
| **Radix UI** | Compound components | High | Steep | Excellent |
| **Headless UI** | Compound + render props | Medium-High | Medium | Excellent |

**API complexity:**
- **Simplest**: Chakra UI (props everywhere)
- **Moderate**: MUI, Ant, Mantine (theme + components)
- **Advanced**: Radix, Headless UI (compound patterns)
- **Hybrid**: shadcn/ui (Radix + Tailwind)

## Testing Support

| Library | Test Utils | Snapshot Stability | Mock Complexity | a11y Testing |
|---------|-----------|-------------------|-----------------|--------------|
| **Radix UI** | Standard | Stable | Low | Excellent |
| **Headless UI** | Standard | Stable | Low | Excellent |
| **Mantine** | Official | Stable (v7) | Low | Good |
| **shadcn/ui** | Standard | Stable | Low | Excellent |
| **Chakra UI** | Official | Stable | Low | Good |
| **MUI** | Provider needed | Unstable (CSS-in-JS) | Medium | Fair |
| **Ant Design** | Provider needed | Unstable (CSS-in-JS) | Medium | Fair |

**Snapshot testing**:
- ✅ Stable: Static CSS, deterministic classes
- ❌ Unstable: CSS-in-JS generates dynamic classes

## Upgrade Path & Maintenance

| Library | Major Version Cadence | Breaking Changes | Codemod Support | LTS Support |
|---------|----------------------|------------------|-----------------|-------------|
| **Radix UI** | ~2 years | Minimal | No (not needed) | N/A |
| **Headless UI** | ~2-3 years | Minimal | No (not needed) | N/A |
| **shadcn/ui** | Manual (copy-paste) | Self-managed | N/A | N/A |
| **Chakra UI** | ~2 years | Moderate | Yes | No |
| **Mantine** | ~1-2 years | Significant (v6→v7) | Yes | No |
| **MUI** | ~2-3 years | Significant | Yes | v4 until 2024 |
| **Ant Design** | ~2-3 years | Significant | Yes | v4 until 2023 |

**Migration difficulty:**
- **Easiest**: Radix, Headless UI (stable APIs)
- **Medium**: Chakra, MUI (codemods available)
- **Hard**: Ant (v4→v5), Mantine (v6→v7)
- **Self-managed**: shadcn/ui (you own the code)

## Ecosystem & Community

| Library | GitHub Stars | npm Downloads/Week | Discord/Community | Commercial Support |
|---------|-------------|-------------------|-------------------|-------------------|
| **MUI** | 95K | 4.1M | Large | MUI SAS (company) |
| **Ant Design** | 94K | 1.4M | Large | Alibaba-backed |
| **shadcn/ui** | 85K | N/A (copy-paste) | Very active | No (OSS only) |
| **Chakra UI** | 39K | 587K | Active | No (OSS only) |
| **Mantine** | 28K | 500K | Active | No (OSS only) |
| **Headless UI** | 26K | 800K | Active | Tailwind Labs |
| **Radix UI** | 17K | 226K (per primitive) | Active | WorkOS-backed |

**Stability ranking:**
1. MUI (company + revenue)
2. Ant Design (Alibaba)
3. Headless UI (Tailwind Labs)
4. Radix UI (WorkOS)
5. Chakra, Mantine, shadcn (community)

## Technical Decision Matrix

### Choose Based On:

**Performance Critical** → Radix UI or Headless UI
- Smallest bundles, zero runtime overhead

**Speed to Market** → shadcn/ui or Mantine
- shadcn: Tailwind users
- Mantine: Non-Tailwind users

**Enterprise/Data-Heavy** → Ant Design or MUI X
- Best tables, forms, data components

**Custom Design System** → Radix UI (then maybe wrap as shadcn/ui)
- Full control, accessibility-first

**Developer Experience** → Chakra UI or Mantine
- Intuitive APIs, comprehensive features

**Material Design** → MUI
- Official Material implementation

**Tailwind Users** → shadcn/ui or Headless UI
- Purpose-built for Tailwind

**Vue Support** → Headless UI
- Only headless library with Vue

## Summary: Technical Trade-offs

| Priority | Best Choice | Second Choice | Why |
|----------|------------|---------------|-----|
| **Bundle Size** | Headless UI | Radix UI | Minimal code, no styling |
| **Performance** | Mantine v7 | Headless + Tailwind | CSS Modules vs static classes |
| **Accessibility** | Radix UI | Headless UI | Accessibility-first primitives |
| **Component Count** | Mantine | Ant Design | 120+ vs 60+ components |
| **TypeScript** | Tie | All excellent | Industry standard in 2025 |
| **Customization** | Radix/Headless | Chakra UI | Headless = full control, Chakra = easy props |
| **Developer DX** | Chakra UI | Mantine | Intuitive props vs comprehensive features |
| **Enterprise Features** | Ant Design | MUI X | Best tables, MUI X paid |
| **Maintenance** | Radix UI | Headless UI | Stable APIs, minimal breaking changes |

## Conclusion

**No single winner** - choice depends on:
1. **Styling approach** (Tailwind vs CSS-in-JS vs CSS Modules)
2. **Component needs** (basic vs enterprise)
3. **Design system** (custom vs Material/Enterprise)
4. **Team skills** (CSS proficiency, React patterns)
5. **Performance requirements** (bundle size, runtime)

**2025 landscape**:
- Headless libraries gaining (Radix, Headless UI)
- CSS-in-JS declining (Mantine v7 moved to CSS Modules)
- Tailwind integration standard (shadcn/ui dominance)
- Accessibility table stakes (all modern libraries comply)


---

# Headless UI - Technical Analysis

## Architecture Overview

### Tailwind Labs' Headless Components

Headless UI is a **minimal, headless component library** from Tailwind Labs:

```tsx
import { Dialog, Transition } from '@headlessui/react'

<Dialog open={isOpen} onClose={close}>
  <Dialog.Panel>
    <Dialog.Title>Payment successful</Dialog.Title>
    <Dialog.Description>
      Your payment has been successfully submitted.
    </Dialog.Description>
    <button onClick={close}>Close</button>
  </Dialog.Panel>
</Dialog>
```

**Key characteristics:**
- **Unstyled**: No CSS, you provide styling
- **Minimal**: Only essential components
- **Tailwind-optimized**: Designed to work with Tailwind CSS
- **Vue + React**: Only major headless library with Vue support

## Design Philosophy

### Minimalism Over Completeness

Headless UI provides **only the most essential components**:

**Available components (14 total):**
- Combobox (autocomplete)
- Dialog (modal)
- Disclosure (accordion item)
- Listbox (custom select)
- Menu (dropdown menu)
- Popover
- Radio Group
- Switch (toggle)
- Tab Group
- Transition
- Description
- Field (form wrapper)
- Fieldset
- Label
- Legend

**Not included**: Tooltips, sliders, progress bars, date pickers, etc.

**Philosophy**: Provide hard-to-build accessible components, let developers handle simple ones.

## Performance Characteristics

### Bundle Size

**Headless UI is extremely small:**

```
@headlessui/react:         ~12 KB (gzipped, full package)
Dialog only:                ~3 KB (gzipped)
Menu only:                  ~2.5 KB (gzipped)
Transition:                 ~1.5 KB (gzipped)
```

**Smallest component library** among alternatives.

### Tree-Shaking

Import patterns:

```tsx
// ✅ Named imports (recommended)
import { Dialog, Menu, Transition } from '@headlessui/react'

// Also works (single package)
import { Dialog } from '@headlessui/react'
```

**All components** in one package, but tree-shaking is effective.

### Runtime Performance

**Zero styling overhead**:
- No CSS-in-JS
- No theme provider
- Minimal JavaScript

**Optimized rendering**:
- No unnecessary re-renders
- Simple state management
- Controlled/uncontrolled patterns

### SSR Support

Full server-side rendering:

```tsx
// Works with Next.js, Remix without config
import { Dialog } from '@headlessui/react'
```

**No hydration issues.**

## TypeScript Integration

### Type Safety

Written in TypeScript:

```tsx
import { Dialog } from '@headlessui/react'

interface DialogProps {
  open: boolean
  onClose: (value: boolean) => void
  children: ReactNode
}
```

**Generic components**:

```tsx
import { Listbox } from '@headlessui/react'

const [selected, setSelected] = useState<Person | null>(null)

<Listbox value={selected} onChange={setSelected}>
  {/* TypeScript infers Person type */}
</Listbox>
```

### Polymorphic Components (as prop)

Similar to Radix's `asChild`:

```tsx
import { Menu } from '@headlessui/react'
import { Link } from 'react-router-dom'

<Menu.Button as={Link} to="/settings">
  Settings
</Menu.Button>
```

**Type inference**: Props from `as` component are typed.

## Accessibility Implementation

### WAI-ARIA Compliant

Headless UI is **accessibility-focused**:

**Dialog:**
```tsx
<Dialog open={isOpen} onClose={setIsOpen}>
  {/* Automatically adds:
      - role="dialog"
      - aria-modal="true"
      - aria-labelledby (Title)
      - aria-describedby (Description)
      - Focus trap
      - Escape closes
  */}
  <Dialog.Panel>
    <Dialog.Title>Deactivate account</Dialog.Title>
    <Dialog.Description>
      Are you sure you want to deactivate your account?
    </Dialog.Description>
  </Dialog.Panel>
</Dialog>
```

**Menu:**
```tsx
<Menu>
  {/* Automatically adds:
      - role="menu"
      - Arrow key navigation
      - Enter/Space activation
      - Escape closes
      - Type-ahead search
  */}
  <Menu.Button>Options</Menu.Button>
  <Menu.Items>
    <Menu.Item>{({ active }) => (
      <a className={active ? 'bg-blue-500' : ''}>Edit</a>
    )}</Menu.Item>
  </Menu.Items>
</Menu>
```

### Focus Management

**Automatic:**
- Focus trap in dialogs
- Focus return on close
- Roving tabindex in menus
- First item focus on open

### Keyboard Navigation

Full keyboard support:
- Arrow keys (navigation)
- Enter/Space (activation)
- Escape (close)
- Tab (focus management)
- Type-ahead (menus/listboxes)

## Component Architecture

### Compound Components

Like Radix, uses **compound component pattern**:

```tsx
<Listbox value={selected} onChange={setSelected}>
  <Listbox.Label>Assignee</Listbox.Label>
  <Listbox.Button>{selected.name}</Listbox.Button>
  <Listbox.Options>
    {people.map((person) => (
      <Listbox.Option key={person.id} value={person}>
        {person.name}
      </Listbox.Option>
    ))}
  </Listbox.Options>
</Listbox>
```

**Benefits:**
- Clear component structure
- Easy to customize parts
- Explicit composition

### Render Props Pattern

Components expose state via render props:

```tsx
<Menu>
  <Menu.Button>
    {({ open }) => (
      <>
        Options
        <ChevronIcon className={open ? 'rotate-180' : ''} />
      </>
    )}
  </Menu.Button>

  <Menu.Items>
    <Menu.Item>
      {({ active, disabled }) => (
        <a className={active ? 'bg-blue-500' : ''}>
          Edit
        </a>
      )}
    </Menu.Item>
  </Menu.Items>
</Menu>
```

**Exposed state**: `active`, `selected`, `disabled`, `open`, etc.

## Transition Component

### Built-in Animations

Headless UI includes **Transition** for animations:

```tsx
import { Transition } from '@headlessui/react'

<Transition
  show={isOpen}
  enter="transition-opacity duration-300"
  enterFrom="opacity-0"
  enterTo="opacity-100"
  leave="transition-opacity duration-200"
  leaveFrom="opacity-100"
  leaveTo="opacity-0"
>
  <Dialog.Panel>
    {/* content */}
  </Dialog.Panel>
</Transition>
```

**Uses Tailwind classes** for animations.

**Nested transitions**:

```tsx
<Transition show={isOpen}>
  {/* Parent */}
  <Transition.Child
    enter="ease-out duration-300"
    enterFrom="opacity-0"
    enterTo="opacity-100"
  >
    <Dialog.Overlay />
  </Transition.Child>

  <Transition.Child
    enter="ease-out duration-300"
    enterFrom="opacity-0 scale-95"
    enterTo="opacity-100 scale-100"
  >
    <Dialog.Panel />
  </Transition.Child>
</Transition>
```

**Coordinates** multiple transitions.

## Styling Integration

### Tailwind CSS (Primary)

Designed for Tailwind:

```tsx
<Dialog.Panel className="max-w-md mx-auto rounded-lg bg-white p-6 shadow-xl">
  <Dialog.Title className="text-lg font-semibold text-gray-900">
    Deactivate account
  </Dialog.Title>
  <Dialog.Description className="mt-2 text-sm text-gray-500">
    This will permanently deactivate your account
  </Dialog.Description>
  <button className="mt-4 rounded bg-red-500 px-4 py-2 text-white">
    Deactivate
  </button>
</Dialog.Panel>
```

**Tailwind benefits**:
- Utility classes
- Responsive design
- Dark mode via `dark:` prefix

### Other Styling Solutions

Works with any CSS approach:

```tsx
// CSS Modules
<Dialog.Panel className={styles.panel}>

// Emotion/Styled Components
const StyledPanel = styled(Dialog.Panel)`
  background: white;
  padding: 24px;
`

// Vanilla CSS
<Dialog.Panel className="dialog-panel">
```

## Controlled vs Uncontrolled

### Flexible State Management

Components support **both patterns**:

```tsx
// Uncontrolled (component manages state)
<Disclosure>
  <Disclosure.Button>Show more</Disclosure.Button>
  <Disclosure.Panel>Content</Disclosure.Panel>
</Disclosure>

// Controlled (you manage state)
const [isOpen, setIsOpen] = useState(false)
<Disclosure as="div" open={isOpen}>
  <Disclosure.Button onClick={() => setIsOpen(!isOpen)}>
    Show more
  </Disclosure.Button>
  <Disclosure.Panel>Content</Disclosure.Panel>
</Disclosure>
```

## Vue Support

### Vue 3 Components

**Only major headless library** with Vue support:

```vue
<script setup>
import { ref } from 'vue'
import { Dialog, DialogPanel, DialogTitle } from '@headlessui/vue'

const isOpen = ref(false)
</script>

<template>
  <Dialog :open="isOpen" @close="isOpen = false">
    <DialogPanel>
      <DialogTitle>Payment successful</DialogTitle>
      <button @click="isOpen = false">Close</button>
    </DialogPanel>
  </Dialog>
</template>
```

**Same API** as React version (where Vue patterns allow).

## Build System Integration

### Framework Agnostic

Works with all React/Vue build tools:

- **Next.js**: No config needed
- **Vite**: Works out-of-box
- **Create React App**: Compatible
- **Remix**: Full support
- **Nuxt** (Vue): Supported

### No Build Step

Pre-built components:
- No CSS to process
- No compilation needed
- Import and use

## Testing Considerations

### Unit Testing

Test as regular React/Vue components:

```tsx
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { Dialog } from '@headlessui/react'

test('opens and closes dialog', async () => {
  const user = userEvent.setup()
  const close = jest.fn()

  render(
    <Dialog open={true} onClose={close}>
      <Dialog.Panel>
        <button onClick={close}>Close</button>
      </Dialog.Panel>
    </Dialog>
  )

  await user.click(screen.getByText('Close'))
  expect(close).toHaveBeenCalled()
})
```

**No special test setup needed.**

## Maintenance & Development

### Development Model

- **Open source**: MIT licensed
- **Maintainer**: Tailwind Labs (Adam Wathan, team)
- **Stability**: Mature, production-ready
- **Release cadence**: Regular updates

### Versioning

Semantic versioning:
- v1.x: Current stable
- v2.x: In development (2025)

**Stable API**: Few breaking changes.

## Limitations & Constraints

### Minimal Component Set

**Only 14 components**:
- No Tooltip
- No Slider
- No Progress
- No Date Picker
- No Table
- No Form components (basic Field/Label only)

**Mitigation**: Build these yourself or use other libraries.

### No Layout Components

No Stack, Grid, Flex, etc. (use Tailwind or custom).

### No Theming System

**You provide**:
- Color system
- Spacing
- Typography
- Component variants

**Good**: Full control
**Bad**: More setup time

### Tailwind Bias

While it works with any CSS:
- Examples use Tailwind
- Transition component expects Tailwind classes
- Best DX with Tailwind

**Not ideal** if not using Tailwind.

## When to Choose Headless UI (Technical POV)

### Ideal Technical Conditions

✅ **Use when:**
- Using Tailwind CSS (excellent integration)
- Need Vue support (only headless option)
- Want minimal bundle size
- Only need core interactive components
- Building custom design system

❌ **Avoid when:**
- Need comprehensive component set
- Not using Tailwind (suboptimal DX)
- Want pre-styled components
- Need advanced widgets (tooltips, sliders, etc.)

## Headless UI vs Radix UI

### Comparison

| Aspect | Headless UI | Radix UI |
|--------|-------------|----------|
| Components | 14 | 25+ |
| Vue support | ✅ Yes | ❌ No |
| Bundle size | ~12 KB | ~varies (per primitive) |
| API verbosity | Moderate | High |
| Tailwind integration | Excellent | Good |
| Transitions built-in | ✅ Yes | ❌ No |
| Ecosystem | Smaller | Larger (powers shadcn/ui) |

**Choose Headless UI if**:
- Using Tailwind
- Need Vue
- Want simpler API

**Choose Radix if**:
- Need more components
- React-only
- Want battle-tested foundation (shadcn/ui uses it)

## Technical Debt Considerations

### Low Long-Term Debt

- Tailwind Labs-backed (stable)
- Minimal API (less to break)
- Vue + React support maintained

### Medium Setup Burden

- Must build component layer
- No theming out-of-box
- Limited component set

## Conclusion

Headless UI is the **minimalist headless library**:

**Strengths:**
- Smallest bundle size
- Excellent Tailwind integration
- Vue + React support (unique)
- Simple, clean API
- Good accessibility

**Trade-offs:**
- Limited component set (14 components)
- No theming system
- Tailwind-biased (less optimal without it)
- Fewer features than Radix

**Best for**: Teams using Tailwind CSS (React or Vue) who want accessible headless components without the complexity of Radix UI. Not suitable if you need comprehensive component coverage.


---

# Mantine - Technical Analysis

## Architecture Overview

### Full-Featured Modern Library

Mantine is a **batteries-included** React component library:

```tsx
import { Button, TextInput, DatePicker } from '@mantine/core'
import { useForm } from '@mantine/form'
import { useDebouncedValue } from '@mantine/hooks'
import { RichTextEditor } from '@mantine/tiptap'
```

**Packages:**
- **@mantine/core**: 120+ components
- **@mantine/hooks**: 70+ utility hooks
- **@mantine/form**: Form management
- **@mantine/dates**: Date/time components
- **@mantine/notifications**: Toast notifications
- **@mantine/tiptap**: Rich text editor
- **@mantine/dropzone**: File upload
- **@mantine/spotlight**: Command palette

Most comprehensive ecosystem in a single library.

## Styling Architecture

### CSS Modules + CSS-in-JS Hybrid

Mantine v7 uses **CSS modules** by default:

```tsx
import classes from './MyComponent.module.css'

<Button className={classes.custom}>Click</Button>
```

**Previously (v6)**: Emotion CSS-in-JS

**Migration rationale**: Better performance, simpler builds

### Theme System

Powerful theming via `MantineProvider`:

```tsx
import { MantineProvider, createTheme } from '@mantine/core'

const theme = createTheme({
  primaryColor: 'blue',
  fontFamily: 'Inter, sans-serif',
  spacing: { xs: '0.5rem', sm: '0.75rem', md: '1rem' },
  radius: { xs: '0.125rem', sm: '0.25rem', md: '0.5rem' },
  breakpoints: {
    xs: '30em',
    sm: '48em',
    md: '64em',
    lg: '74em',
    xl: '90em',
  },
  colors: {
    brand: ['#e3f2fd', '#90caf9', '#2196f3', ...],
  },
  components: {
    Button: {
      defaultProps: { size: 'md' },
      styles: (theme) => ({
        root: { borderRadius: theme.radius.sm },
      }),
    },
  },
})

<MantineProvider theme={theme}>
  <App />
</MantineProvider>
```

### Styles API

Granular component customization:

```tsx
<Button
  styles={(theme) => ({
    root: { backgroundColor: theme.colors.blue[6] },
    label: { fontSize: theme.fontSizes.lg },
    leftIcon: { marginRight: theme.spacing.md },
  })}
>
  Custom Button
</Button>
```

**Every sub-element** is styleable.

### CSS Variables

Mantine generates CSS variables:

```css
:root {
  --mantine-color-blue-6: #228be6;
  --mantine-spacing-md: 1rem;
  --mantine-radius-md: 0.5rem;
}
```

Enables dynamic theming without runtime CSS generation.

## Performance Characteristics

### Bundle Size

**Mantine v7 (2025):**
```
@mantine/core:        ~150 KB (tree-shaken commonly used)
Button only:           ~8 KB
DatePicker:           ~35 KB (with dayjs)
Full package:         ~400 KB (if importing everything)
```

**v7 vs v6**: ~40% smaller due to CSS modules

### Tree-Shaking

Excellent tree-shaking:

```tsx
// ✅ Perfect tree-shaking
import { Button, TextInput } from '@mantine/core'

// ❌ Avoid
import * as Mantine from '@mantine/core'
```

**Package splitting**: Separate packages (@mantine/dates, @mantine/tiptap) reduce main bundle.

### Runtime Performance

**CSS Modules = zero runtime overhead**:
- No CSS-in-JS parsing
- Static classNames
- No theme context lookups (unless using styles API)

**Component performance**:
- Optimized re-renders
- Virtual lists for large datasets
- Memoization built-in

### SSR Support

Full server-side rendering:

```tsx
// Works with Next.js, Remix out-of-box
import { MantineProvider } from '@mantine/core'

export default function Layout({ children }) {
  return (
    <MantineProvider>
      {children}
    </MantineProvider>
  )
}
```

**No special SSR setup needed** (v7+).

## TypeScript Integration

### Type Safety

Written in TypeScript-first:

```tsx
interface ButtonProps {
  variant?: 'filled' | 'light' | 'outline' | 'subtle' | 'default'
  color?: MantineColor
  size?: MantineSize
  radius?: MantineRadius
  fullWidth?: boolean
  leftSection?: ReactNode
  rightSection?: ReactNode
}
```

**Generic components**:

```tsx
<Select<string>
  data={['React', 'Vue', 'Svelte']}
  onChange={(value) => {
    // value is typed as string | null
  }}
/>
```

### Theme Typing

Extend theme types:

```tsx
import type { MantineThemeOverride } from '@mantine/core'

declare module '@mantine/core' {
  export interface MantineThemeColorsOverride {
    colors: Record<'brand', [string, ...string[]]>
  }
}

// Now 'brand' autocompletes
<Button color="brand">Click</Button>
```

### Form Typing

Form values fully typed:

```tsx
interface FormValues {
  email: string
  age: number
}

const form = useForm<FormValues>({
  initialValues: { email: '', age: 0 },
  validate: {
    email: (value) => (/^\S+@\S+$/.test(value) ? null : 'Invalid email'),
    age: (value) => (value >= 18 ? null : 'Must be 18+'),
  },
})

// form.values is typed as FormValues
```

## Component Composition

### Compound Components

Used extensively:

```tsx
<Tabs defaultValue="gallery">
  <Tabs.List>
    <Tabs.Tab value="gallery">Gallery</Tabs.Tab>
    <Tabs.Tab value="messages">Messages</Tabs.Tab>
  </Tabs.List>

  <Tabs.Panel value="gallery">Gallery content</Tabs.Panel>
  <Tabs.Panel value="messages">Messages content</Tabs.Panel>
</Tabs>
```

### Layout Components

Comprehensive layout primitives:

```tsx
// Stack (vertical)
<Stack gap="md">
  <Box>Item 1</Box>
  <Box>Item 2</Box>
</Stack>

// Group (horizontal)
<Group justify="space-between" align="center">
  <Button>Left</Button>
  <Button>Right</Button>
</Group>

// Grid
<Grid>
  <Grid.Col span={4}>1/3 width</Grid.Col>
  <Grid.Col span={8}>2/3 width</Grid.Col>
</Grid>

// Flex
<Flex direction="row" wrap="wrap" gap="md">
  <Box>Item</Box>
</Flex>
```

### Polymorphic Components

Every component supports `component` prop:

```tsx
<Button component="a" href="/dashboard">
  Dashboard
</Button>

<Button component={Link} to="/dashboard">
  Dashboard
</Button>
```

## Hooks Library

### Comprehensive Hooks (70+)

**State Management:**
```tsx
useLocalStorage('theme', 'light')
useSessionStorage('user', null)
useToggle(['light', 'dark'])
useDisclosure(false) // open/close state
```

**DOM Utilities:**
```tsx
useClickOutside(() => setOpened(false))
useHover()
useIntersection(ref, { threshold: 0.5 })
useWindowScroll()
useMediaQuery('(min-width: 768px)')
```

**Form & Input:**
```tsx
useDebouncedValue(search, 500)
useDebouncedState(search, 500)
useInputState('initial')
```

**Misc:**
```tsx
useClipboard()
useIdle(5000) // Detect user inactivity
useFavicon('/icon.png')
useDocumentTitle('Page Title')
```

**No other library provides this many hooks.**

## Form Management

### @mantine/form

Powerful form solution:

```tsx
import { useForm } from '@mantine/form'

const form = useForm({
  initialValues: {
    email: '',
    password: '',
    termsOfService: false,
  },

  validate: {
    email: (value) => (/^\S+@\S+$/.test(value) ? null : 'Invalid email'),
    password: (value) => (
      value.length >= 6 ? null : 'Password must be 6+ characters'
    ),
  },
})

<form onSubmit={form.onSubmit((values) => console.log(values))}>
  <TextInput
    label="Email"
    {...form.getInputProps('email')}
  />
  <PasswordInput
    label="Password"
    {...form.getInputProps('password')}
  />
  <Button type="submit">Submit</Button>
</form>
```

**Features:**
- Field-level validation
- Async validation
- Nested objects/arrays
- Dynamic lists
- Transform values

**Performance**: Only changed fields re-render.

## Date Components

### @mantine/dates

Rich date/time components:

```tsx
import { DatePicker, DateRangePicker, TimeInput } from '@mantine/dates'

<DatePicker
  value={date}
  onChange={setDate}
  minDate={new Date()}
  maxDate={dayjs(new Date()).add(1, 'month').toDate()}
/>

<DateRangePicker
  type="range"
  value={[startDate, endDate]}
  onChange={setRange}
/>

<TimeInput value={time} onChange={setTime} />
```

**Uses dayjs** (lightweight date library).

## Accessibility Implementation

### Excellent Accessibility

Mantine emphasizes a11y:

```tsx
// Modal focus trapping, Escape closes
<Modal opened={opened} onClose={close}>
  <Modal.Header>Title</Modal.Header>
  <Modal.Body>Content</Modal.Body>
</Modal>

// Menu keyboard navigation
<Menu>
  <Menu.Target><Button>Actions</Button></Menu.Target>
  <Menu.Dropdown>
    <Menu.Item>Download</Menu.Item>
  </Menu.Dropdown>
</Menu>
```

**Features:**
- Full keyboard navigation
- Screen reader support
- ARIA attributes automatic
- Focus management
- Skip links

**Documentation** emphasizes accessibility patterns.

## Customization Mechanisms

### Global Styles Override

```tsx
<MantineProvider
  theme={{
    components: {
      Button: {
        defaultProps: {
          size: 'md',
          variant: 'filled',
        },
        styles: {
          root: { fontWeight: 600 },
          label: { textTransform: 'uppercase' },
        },
      },
    },
  }}
>
```

### CSS Variables

Override via CSS:

```css
:root {
  --mantine-primary-color-filled: #1c7ed6;
  --mantine-radius-default: 0.5rem;
}
```

### Variants

Create custom variants:

```tsx
<MantineProvider
  theme={{
    components: {
      Button: Button.extend({
        variants: {
          danger: (theme) => ({
            root: {
              backgroundColor: theme.colors.red[6],
              color: 'white',
            },
          }),
        },
      }),
    },
  }}
>

// Usage
<Button variant="danger">Delete</Button>
```

## Build System Integration

### Next.js

Official integration:

```bash
npm install @mantine/next
```

```tsx
// app/layout.tsx
import { MantineProvider } from '@mantine/core'
import { ColorSchemeScript } from '@mantine/core'

export default function RootLayout({ children }) {
  return (
    <html>
      <head>
        <ColorSchemeScript />
      </head>
      <body>
        <MantineProvider>{children}</MantineProvider>
      </body>
    </html>
  )
}
```

### Vite

Works out-of-box:

```tsx
import '@mantine/core/styles.css'
```

### Remix

Official support with hydration handling.

## Testing Considerations

### Testing Utilities

`@mantine/tests` package provides utilities:

```tsx
import { render, screen } from '@mantine/tests'

test('renders button', () => {
  render(<Button>Click me</Button>)
  expect(screen.getByRole('button')).toHaveTextContent('Click me')
})
```

Handles MantineProvider automatically.

### Snapshot Testing

**Stable** with CSS Modules:
- No generated classNames
- Deterministic output

## Upgrade Path

### v6 → v7 Migration

Major changes (2024):
- Emotion → CSS Modules
- Import styles: `import '@mantine/core/styles.css'`
- Some component API changes

**Codemod available**:
```bash
npx @mantine/codemod@latest v6-to-v7 src/
```

**Breaking changes documented** thoroughly.

## Ecosystem

### Official Packages (All Free)

- **@mantine/hooks**: 70+ hooks
- **@mantine/form**: Form management
- **@mantine/dates**: Date/time components
- **@mantine/notifications**: Toast system
- **@mantine/tiptap**: Rich text editor
- **@mantine/dropzone**: File upload
- **@mantine/spotlight**: Command palette
- **@mantine/carousel**: Image carousel
- **@mantine/nprogress**: Progress bar

**Everything is free** (no premium tier).

### Community

- Active Discord community
- Regular releases
- Responsive maintainers

## Limitations & Constraints

### No Premium/Advanced Components

- No data grid (like MUI X)
- No Gantt chart
- No org chart

**Mitigation**: Use third-party libraries (TanStack Table, etc.)

### CSS Modules Learning Curve

Teams used to CSS-in-JS may need adjustment (v7+).

### Not Opinionated

- No specific design language (unlike MUI = Material, Ant = Enterprise)
- More customization needed for cohesive look

## When to Choose Mantine (Technical POV)

### Ideal Technical Conditions

✅ **Use when:**
- Want comprehensive component + hooks library
- Need form handling built-in
- Date/time pickers required
- Don't need premium components (data grid)
- Want zero-runtime styling (v7+)
- Team values DX and completeness

❌ **Avoid when:**
- Need data grid/advanced enterprise components
- Using Tailwind (different paradigm)
- Want specific design language (Material, etc.)

## Technical Debt Considerations

### Low Long-Term Debt

- v6→v7 migration smooth with codemod
- No premium licenses to manage
- Active development

### Low Maintenance Burden

- Regular updates
- Good backward compatibility within versions
- Community support

## Conclusion

Mantine is the **most feature-complete** free React UI library:

**Strengths:**
- 120+ components + 70+ hooks (everything you need)
- Excellent TypeScript support
- Zero-runtime styling (v7+)
- Comprehensive ecosystem (forms, dates, notifications, etc.)
- All free (no paid tiers)
- Great documentation

**Trade-offs:**
- No advanced data components (grid, charts)
- Less opinionated (more setup for cohesive design)
- Smaller community than MUI/Ant
- Not compatible with Tailwind

**Best for**: Teams that want a batteries-included library with modern DX, don't need advanced enterprise components, and value completeness over specific design languages.


---

# MUI (Material-UI) - Technical Analysis

## Architecture Overview

### Component System Design

MUI implements **Google's Material Design specification** as React components:

```tsx
import Button from '@mui/material/Button'
import { ThemeProvider, createTheme } from '@mui/material/styles'
```

**Architecture layers:**
1. **@mui/system**: Style engine and utilities
2. **@mui/material**: Material Design components
3. **@mui/icons-material**: 2000+ Material icons
4. **@mui/lab**: Experimental components
5. **@mui/x-data-grid** / **@mui/x-date-pickers**: Premium/advanced components

### Styling Engine: Emotion

MUI v5+ uses **Emotion** (CSS-in-JS):

```tsx
// Runtime CSS generation
<Button sx={{
  color: 'primary.main',
  '&:hover': {
    bgcolor: 'primary.dark',
  }
}} />
```

**Previously**: JSS (v4) - migration to Emotion improved performance

## Styling Architecture

### sx Prop System

The `sx` prop is MUI's primary styling API:

```tsx
<Box
  sx={{
    width: 300,
    height: 300,
    bgcolor: 'primary.main',
    '&:hover': {
      bgcolor: 'primary.dark',
    },
    '@media (min-width: 600px)': {
      width: 400,
    },
  }}
/>
```

**Features:**
- **Theme-aware**: Accesses theme values directly
- **Responsive**: Breakpoint arrays `{ xs: 12, md: 6 }`
- **Type-safe**: Full TypeScript support
- **Shorthand props**: `bgcolor`, `p` (padding), `m` (margin)

**Implementation**: Converts to Emotion's `css` prop at runtime

### Theme System

Comprehensive theming via `createTheme`:

```tsx
const theme = createTheme({
  palette: {
    primary: { main: '#1976d2' },
    secondary: { main: '#dc004e' },
  },
  typography: {
    fontFamily: 'Roboto, sans-serif',
    h1: { fontSize: '2.5rem' },
  },
  spacing: 8, // Base unit (1 = 8px)
  shape: { borderRadius: 4 },
  components: {
    MuiButton: {
      styleOverrides: {
        root: { textTransform: 'none' },
      },
    },
  },
})
```

**Theme capabilities:**
- **Palette**: Colors, contrast thresholds
- **Typography**: Font scales, variants
- **Spacing**: Grid system
- **Breakpoints**: Responsive design
- **Component overrides**: Per-component customization
- **Dark mode**: Built-in support via `mode: 'dark'`

### CSS Injection Strategy

Emotion injects styles at **runtime**:

1. Component renders
2. `sx` prop evaluated against theme
3. CSS generated
4. Style tag injected into `<head>`
5. ClassName applied

**Performance implication**: First render slower due to CSS generation

## Performance Characteristics

### Bundle Size

**Material-UI v5 (2025):**
```
@mui/material:        ~300 KB (full package)
Single Button:         ~15 KB (with tree-shaking)
Button + TextField:    ~45 KB
Emotion runtime:       ~15 KB
```

**Compared to v4**: 30% smaller due to Emotion migration

### Tree-Shaking

**Named imports required** for tree-shaking:

```tsx
// ✅ Good - only Button bundled
import Button from '@mui/material/Button'

// ❌ Bad - entire library bundled
import { Button } from '@mui/material'
```

**Effectiveness**: Good but requires correct import pattern

### Runtime Performance

**CSS-in-JS overhead:**
- Style recalculation on theme changes
- Runtime CSS parsing
- Emotion caching helps but not free

**Mitigation strategies:**
- `styled()` API for static styles (compiled once)
- Memoization for complex `sx` props
- Zero-runtime mode (experimental in v6)

### Server-Side Rendering (SSR)

Excellent SSR support:

```tsx
// Extract critical CSS for initial page load
import { ServerStyleSheets } from '@mui/styles'

const sheets = new ServerStyleSheets()
const html = renderToString(sheets.collect(<App />))
const css = sheets.toString()
```

**Next.js integration**: Official plugin handles SSR automatically

## TypeScript Integration

### Type Safety

MUI is **TypeScript-first**:

```tsx
interface ButtonProps {
  variant?: 'text' | 'outlined' | 'contained'
  color?: 'primary' | 'secondary' | 'error' | 'info' | 'success' | 'warning'
  size?: 'small' | 'medium' | 'large'
  disabled?: boolean
  startIcon?: ReactNode
  endIcon?: ReactNode
}
```

**sx prop typing**: Fully typed, including autocomplete

### Theme Augmentation

Extend theme types for custom properties:

```tsx
declare module '@mui/material/styles' {
  interface Palette {
    neutral: Palette['primary']
  }
  interface PaletteOptions {
    neutral?: PaletteOptions['primary']
  }
}

// Now 'neutral' is a valid color
<Button color="neutral" />
```

### Generic Component Props

Polymorphic `component` prop is fully typed:

```tsx
// Button renders as Link with correct props
<Button<typeof Link>
  component={Link}
  to="/dashboard" // TypeScript knows this is valid
/>
```

## Component Composition

### Material Design Patterns

MUI implements MD specifications precisely:

**Elevation system:**
```tsx
<Paper elevation={3} /> // 3dp shadow (0-24)
```

**Ripple effect:**
```tsx
<ButtonBase> // Provides Material ripple
  <CustomContent />
</ButtonBase>
```

**State layers:**
- Hover: 4% opacity overlay
- Focus: 12% opacity
- Pressed: 12% opacity

### Compound Components

Used selectively for complex widgets:

```tsx
<Tabs value={tab} onChange={handleChange}>
  <Tab label="One" />
  <Tab label="Two" />
</Tabs>

<Dialog open={open}>
  <DialogTitle>Title</DialogTitle>
  <DialogContent>Content</DialogContent>
  <DialogActions>
    <Button>Cancel</Button>
    <Button>Confirm</Button>
  </DialogActions>
</Dialog>
```

### Slot System (v5+)

Override internal component parts:

```tsx
<Button
  slots={{
    root: CustomButtonRoot,
  }}
  slotProps={{
    root: { className: 'custom-class' },
  }}
/>
```

## Accessibility Implementation

### WAI-ARIA Compliance

MUI components follow **Material Design Accessibility** spec:

```tsx
<TextField
  label="Email"
  error={hasError}
  helperText="Invalid email"
  // Generates:
  // role="textbox"
  // aria-invalid="true"
  // aria-describedby="helper-text-id"
/>
```

**Built-in features:**
- Keyboard navigation
- ARIA attributes
- Focus management
- Screen reader labels

### Color Contrast

Theme includes **contrast utilities**:

```tsx
theme.palette.getContrastText('#1976d2') // Returns white or black
```

Ensures WCAG AA compliance by default.

## Customization Mechanisms

### Four Customization Levels

**1. One-off customization (sx prop):**
```tsx
<Button sx={{ borderRadius: 10 }} />
```

**2. Reusable component (styled):**
```tsx
const CustomButton = styled(Button)({
  borderRadius: 10,
})
```

**3. Global theme overrides:**
```tsx
createTheme({
  components: {
    MuiButton: {
      styleOverrides: {
        root: { borderRadius: 10 },
      },
    },
  },
})
```

**4. Custom components:**
```tsx
createTheme({
  components: {
    MuiButton: {
      defaultProps: { variant: 'outlined' },
      styleOverrides: { /* ... */ },
      variants: [
        {
          props: { variant: 'dashed' },
          style: { border: '1px dashed' },
        },
      ],
    },
  },
})
```

## Advanced Features

### MUI X (Premium)

Commercial components with advanced features:

**Data Grid:**
```tsx
import { DataGridPro } from '@mui/x-data-grid-pro'

<DataGridPro
  rows={rows}
  columns={columns}
  pagination
  sorting
  filtering
  grouping
  treeData
  aggregation
/>
```

**Pricing**: $495-$1660 per developer (perpetual license)

**Date/Time Pickers:**
- Date range pickers
- Time pickers
- DateTime pickers
- Multi-language support

### Lab Components

Experimental components (free):

```tsx
import { Masonry, Timeline, TreeView } from '@mui/lab'
```

Graduated to core when stable (e.g., Autocomplete, Pagination)

## Build System Integration

### Next.js

Official integration:

```bash
npm install @mui/material-nextjs
```

```tsx
// app/layout.tsx
import { AppRouterCacheProvider } from '@mui/material-nextjs/v13-appRouter'

export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        <AppRouterCacheProvider>
          {children}
        </AppRouterCacheProvider>
      </body>
    </html>
  )
}
```

### Vite

Works out of the box:
```tsx
import { Button } from '@mui/material'
```

Tree-shaking automatic with Vite's Rollup integration.

### Create React App

No special config needed (SSR not relevant).

## Testing Considerations

### Unit Testing

Requires theme provider in tests:

```tsx
import { render } from '@testing-library/react'
import { ThemeProvider, createTheme } from '@mui/material/styles'

const theme = createTheme()

test('renders button', () => {
  render(
    <ThemeProvider theme={theme}>
      <Button>Click</Button>
    </ThemeProvider>
  )
})
```

**Alternatively**: Create a custom render function

### Snapshot Testing

**Unstable** due to generated classNames:

```tsx
// Generated class names change between runs
<button class="MuiButton-root MuiButton-contained css-1e6y48t">
```

**Solution**: Use `@testing-library/jest-dom` assertions instead

## Migration & Upgrade Path

### v4 → v5 Migration

Major rewrite (2021):
- JSS → Emotion
- `makeStyles` → `styled` or `sx`
- Import paths changed

**Codemod available:**
```bash
npx @mui/codemod v5.0.0/preset-safe src/
```

### v5 → v6 (Upcoming)

Focus on performance:
- Zero-runtime CSS option
- Smaller bundle sizes
- Improved tree-shaking

**Migration**: Expected to be smoother than v4→v5

## Maintenance & Ecosystem

### Development Model

- **Open source**: MIT licensed (core)
- **Company-backed**: MUI SAS (formerly Material-UI)
- **Premium tiers**: MUI X Pro/Premium
- **Community**: 90K+ GitHub stars
- **Release cadence**: Monthly minor releases

### Long-Term Support

- v4 maintained until 2022
- v5 current stable (2021+)
- v6 in development (2025)

Enterprise support available ($$$)

## Limitations & Constraints

### Material Design Lock-In

**Visual identity** is Material Design:
- Hard to completely override MD look
- Clients may recognize "Google aesthetic"
- Custom design systems require heavy theming

### Bundle Size

**Larger than minimal alternatives**:
- Emotion runtime required
- Icon package separate but large (2000+ icons)
- Full package ~300 KB

### Runtime Cost

CSS-in-JS has overhead:
- Style injection on mount
- Re-calculation on theme changes
- Not ideal for very large lists

## When to Choose MUI (Technical POV)

### Ideal Technical Conditions

✅ **Use when:**
- Need comprehensive component library (60+ components)
- Want Material Design aesthetic
- Building data-heavy applications (MUI X Data Grid)
- Team comfortable with CSS-in-JS
- Need excellent TypeScript support
- Want commercial support option

❌ **Avoid when:**
- Bundle size critical (`<100` KB target)
- Custom design system required (not MD)
- Need maximum runtime performance
- Building with Tailwind (no integration)

## Technical Debt Considerations

### Medium Long-Term Debt

- Major version migrations require codemods
- Premium components create vendor lock-in
- CSS-in-JS may fall out of favor (industry trend)

### Low Maintenance Burden

- Active development
- Security patches regular
- Breaking changes minimized in minor versions
- Good upgrade tooling (codemods)

## Conclusion

MUI is a **mature, comprehensive** component library with:

**Strengths:**
- Complete Material Design implementation
- Excellent TypeScript support
- Powerful theming system
- Enterprise-grade data components (MUI X)
- Large ecosystem and community

**Trade-offs:**
- Larger bundle size
- Runtime CSS-in-JS overhead
- Material Design visual lock-in
- Premium features require licensing

Best for teams building **enterprise applications** that benefit from Material Design's proven patterns and don't mind the bundle/runtime cost.


---

# Radix UI - Technical Analysis

## Architecture Overview

### Headless/Unstyled Primitives

Radix UI provides **behavior and accessibility without styling**:

```tsx
import * as Dialog from '@radix-ui/react-dialog'

<Dialog.Root>
  <Dialog.Trigger className="your-button-class">Open</Dialog.Trigger>
  <Dialog.Portal>
    <Dialog.Overlay className="your-overlay-class" />
    <Dialog.Content className="your-content-class">
      <Dialog.Title>Title</Dialog.Title>
      <Dialog.Description>Description</Dialog.Description>
      <Dialog.Close>Close</Dialog.Close>
    </Dialog.Content>
  </Dialog.Portal>
</Dialog.Root>
```

**You provide**: All styling (CSS, Tailwind, CSS-in-JS, etc.)

**Radix provides**: Accessibility, keyboard navigation, focus management, state management

## Design Philosophy

### Primitives, Not Components

Radix components are **building blocks**:

- **Low-level**: Granular control over every element
- **Composable**: Combine primitives to create custom components
- **Unstyled**: No opinions on visual design
- **Accessible**: WAI-ARIA compliant by default

**Intended use**: Foundation for design systems, not direct consumption.

### Component Model: Compound Components

All Radix components use **compound component pattern**:

```tsx
// Root: Manages state
<Dialog.Root open={open} onOpenChange={setOpen}>

  // Trigger: Opens dialog
  <Dialog.Trigger asChild>
    <button>Open</button>
  </Dialog.Trigger>

  // Portal: Renders outside DOM hierarchy
  <Dialog.Portal>

    // Overlay: Background overlay
    <Dialog.Overlay />

    // Content: Main dialog content
    <Dialog.Content>
      <Dialog.Title>Title</Dialog.Title>
      <Dialog.Description>Accessible description</Dialog.Description>
      <Dialog.Close>Close</Dialog.Close>
    </Dialog.Content>
  </Dialog.Portal>
</Dialog.Root>
```

**Benefits:**
- Full control over structure
- Easy to understand what each part does
- Can customize/omit parts as needed

**Trade-off**: More verbose than single-component APIs

## Performance Characteristics

### Bundle Size

**Radix primitives are tiny:**

```
@radix-ui/react-dialog:     ~7 KB (gzipped)
@radix-ui/react-dropdown:   ~9 KB (gzipped)
@radix-ui/react-popover:    ~5 KB (gzipped)
@radix-ui/react-select:    ~15 KB (gzipped)
@radix-ui/react-slider:     ~4 KB (gzipped)
```

**No styling engine** = minimal overhead.

### Tree-Shaking

Perfect tree-shaking:

```tsx
// ✅ Only Dialog bundled
import * as Dialog from '@radix-ui/react-dialog'

// Each primitive is a separate package
import * as DropdownMenu from '@radix-ui/react-dropdown-menu'
```

**Import only what you use.**

### Runtime Performance

**Zero styling overhead**:
- No CSS-in-JS runtime
- No theme provider (unless you add one)
- Minimal JavaScript

**React performance**:
- Optimized re-renders
- Controlled/uncontrolled patterns
- No unnecessary state updates

### SSR Support

Full server-side rendering:

```tsx
// Works with Next.js, Remix out-of-box
import * as Dialog from '@radix-ui/react-dialog'
```

**No hydration issues** when used correctly.

## TypeScript Integration

### Type Safety

Fully typed in TypeScript:

```tsx
import * as Dialog from '@radix-ui/react-dialog'

interface DialogContentProps extends React.ComponentPropsWithoutRef<
  typeof Dialog.Content
> {
  className?: string
}

const DialogContent = React.forwardRef<
  React.ElementRef<typeof Dialog.Content>,
  DialogContentProps
>(({ className, children, ...props }, ref) => (
  <Dialog.Portal>
    <Dialog.Overlay />
    <Dialog.Content ref={ref} className={className} {...props}>
      {children}
    </Dialog.Content>
  </Dialog.Portal>
))
```

**Component types** exported for extensions.

### Polymorphic Components (asChild)

`asChild` prop enables **slot pattern**:

```tsx
// Render Trigger as custom component
<Dialog.Trigger asChild>
  <Link to="/settings">Open Settings</Link>
</Dialog.Trigger>
```

**Implementation**: Radix Slot merges props and renders as child.

**Typed correctly**: TypeScript infers child component props.

## Accessibility Implementation

### WAI-ARIA Compliant

Radix is **accessibility-first**:

**Dialog example:**
```tsx
<Dialog.Root>
  {/* Automatically adds:
      - role="dialog"
      - aria-modal="true"
      - aria-labelledby (points to Title)
      - aria-describedby (points to Description)
      - Focus trap
      - Escape key closes
      - Click outside closes
  */}
  <Dialog.Content>
    <Dialog.Title>Edit Profile</Dialog.Title>
    <Dialog.Description>
      Make changes to your profile here.
    </Dialog.Description>
  </Dialog.Content>
</Dialog.Root>
```

**Menu example:**
```tsx
<DropdownMenu.Root>
  {/* Automatically adds:
      - role="menu"
      - aria-haspopup="true"
      - Arrow key navigation
      - Home/End navigation
      - Type-ahead selection
      - Escape closes
  */}
</DropdownMenu.Root>
```

### Focus Management

**Automatic focus handling:**
- Focus trap in dialogs
- Focus return on close
- First/last item focus with Tab
- Roving tabindex in menus

### Keyboard Navigation

**Full keyboard support:**
- Arrow keys (menus, sliders, tabs)
- Enter/Space (activation)
- Escape (close/cancel)
- Home/End (navigation)
- Tab (focus management)

## Component Architecture

### 25+ Primitives

**Overlays:**
- Dialog (modal)
- Popover
- Dropdown Menu
- Context Menu
- Hover Card
- Tooltip

**Navigation:**
- Accordion
- Tabs
- Navigation Menu

**Forms:**
- Checkbox
- Radio Group
- Select
- Slider
- Switch
- Toggle
- Toggle Group

**Data Display:**
- Avatar
- Progress
- Scroll Area

**Utilities:**
- Collapsible
- Separator
- Label
- Visually Hidden
- Portal
- Slot

### State Management

Components can be **controlled or uncontrolled**:

```tsx
// Uncontrolled (Radix manages state)
<Dialog.Root>
  <Dialog.Trigger>Open</Dialog.Trigger>
  <Dialog.Content>Content</Dialog.Content>
</Dialog.Root>

// Controlled (you manage state)
const [open, setOpen] = useState(false)
<Dialog.Root open={open} onOpenChange={setOpen}>
  <Dialog.Trigger>Open</Dialog.Trigger>
  <Dialog.Content>Content</Dialog.Content>
</Dialog.Root>
```

**Flexibility**: Use uncontrolled for simple cases, controlled when you need to sync state.

## Styling Integration

### Works with Any Styling Solution

**Tailwind CSS:**
```tsx
<Dialog.Content className="rounded-lg bg-white p-6 shadow-xl">
  <Dialog.Title className="text-lg font-semibold">
    Edit Profile
  </Dialog.Title>
</Dialog.Content>
```

**CSS Modules:**
```tsx
import styles from './Dialog.module.css'

<Dialog.Content className={styles.content}>
  <Dialog.Title className={styles.title}>Edit Profile</Dialog.Title>
</Dialog.Content>
```

**Emotion/Styled Components:**
```tsx
const StyledContent = styled(Dialog.Content)`
  background: white;
  border-radius: 8px;
  padding: 24px;
`
```

**Vanilla CSS:**
```css
.dialog-content {
  background: white;
  border-radius: 8px;
  padding: 24px;
}
```

### Data Attributes for State

Radix adds **data attributes** for styling states:

```tsx
<Dialog.Overlay data-state="open" />

// CSS
.dialog-overlay[data-state='open'] {
  animation: fadeIn 200ms;
}

.dialog-overlay[data-state='closed'] {
  animation: fadeOut 200ms;
}
```

**Available states**: `data-state`, `data-disabled`, `data-orientation`, etc.

## Customization & Extension

### Building on Radix

Radix is **designed to be wrapped**:

```tsx
// Create your own styled Dialog
export const Dialog = (props) => (
  <RadixDialog.Root {...props} />
)

export const DialogTrigger = ({ children, ...props }) => (
  <RadixDialog.Trigger asChild {...props}>
    {children}
  </RadixDialog.Trigger>
)

export const DialogContent = ({ children, ...props }) => (
  <RadixDialog.Portal>
    <RadixDialog.Overlay className="fixed inset-0 bg-black/50" />
    <RadixDialog.Content
      className="fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2"
      {...props}
    >
      {children}
    </RadixDialog.Content>
  </RadixDialog.Portal>
)
```

**This is how shadcn/ui works** - it wraps Radix with Tailwind styles.

## Build System Integration

### Framework Agnostic

Works with all React build tools:

- **Next.js**: No special config
- **Vite**: Works out-of-box
- **Create React App**: No issues
- **Remix**: Full support
- **Gatsby**: Compatible

### No Build Step Required

Radix primitives are **pre-built**:
- No CSS to process
- No compile step
- Import and use

## Testing Considerations

### Unit Testing

Test as regular React components:

```tsx
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import * as Dialog from '@radix-ui/react-dialog'

test('opens and closes dialog', async () => {
  const user = userEvent.setup()

  render(
    <Dialog.Root>
      <Dialog.Trigger>Open</Dialog.Trigger>
      <Dialog.Content>
        <Dialog.Title>Title</Dialog.Title>
        <Dialog.Close>Close</Dialog.Close>
      </Dialog.Content>
    </Dialog.Root>
  )

  await user.click(screen.getByText('Open'))
  expect(screen.getByText('Title')).toBeInTheDocument()

  await user.click(screen.getByText('Close'))
  expect(screen.queryByText('Title')).not.toBeInTheDocument()
})
```

**No special setup needed.**

### Accessibility Testing

Use `jest-axe` or `@axe-core/react`:

```tsx
import { axe } from 'jest-axe'

test('dialog is accessible', async () => {
  const { container } = render(<Dialog />)
  const results = await axe(container)
  expect(results).toHaveNoViolations()
})
```

Radix components **pass accessibility audits** by default.

## Maintenance & Development

### Development Model

- **Open source**: MIT licensed
- **Maintainer**: WorkOS (company-backed)
- **Community**: Active development
- **Stability**: Mature, production-ready

### Versioning

Radix follows **semantic versioning**:
- Major versions: Breaking changes
- Minor versions: New features
- Patch versions: Bug fixes

**Stable API**: Breaking changes rare after 1.0.

## Limitations & Constraints

### Not Ready-to-Use

**You must:**
- Write all CSS/styling
- Decide on visual design
- Create your own variants
- Handle theming

**Time investment**: More setup than pre-styled libraries.

### No Pre-Built Components

**Missing:**
- Pre-styled buttons, inputs
- Layout components (Grid, Stack)
- Utility components (Card, Badge)

**Mitigation**: Build these yourself or use with shadcn/ui.

### Verbose API

Compound components = more code:

```tsx
// Radix (verbose)
<Dialog.Root>
  <Dialog.Trigger>Open</Dialog.Trigger>
  <Dialog.Portal>
    <Dialog.Overlay />
    <Dialog.Content>
      <Dialog.Title>Title</Dialog.Title>
      <Dialog.Description>Description</Dialog.Description>
      <form>
        {/* ... */}
      </form>
    </Dialog.Content>
  </Dialog.Portal>
</Dialog.Root>

// vs Single-component API (concise)
<Dialog
  trigger={<button>Open</button>}
  title="Title"
  description="Description"
>
  <form>{/* ... */}</form>
</Dialog>
```

**Trade-off**: Verbosity for flexibility.

## When to Choose Radix UI (Technical POV)

### Ideal Technical Conditions

✅ **Use when:**
- Building custom design system
- Need full control over styling
- Want minimal bundle size
- Accessibility is critical
- Using Tailwind or custom CSS
- Team comfortable with compound components

❌ **Avoid when:**
- Need pre-styled components (use shadcn/ui instead)
- Want quick prototyping (use MUI/Chakra)
- Team unfamiliar with headless libraries
- Don't want to write CSS

## Technical Debt Considerations

### Low Long-Term Debt

- Stable API
- Company-backed (WorkOS)
- No major breaking changes expected
- Can migrate away (no vendor lock-in)

### Medium Setup Burden

- Must build your own component layer
- Theming requires custom solution
- More code to maintain vs pre-styled

## Conclusion

Radix UI is **the foundation for custom design systems**:

**Strengths:**
- Excellent accessibility (best-in-class)
- Minimal bundle size
- Full styling control
- Stable, production-ready API
- Powers shadcn/ui (proven at scale)

**Trade-offs:**
- Requires custom styling layer
- More verbose API
- More setup time
- No pre-built variants

**Best for**: Teams building custom design systems who need accessible primitives and full styling control. Not for rapid prototyping or teams wanting pre-styled components (use shadcn/ui for that).


---

# S2 Technical Recommendations

## Decision Framework: Architecture-First

Choose based on **technical architecture requirements**, not popularity:

### 1. Styling Architecture Decision

**Question**: What styling approach does your team use?

```
├─ Tailwind CSS
│  ├─ Want pre-built components → shadcn/ui
│  └─ Building from primitives → Headless UI
│
├─ CSS Modules / Vanilla CSS
│  ├─ Want comprehensive library → Mantine
│  └─ Building design system → Radix UI
│
└─ CSS-in-JS (Emotion, styled-components)
   ├─ Prop-based styling preference → Chakra UI
   ├─ Material Design required → MUI
   └─ Enterprise/data-heavy → Ant Design
```

### 2. Performance Requirements

**Question**: What are your bundle/performance constraints?

| Requirement | Recommendation | Bundle Size | Runtime Cost |
|-------------|---------------|-------------|--------------|
| **< 20 KB total** | Headless UI or Radix UI | ~8-15 KB | Zero |
| **< 50 KB total** | shadcn/ui or Mantine | ~20-35 KB | Zero (static CSS) |
| **< 100 KB total** | Chakra UI | ~45 KB | Low (Emotion cached) |
| **No constraint** | MUI or Ant Design | ~70-85 KB | Medium (CSS-in-JS) |

**Runtime performance ranking:**
1. Headless UI + Tailwind (static classes)
2. Radix UI + CSS Modules (static CSS)
3. Mantine v7 (CSS Modules)
4. shadcn/ui (CVA + Tailwind)
5. Chakra UI (Emotion cached)
6. MUI (Emotion runtime)
7. Ant Design (token system + CSS-in-JS)

### 3. Component Coverage Needs

**Question**: What components do you absolutely need?

| Need | Best Choice | Why |
|------|------------|-----|
| **Advanced data tables** | Ant Design | Best-in-class Table with sorting, filtering, pagination, fixed columns, virtual scrolling |
| **Date/time pickers** | Mantine or Ant Design | Comprehensive date components (Mantine free, Ant Design free, MUI X paid) |
| **Form handling** | Ant Design or Mantine | Powerful form libraries (@ant-design/form, @mantine/form) |
| **Rich text editor** | Mantine | @mantine/tiptap built-in (others need third-party) |
| **File upload** | Mantine | @mantine/dropzone built-in |
| **Command palette** | Mantine | @mantine/spotlight built-in |
| **Basic components only** | Headless UI or Radix UI | Overlays, menus, navigation - build the rest |

**Component count (free):**
- Mantine: 120+ (most comprehensive)
- Ant Design: 60+ (enterprise focus)
- MUI: 50+ core (MUI X paid)
- Chakra UI: 50+
- shadcn/ui: 40+
- Radix UI: 25+ primitives
- Headless UI: 14 components

### 4. Customization Depth

**Question**: How much customization do you need?

```
Full Custom Design System (from scratch)
├─ React-only → Radix UI
└─ Need Vue support → Headless UI
   │
   └─ Then consider wrapping like shadcn/ui does

Moderate Customization (theme existing library)
├─ Easiest via props → Chakra UI
├─ Best theming system → Mantine
└─ Need Material base → MUI

Minimal Customization (use defaults)
├─ Material Design → MUI
├─ Enterprise aesthetic → Ant Design
└─ Modern minimalist → Mantine or Chakra
```

## Technical Architecture Patterns

### Pattern 1: Headless + Styling Layer

**Best for**: Maximum control, custom design systems

**Architecture:**
```
Radix UI (behavior/a11y) + Tailwind CSS (styling) + CVA (variants) = shadcn/ui pattern
```

**Example implementation:**
```tsx
// 1. Start with Radix primitive
import * as DialogPrimitive from '@radix-ui/react-dialog'

// 2. Add Tailwind styling layer
const DialogContent = ({ children, ...props }) => (
  <DialogPrimitive.Portal>
    <DialogPrimitive.Overlay className="fixed inset-0 bg-black/50" />
    <DialogPrimitive.Content
      className="fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2
                 max-w-md rounded-lg bg-white p-6 shadow-xl"
      {...props}
    >
      {children}
    </DialogPrimitive.Content>
  </DialogPrimitive.Portal>
)

// 3. Add variants with CVA
import { cva } from 'class-variance-authority'

const dialogVariants = cva('rounded-lg bg-white p-6', {
  variants: {
    size: {
      sm: 'max-w-sm',
      md: 'max-w-md',
      lg: 'max-w-lg',
    },
  },
})
```

**Pros:**
- Complete styling control
- Smallest possible bundle
- Perfect accessibility
- No library updates break your styles

**Cons:**
- More initial setup
- Must build component layer yourself
- Need CSS/Tailwind proficiency

### Pattern 2: Full-Featured Library

**Best for**: Rapid development, standard applications

**Architecture:**
```
Mantine or Chakra UI (complete system)
```

**Example implementation:**
```tsx
import { MantineProvider } from '@mantine/core'
import { Button, Modal, Table } from '@mantine/core'

// Theme once, use everywhere
<MantineProvider theme={{ primaryColor: 'blue' }}>
  <App />
</MantineProvider>
```

**Pros:**
- Everything included (components + hooks + forms + dates)
- Fast time-to-market
- Consistent DX across all components
- Minimal setup

**Cons:**
- Larger bundle (but still reasonable)
- Some unused features bundled
- Less styling control
- Design system opinions baked in

### Pattern 3: Enterprise Pre-Styled

**Best for**: Enterprise applications, data-heavy dashboards

**Architecture:**
```
Ant Design or MUI (established enterprise libraries)
```

**Example implementation:**
```tsx
import { ConfigProvider } from 'antd'
import { Table, Form, DatePicker } from 'antd'

<ConfigProvider theme={{ token: { colorPrimary: '#00b96b' } }}>
  <App />
</ConfigProvider>
```

**Pros:**
- Advanced components (data tables, complex forms)
- Proven at scale (Alibaba, Netflix, Spotify)
- Enterprise features out-of-box
- Commercial support available

**Cons:**
- Largest bundles
- Strong visual identity (hard to customize away)
- CSS-in-JS overhead (MUI, Ant v5)
- Premium features may require payment (MUI X)

## Technical Migration Paths

### From Bootstrap → Modern Libraries

**Easiest**: Chakra UI (prop-based similar to Bootstrap classes)
```tsx
// Bootstrap
<div className="d-flex justify-content-between align-items-center p-4">

// Chakra UI
<Flex justify="space-between" align="center" p={4}>
```

**Alternative**: Mantine (comprehensive like Bootstrap)

### From Material-UI v4 → Modern

**Stay in ecosystem**: MUI v5 (codemod available)
```bash
npx @mui/codemod v5.0.0/preset-safe src/
```

**Switch to headless**: Radix UI + Tailwind (rewrites but full control)

### From Custom CSS → Component Library

**If using Tailwind**: shadcn/ui (keeps Tailwind patterns)

**If not using Tailwind**: Mantine (CSS Modules, familiar patterns)

### From CSS-in-JS → Modern

**2025 trend**: Move away from runtime CSS-in-JS

- **Mantine v6 → v7**: Emotion → CSS Modules (official migration)
- **Chakra v2 → v3**: Moving to zero-runtime (Panda CSS)
- **Alternative**: Switch to shadcn/ui or Headless UI (no CSS-in-JS)

## Testing Architecture

### For Maximum Test Stability

**Choose**: Mantine v7, Radix UI, Headless UI, or shadcn/ui

**Why**: Static CSS = stable snapshots
```tsx
// Generated class: "Button_root__abc123" (stable across runs)
<button className="rounded-lg bg-blue-500 px-4 py-2">
  Click me
</button>
```

### If Using CSS-in-JS Libraries

**Avoid**: Snapshot testing

**Instead**: Test behavior and DOM structure
```tsx
// ❌ Snapshot (breaks on CSS-in-JS updates)
expect(container).toMatchSnapshot()

// ✅ Behavior + structure
expect(screen.getByRole('button')).toHaveTextContent('Click me')
expect(screen.getByRole('button')).toHaveClass('MuiButton-root')
```

## SSR/Framework-Specific Recommendations

### Next.js App Router

**Best**: Mantine, shadcn/ui, Headless UI, Radix UI
- No special config needed
- Server Components compatible
- Excellent hydration

**Good**: Chakra UI, MUI
- Require provider plugins
- Client Components needed

**Avoid**: Ant Design v4 (use v5 for better SSR)

### Remix

**Best**: All modern libraries work well
- Mantine has official support
- MUI works with minor config
- Headless/Radix work out-of-box

### Vite

**Best**: All libraries (Vite's tree-shaking is excellent)
- shadcn/ui (designed for Vite)
- Mantine (official Vite support)
- Headless UI (minimal config)

## TypeScript-First Projects

**All libraries** have excellent TypeScript support in 2025.

**Special mentions:**
- **Mantine**: Best generic component types (Table, Select, etc.)
- **MUI**: Best polymorphic component typing
- **Chakra**: Best style prop type inference
- **Radix**: Best primitive type exports for wrapping

## Accessibility-Critical Applications

**Tier 1**: Radix UI, Headless UI, shadcn/ui
- Accessibility-first design
- 100% WAI-ARIA compliant
- Built by a11y experts

**Tier 2**: Chakra UI, Mantine
- Strong accessibility
- Minor gaps in edge cases
- 95%+ compliant

**Tier 3**: MUI, Ant Design
- Good for common patterns
- Enterprise accessibility decent
- Some complex widgets have gaps
- 80-85% compliant

## Final Recommendations by Use Case

### New Project, Modern Stack

**Default**: shadcn/ui (if using Tailwind) or Mantine (if not)

**Why**: Best DX, modern architecture, zero technical debt

### Enterprise Dashboard

**Default**: Ant Design (data-heavy) or MUI (Material Design)

**Why**: Best data tables, proven at scale, commercial support

### Custom Design System

**Default**: Radix UI

**Why**: Accessibility-first primitives, full styling control, wrap like shadcn/ui

### Tailwind Project

**Default**: shadcn/ui

**Why**: Purpose-built for Tailwind, code ownership, excellent integration

### Vue Project

**Only option**: Headless UI

**Why**: Only modern headless library with Vue support

### Maximum Performance

**Default**: Headless UI or Radix UI

**Why**: Smallest bundles, zero runtime overhead, static CSS

### Rapid Prototyping

**Default**: Chakra UI or Mantine

**Why**: Intuitive APIs, comprehensive features, fast setup

## Anti-Recommendations

### When NOT to Choose Each Library

**❌ shadcn/ui**: Not using Tailwind, need automatic updates, team unfamiliar with Radix patterns

**❌ MUI**: Custom design system required (not Material), bundle size critical (`<50` KB)

**❌ Ant Design**: Consumer-facing app (enterprise aesthetic), bundle size critical

**❌ Chakra UI**: Need zero runtime cost, using Tailwind (different paradigm), need advanced data components

**❌ Mantine**: Using Tailwind (incompatible), need paid support, need advanced data grid

**❌ Radix UI**: Need pre-styled components (use shadcn/ui instead), rapid prototyping, team new to React

**❌ Headless UI**: Need comprehensive component set (14 components not enough), not using Tailwind (suboptimal DX)

## The 2025 Meta

**Trends:**
1. **Headless libraries rising**: Radix/Headless UI gaining market share
2. **CSS-in-JS declining**: Mantine v7 migration signals shift
3. **Tailwind dominance**: shadcn/ui proves copy-paste model works
4. **Accessibility standard**: All modern libraries must be WAI-ARIA compliant

**Prediction**: By 2026, most new projects will use either:
- shadcn/ui (Tailwind users)
- Mantine (non-Tailwind users)
- Enterprise libraries (MUI/Ant for data apps)

**The "safe bet" for 2025**: Mantine (comprehensive, modern, free, CSS Modules)


---

# shadcn/ui - Technical Analysis

## Architecture Overview

### Fundamental Design: Copy-Paste Model

shadcn/ui is NOT a traditional npm package - it's a **code generation system**:

```bash
npx shadcn-ui@latest add button
# Copies button.tsx into YOUR codebase at components/ui/button.tsx
```

**Implications:**
- Zero runtime dependency after copying
- Full code ownership and modification rights
- Updates require manual re-copying and merging
- No version management via npm semver

### Component Foundation: Radix UI

Every shadcn/ui component is built on Radix UI primitives:

```tsx
// shadcn/ui Dialog wraps Radix Dialog
import * as DialogPrimitive from "@radix-ui/react-dialog"

const Dialog = DialogPrimitive.Root
const DialogTrigger = DialogPrimitive.Trigger
// + Tailwind styling layer
```

**Architecture stack:**
1. **Base**: Radix UI (accessibility + behavior)
2. **Styling**: Tailwind CSS (utility classes)
3. **Variants**: class-variance-authority (CVA) for prop-based styling
4. **Utilities**: clsx + tailwind-merge for className composition

## Styling Architecture

### Class Variance Authority (CVA)

Enables prop-based variants while using Tailwind:

```tsx
const buttonVariants = cva(
  "inline-flex items-center justify-center rounded-md",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground",
        destructive: "bg-destructive text-destructive-foreground",
        outline: "border border-input bg-background",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
      },
    },
  }
)
```

**Benefits:**
- Type-safe variant props
- Tailwind IntelliSense support
- No runtime CSS-in-JS cost
- Compile-time optimizations

### CSS Variable Theming

Uses CSS custom properties for color system:

```css
:root {
  --background: 0 0% 100%;
  --foreground: 222.2 84% 4.9%;
  --primary: 222.2 47.4% 11.2%;
}

.dark {
  --background: 222.2 84% 4.9%;
  --foreground: 210 40% 98%;
}
```

**Advantages:**
- Native CSS performance
- Automatic dark mode via class toggle
- No JavaScript theme provider needed
- Works with Tailwind's theme system

## Performance Characteristics

### Bundle Size Impact

**Base overhead**: ~0 KB
- No library to bundle (code is copied)
- Only Radix dependencies are bundled
- Typical Radix primitive: 5-15 KB gzipped

**Example button component:**
```
Button.tsx:        2.3 KB (uncompressed)
+ Radix Slot:      1.8 KB (gzipped)
+ CVA:             0.6 KB (gzipped)
Total:            ~4.7 KB
```

### Tree-Shaking

Perfect tree-shaking since components are separate files:
- Import only what you copy
- No monolithic library to shake
- Dead code elimination at build time

### Runtime Performance

**No runtime overhead** from styling:
- Tailwind classes are static strings
- CVA evaluated once per render
- No CSS-in-JS recalculation
- No theme context lookups

**React performance:**
- Same as Radix (compound components)
- Minimal re-renders with proper memoization
- No library-specific optimizations needed

## TypeScript Integration

### Type Safety

Generated components are **TypeScript-first**:

```tsx
interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}
```

**Strengths:**
- Full IntelliSense support
- Variant props are type-checked
- Native HTML prop types preserved
- `asChild` pattern for composition

### Type Inference

CVA provides automatic type inference:

```tsx
// size prop is: "default" | "sm" | "lg"
// variant prop is: "default" | "destructive" | "outline"
<Button size="sm" variant="destructive" />
```

## Composition Patterns

### asChild Pattern (Radix Slot)

Render component as a different element:

```tsx
// Renders as <Link> with Button styles
<Button asChild>
  <Link href="/dashboard">Dashboard</Link>
</Button>
```

**Implementation:**
```tsx
const Comp = asChild ? Slot : "button"
return <Comp {...props} />
```

**Use case**: Avoid nested buttons, integrate with routing

### Compound Components

Following Radix patterns:

```tsx
<Dialog>
  <DialogTrigger>Open</DialogTrigger>
  <DialogContent>
    <DialogHeader>
      <DialogTitle>Title</DialogTitle>
      <DialogDescription>Description</DialogDescription>
    </DialogHeader>
    {children}
    <DialogFooter>Actions</DialogFooter>
  </DialogContent>
</Dialog>
```

## Accessibility Implementation

### Inherited from Radix

All accessibility comes from Radix UI:
- **WAI-ARIA compliant** by default
- Keyboard navigation built-in
- Focus management automatic
- Screen reader labels included

shadcn/ui adds **visual accessibility**:
- Focus rings via Tailwind's `focus-visible`
- Color contrast in theme variables
- Disabled state styling

## Customization Mechanisms

### Direct Code Modification

Since you own the code, customization is straightforward:

1. **Edit the component file directly**
2. **Modify CVA variants**
3. **Add new props**
4. **Change Tailwind classes**

**Example customization:**
```tsx
// Add a new "ghost" variant
const buttonVariants = cva(
  "...",
  {
    variants: {
      variant: {
        // ... existing variants
        ghost: "hover:bg-accent hover:text-accent-foreground",
      },
    },
  }
)
```

### Theme Customization

Modify CSS variables in `globals.css`:

```css
:root {
  --radius: 0.5rem; /* Change border radius globally */
  --primary: 210 100% 50%; /* Change primary color */
}
```

## Build System Integration

### Next.js (Optimal)

shadcn/ui is designed for Next.js:
- Server Components support
- Automatic tree-shaking
- Tailwind JIT compilation

### Vite

Works well with Vite:
- Fast HMR
- Optimized bundling
- Path aliases for `@/components`

### Create React App

Requires ejecting or Craco for path aliases:
```json
// tsconfig.json paths
{
  "paths": {
    "@/*": ["./src/*"]
  }
}
```

## Testing Considerations

### Unit Testing

Test as regular React components:

```tsx
import { render, screen } from '@testing-library/react'
import { Button } from './button'

test('renders button', () => {
  render(<Button>Click me</Button>)
  expect(screen.getByRole('button')).toHaveTextContent('Click me')
})
```

**No library-specific mocking needed** - it's your code.

### Snapshot Testing

**Stable snapshots** since:
- No generated classNames (like CSS-in-JS)
- Tailwind classes are deterministic
- No library version changes (code is copied)

## Upgrade Path

### Manual Update Process

1. **Check changelog** for component updates
2. **Run `npx shadcn-ui@latest diff button`** (if available)
3. **Manually merge changes** into your component
4. **Test thoroughly**

**Trade-off:**
- ❌ No automatic upgrades via npm update
- ✅ No breaking changes from npm updates
- ✅ Control over when/how to adopt changes

## Maintenance & Community

### Development Model

- **Open source**: MIT licensed
- **Creator**: Maintained by shadcn (Vercel)
- **Community**: Large contributor base
- **Components**: 40+ official components (2025)

### Documentation

- Excellent examples
- Copy-paste code snippets
- Integration guides for Next.js, Vite, Remix
- Theme customization examples

## Limitations & Constraints

### Not a Traditional Library

**Cannot:**
- `npm update` to get bug fixes
- Use semantic versioning
- Track components across projects easily

**Must:**
- Manually track upstream changes
- Maintain your own copies
- Handle merge conflicts on updates

### Tailwind Dependency

**Requires Tailwind CSS** - no alternative styling:
- Cannot use with other CSS frameworks
- Must configure Tailwind
- Need to understand utility-first CSS

### No Component Composition Utilities

Unlike Mantine/Chakra, no built-in:
- Stack/Group layout components
- Responsive prop shortcuts
- Global style props system

## When to Choose shadcn/ui (Technical POV)

### Ideal Technical Conditions

✅ **Use when:**
- Already using Tailwind CSS
- Want to modify component internals
- Building with Next.js or Vite
- Team comfortable with React + TypeScript
- Need excellent tree-shaking

❌ **Avoid when:**
- Not using Tailwind (no alternative)
- Need automatic security updates
- Want comprehensive component sets (only 40+ components)
- Team unfamiliar with compound component patterns

## Technical Debt Considerations

### Low Long-Term Debt

- No library version upgrades to manage
- No deprecation warnings from upstream
- No breaking changes unless you adopt them

### Medium Maintenance Burden

- Must manually track security issues in Radix
- Updates require code review and merging
- No automated refactoring tools

## Conclusion

shadcn/ui is technically **not a component library** but a **component generation system**. Its architecture prioritizes:

1. **Code ownership** over convenience
2. **Zero runtime overhead** over feature richness
3. **Explicit control** over automatic updates
4. **Tailwind integration** over styling flexibility

This makes it excellent for teams that want full control and are willing to handle manual updates, but challenging for teams expecting traditional npm dependency management.

</details><details>
<summary>S3: Need-Driven</summary>

# S3-Need-Driven: Use Case & Persona Analysis

## Objective

Identify **WHO needs UI component libraries** and **WHY** they need them, focusing on real-world user personas and their pain points. This pass examines use cases, not implementations.

## Analysis Framework

### 1. Persona Identification
- **Role**: Developer role, team size, company context
- **Pain points**: What problems do they face?
- **Goals**: What are they trying to achieve?
- **Constraints**: Time, budget, team skills, requirements

### 2. Decision Factors
- **Technical context**: Existing stack, team skills
- **Business context**: Timeline, budget, maintenance capacity
- **Project type**: Consumer app, enterprise dashboard, design system
- **Requirements**: Accessibility, performance, customization

### 3. Success Criteria
- **Time to market**: How quickly can they ship?
- **Maintenance burden**: Ongoing cost of ownership
- **User experience**: Quality of final product
- **Team velocity**: Developer productivity

## Personas Covered

Each use case file examines a specific persona:

1. **Startup founder** - Ship MVP fast with limited resources
2. **Enterprise frontend team** - Build data-heavy admin panels
3. **Design system team** - Create custom component library for organization
4. **Solo freelancer** - Build custom client sites quickly
5. **Open-source maintainer** - Build accessible tools for community

## What S3 Does NOT Cover

- Implementation details (HOW to use libraries)
- Code examples (save for documentation)
- Technical architecture (covered in S2)
- Long-term strategic decisions (covered in S4)

## Deliverables

- `use-case-<persona>.md` for each persona (5 files)
- `recommendation.md` mapping personas to libraries


---

# S3 Persona-Based Recommendations

## Quick Reference Matrix

| Persona | Best Choice | Alternative | Avoid |
|---------|-------------|-------------|-------|
| **Startup MVP** | shadcn/ui | Mantine | Radix UI, Ant Design |
| **Enterprise Dashboard** | Ant Design | MUI X | shadcn/ui, Chakra UI |
| **Design System** | Radix UI | Headless UI | MUI, Ant Design |
| **Freelance Developer** | shadcn/ui | Mantine | Ant Design, Radix UI |
| **Open-Source Tool** | Headless UI | Radix UI | MUI, Ant Design |

## Decision Tree by Context

### By Team Size

**Solo / 1-3 people**:
- Default: shadcn/ui (Tailwind) or Mantine (others)
- Why: Fast setup, comprehensive, minimal decisions

**Small team / 5-15 people**:
- Default: Chakra UI or Mantine
- Why: Easy to learn, consistent DX

**Enterprise team / 20+ people**:
- Default: Ant Design (data-heavy) or MUI (Material Design)
- Why: Proven at scale, vendor stability

**Design systems team**:
- Default: Radix UI
- Why: Building foundation, need full control

### By Project Type

**Consumer SaaS / Web App**:
- shadcn/ui (modern aesthetic)
- Chakra UI (easy customization)
- Mantine (comprehensive features)

**Enterprise / B2B Dashboard**:
- Ant Design (best data table)
- MUI X (if budget for Premium)
- Mantine (free alternative)

**Marketing Site / Portfolio**:
- shadcn/ui (beautiful defaults)
- Headless UI + custom (if unique design)

**CLI Tool / Electron App**:
- Headless UI (smallest bundle)
- Radix UI (modular, small)

**Internal Design System**:
- Radix UI (accessibility primitives)
- Headless UI (simpler, Tailwind-friendly)

### By Timeline

**< 2 weeks** (prototype):
- shadcn/ui or Mantine (fastest)
- Chakra UI (if team knows it)

**1-3 months** (MVP):
- shadcn/ui, Mantine, or Chakra
- Ant Design (if enterprise features needed)

**6+ months** (design system):
- Radix UI (build proper foundation)
- Headless UI (if Tailwind + simpler needs)

### By Budget

**$0 budget**:
- ✅ shadcn/ui, Mantine, Chakra UI, Radix UI, Headless UI
- ❌ MUI X Premium ($1660/dev)

**< $1000 budget**:
- MUI X Pro ($495/dev) viable
- Otherwise use free options

**Enterprise budget**:
- MUI X Premium ($1660/dev) for best data grid
- Ant Design Pro Components (varies)
- Commercial support contracts available

### By Technical Constraints

**Bundle size < 50 KB**:
- Headless UI (~12 KB)
- Radix UI (~15-25 KB)
- shadcn/ui (~20-30 KB)

**Bundle size < 100 KB**:
- Mantine (~40-60 KB)
- Chakra UI (~45 KB)

**No bundle constraint**:
- MUI (~70-150 KB)
- Ant Design (~100-200 KB)

**Styling approach**:
- **Tailwind**: shadcn/ui or Headless UI
- **CSS Modules**: Mantine
- **CSS-in-JS**: Chakra UI or MUI
- **Custom CSS**: Radix UI or Headless UI

## Persona Deep-Dives

### Startup Founder (Sarah)

**Primary need**: Ship investor-ready MVP in 6 weeks

**Recommendation: shadcn/ui**

**Why**:
- Beautiful defaults (investor-ready without design work)
- Fast setup (productive day 1)
- Owns code (easy to pivot/customize)
- Modern aesthetic (2025 standards)

**Timeline value**:
- Week 1: Core UI built
- Week 3: Product features working
- Week 6: Launched

**Alternative: Mantine** (if not using Tailwind)

**Objection handling**:
- "Too opinionated?" → You'll pivot post-PMF anyway
- "Bundle size?" → 20 KB acceptable for MVP
- "Manual updates?" → Startups customize anyway

### Enterprise Engineer (Michael)

**Primary need**: Robust data tables, complex forms

**Recommendation: Ant Design**

**Why**:
- Best-in-class Table component
- Powerful form system (rc-field-form)
- Alibaba-backed stability
- 60+ enterprise components

**ROI calculation**:
- Building custom table: 3-6 months
- Ant Design: 2-3 weeks
- Savings: $200K-$400K in eng time

**Alternative: MUI X** (if budget for Premium)

**Objection handling**:
- "Bundle size?" → Enterprise WiFi fast enough
- "Aesthetic?" → Enterprise customers don't care
- "Customization?" → Token system allows theming

### Design System Engineer (Jessica)

**Primary need**: Build internal component library

**Recommendation: Radix UI**

**Why**:
- Full styling control (match Figma pixel-perfect)
- Best accessibility (WAI-ARIA experts)
- Compound components (fine-grained control)
- WorkOS-backed stability

**Pattern**:
1. Wrap Radix primitives
2. Add company styling
3. Publish to internal npm
4. Teams consume via npm install

**Alternative: Headless UI** (if using Tailwind, fewer components needed)

**Objection handling**:
- "Too much work?" → 6 months for 5-year system (worth it)
- "Why not theme MUI?" → Want design system, not "MUI with our colors"
- "Maintenance burden?" → Radix handles hard parts (a11y, behavior)

### Freelance Developer (David)

**Primary need**: Ship client projects fast, maximize profit

**Recommendation: shadcn/ui**

**Why**:
- Professional appearance (portfolio-worthy)
- Fast customization (client branding in 10 min)
- Reusable across projects
- Code ownership (tweak anything)

**Business value**:
- Time saved: 1-2 weeks per project
- Money saved: $2K-$4K per project
- Quality: More professional than custom
- Clients: Happier (modern UI)

**Alternative: Mantine** (if not using Tailwind)

**Objection handling**:
- "All projects look same?" → Change colors/fonts/spacing
- "Client wants custom?" → You own code, edit freely
- "Licensing?" → MIT (free for commercial)

### Open-Source Maintainer (Alex)

**Primary need**: Small bundle, excellent accessibility

**Recommendation: Headless UI**

**Why**:
- Smallest bundle (~12 KB)
- Excellent accessibility (Tailwind Labs quality)
- Free (MIT)
- Contributors know it (lower barrier)

**Success metrics**:
- Bundle: < 20 KB (Lighthouse 95+)
- Accessibility: Zero GitHub issues
- Contributors: Familiar patterns

**Alternative: Radix UI** (if need more components)

**Objection handling**:
- "Dependencies risky?" → Tailwind Labs-backed
- "Only 14 components?" → Usually enough for dev tools
- "Contributors complain?" → Devs respect Headless UI

## Common Scenarios

### "I'm using Tailwind CSS"

**→ shadcn/ui** (first choice)
- Purpose-built for Tailwind
- Beautiful defaults
- Code ownership

**→ Headless UI** (minimal approach)
- Smaller bundle
- Vue support (if needed)
- Simpler API

### "I need advanced data tables"

**→ Ant Design** (best free option)
- Industry-leading Table component
- Virtual scrolling, filtering, sorting, grouping
- Free

**→ MUI X Data Grid Premium** (if budget)
- $1660/dev but excellent
- Commercial support

**→ Mantine + TanStack Table** (build it)
- Free but requires integration
- More control

### "I'm building a design system"

**→ Radix UI** (for React)
- Most comprehensive primitives (25+)
- Best accessibility
- Battle-tested

**→ Headless UI** (for Vue or simpler needs)
- Vue support (unique)
- Simpler API
- 14 components

### "I need to ship tomorrow"

**→ shadcn/ui or Mantine**
- Fastest setup
- Copy-paste examples
- Beautiful defaults

**→ Chakra UI** (if team knows it)
- Prop-based styling (fast)

### "Bundle size is critical"

**→ Headless UI** (~12 KB)
**→ Radix UI** (~5-7 KB per primitive)
**→ shadcn/ui** (~20 KB)

Avoid: MUI (70+ KB), Ant Design (100+ KB)

### "I have zero budget"

All libraries are free except:
- ❌ MUI X Premium ($1660/dev)
- ❌ Ant Design Pro (varies, enterprise)

Use:
- ✅ Mantine (most comprehensive free)
- ✅ Chakra UI
- ✅ shadcn/ui
- ✅ Radix UI
- ✅ Headless UI

## Anti-Patterns

### Don't Choose Libraries By:

**❌ GitHub stars alone**
- MUI has most stars but not best for all use cases
- Match library to your context

**❌ "Everyone uses X"**
- shadcn/ui popular NOW but Radix better for design systems
- Ant Design popular in China, MUI in West (both good)

**❌ Avoiding dependencies**
- "Not invented here" syndrome
- Building custom components = weeks of work

**❌ Bundle size obsession (when not critical)**
- Startups: 50 KB library OK if ships 2 weeks faster
- Enterprise: 200 KB OK on fast WiFi

### Do Choose Libraries By:

**✅ Project context** (MVP vs enterprise vs design system)
**✅ Team skills** (Tailwind? CSS-in-JS?)
**✅ Actual requirements** (data tables? forms?)
**✅ Timeline** (weeks vs months)
**✅ Budget** (free vs can pay)

## Decision Flowchart

```
What are you building?
│
├─ MVP / Startup
│  ├─ Using Tailwind? → shadcn/ui
│  └─ Not using Tailwind? → Mantine
│
├─ Enterprise Dashboard
│  ├─ Data-heavy? → Ant Design
│  ├─ Material Design? → MUI
│  └─ Modern DX? → Mantine
│
├─ Design System
│  ├─ React-only? → Radix UI
│  └─ Need Vue? → Headless UI
│
├─ Client Projects (Freelance)
│  ├─ Using Tailwind? → shadcn/ui
│  └─ Not using Tailwind? → Mantine
│
└─ Open Source Tool
   ├─ Bundle critical? → Headless UI
   └─ More components? → Radix UI
```

## The 2025 Safe Defaults

**If unsure**, these are safe bets:

**Consumer apps**: shadcn/ui or Mantine
**Enterprise apps**: Ant Design or MUI
**Design systems**: Radix UI
**Everything else**: shadcn/ui (Tailwind) or Mantine (others)

**Rationale**: Most common needs covered, proven at scale, active maintenance.


---

# Use Case: Building Company Design System

## Who Needs This

**Persona**: Jessica, Design Systems Engineer at Growing Tech Company

**Context**:
- Company has 20-50 engineers across 3-5 product teams
- Multiple products need consistent UI (web app, admin, marketing site)
- Design team created brand guidelines and design system in Figma
- Need to implement design system as React component library
- 6-12 month timeline to build + adopt across teams

**Technical background**:
- Strong React and CSS expertise
- Team comfortable with advanced patterns
- Accessibility is priority (WCAG AA minimum)
- Will maintain design system long-term (2-5+ years)

## Why They Need UI Component Libraries

### Pain Points

**1. Design-to-Code Gap**
- Designers create beautiful Figma components
- Engineers re-implement in React (inconsistently)
- Each product team builds own version
- "Same button" looks different across products

**2. Consistency at Scale**
- 5 products × 10 engineers = 50 different interpretations
- No single source of truth
- Brand guidelines PDF ignored
- QA finds inconsistencies too late

**3. Accessibility Complexity**
- Modal focus trapping is hard
- Keyboard navigation requires expertise
- ARIA attributes easy to get wrong
- Screen reader testing time-consuming

**4. Maintenance Burden**
- Each team maintains own components
- Bug fixes don't propagate
- Security issues duplicated
- Refactors require coordinating across teams

### Goals

**Primary**: Create internal component library that all teams use

**Secondary**:
- Match design system from Figma pixel-perfect
- Ensure accessibility compliance
- Enable teams to ship faster
- Reduce design-to-code inconsistencies

### Requirements

**Must-haves**:
- Full control over styling (match brand exactly)
- Accessible by default (WAI-ARIA compliant)
- Customizable (designers will iterate)
- Maintainable (5+ year lifecycle)
- Documentation for engineers

**Nice-to-haves**:
- Storybook integration
- Design tokens
- Dark mode support
- Animation/transitions

**Don't need**:
- Pre-built visual designs (have Figma)
- Specific design language (not Material/Enterprise)
- Rapid prototyping (building for years)

## Decision Criteria

### 1. Styling Control
**Critical**: Must match brand pixel-perfect

**What this means**:
- ✅ 100% control over CSS
- ✅ Can implement custom design tokens
- ✅ No library opinions on visual design
- ❌ Pre-styled libraries lock into aesthetics

### 2. Accessibility Foundation
**Critical**: Don't want to build from scratch

**What this means**:
- ✅ WAI-ARIA compliant primitives
- ✅ Keyboard navigation built-in
- ✅ Focus management automatic
- ❌ Can't afford to mess up accessibility

### 3. Composability
**Important**: Need to build custom patterns

**What this means**:
- ✅ Compound components (fine-grained control)
- ✅ Headless/unstyled (add own styles)
- ✅ Extensible APIs
- ❌ Black-box components won't work

### 4. Long-Term Stability
**Important**: 5+ year maintenance

**What this means**:
- ✅ Stable API (minimal breaking changes)
- ✅ Company or strong community backing
- ✅ Security updates
- ❌ Hobby projects risky

### 5. Developer Experience
**Moderate**: Internal teams will use this

**What this means**:
- ✅ Good TypeScript support
- ✅ Clear documentation
- ✅ Familiar patterns
- ⚠️ Learning curve acceptable (one-time cost)

## Why Existing Solutions Fall Short

**Pre-styled libraries (MUI, Ant Design)**:
- ❌ Material/Enterprise aesthetic baked in
- ❌ Hard to override completely
- ❌ Teams recognize "this is MUI"
- ❌ Not a unique design system

**shadcn/ui (copy-paste)**:
- ⚠️ Good for small teams
- ❌ Doesn't scale to 50 engineers (no npm updates)
- ❌ Each team copies different versions
- ❌ Bug fixes don't propagate

**Building 100% from scratch**:
- ❌ 12-18 months engineering time
- ❌ Accessibility bugs will happen
- ❌ Reinventing solved problems (focus traps, etc.)
- ❌ ROI negative vs using primitives

## Success Metrics

**Month 3**: First component library version (alpha)
**Month 6**: All teams migrated to design system
**Month 12**: Zero design inconsistencies found in QA
**Year 2+**: System evolves without breaking teams

**Longer term**:
- Design-to-code gap eliminated
- Teams ship 30% faster (no reimplementing)
- Accessibility audits pass
- Single update fixes bugs across all products

## Library Recommendations for This Persona

### Best Fit: Radix UI

**Why it works**:
- ✅ **Headless primitives** = full styling control
- ✅ **Best accessibility** (built by a11y experts)
- ✅ **25+ components** (covers common needs)
- ✅ **Compound patterns** (fine-grained control)
- ✅ **Stable API** (WorkOS-backed)
- ✅ **Battle-tested** (powers shadcn/ui, thousands of companies)

**How to use**:
1. Install Radix primitives (@radix-ui/react-*)
2. Wrap with custom styling matching Figma
3. Publish as internal npm package
4. Teams import from company design system

**Example**:
```tsx
// @company/design-system/Button.tsx
import * as RadixButton from '@radix-ui/react-button'
import { cva } from 'class-variance-authority'

const buttonStyles = cva('...company-specific-styles...', {
  variants: { ... }
})

export const Button = ({ children, ...props }) => (
  <RadixButton.Root className={buttonStyles(props)}>
    {children}
  </RadixButton.Root>
)
```

**Why it might not**:
- ⚠️ Requires CSS expertise (but you have designers)
- ⚠️ More setup time (6 months acceptable for multi-year use)

### Alternative: Headless UI

**Why it works**:
- ✅ Minimal, headless components
- ✅ Excellent accessibility
- ✅ Tailwind Labs-backed (stable)
- ✅ Simpler API than Radix

**Why it might not**:
- ❌ Only 14 components (vs Radix 25+)
- ❌ Less comprehensive (no tooltips, sliders, etc.)
- ❌ Smaller ecosystem

**Best for**: Teams using Tailwind, need fewer components

### Consider: Building on shadcn/ui Pattern

**Why**:
- ✅ Use Radix + Tailwind foundation
- ✅ Customize to match brand
- ✅ Publish as internal package

**Approach**:
1. Fork shadcn/ui components
2. Customize with company design tokens
3. Publish to internal npm registry
4. Teams install via npm (not copy-paste)

### Avoid: MUI, Ant Design, Chakra

**Why**:
- ❌ Pre-styled = not a custom design system
- ❌ Teams will say "this looks like MUI"
- ❌ Deep customization fights library opinions
- ❌ Not building design system, just theming one

## Real-World Example

**Scenario**: Building "Acme Design System" for company products

**What Jessica needs**:
- Custom button (brand colors, fonts, hover states)
- Modal (brand animations, layout)
- Dropdown (custom arrow, transitions)
- Form inputs (brand focus states)
- Navigation (unique design)

**With Radix UI** (6 months):
- Month 1: Setup Radix, design token system
- Month 2-3: Wrap 15-20 core components
- Month 4: Documentation, Storybook
- Month 5-6: Team adoption, feedback, iteration
- **Result**: Custom design system matching Figma

**With MUI customization** (6 months):
- Month 1-2: Deep theme customization
- Month 3: Fighting MUI defaults
- Month 4: Realizing some things can't be changed
- Month 5: Designers unhappy with compromises
- Month 6: Considering rebuild
- **Result**: Looks like "customized MUI", not unique system

**With 100% scratch** (12-18 months):
- Month 1-3: Build button, input, modal
- Month 4-6: Add accessibility
- Month 7-9: Debug focus traps, keyboard nav
- Month 10-12: Add advanced components
- Month 13-18: Fix bugs, edge cases
- **Result**: Working but lots of maintenance debt

**Radix wins**: Custom look, accessibility built-in, maintainable

## Persona Objections & Responses

**"Why not just use shadcn/ui?"**
- shadcn/ui is copy-paste (teams get different versions)
- You need npm package for consistency
- Solution: Build internal package using Radix (like shadcn does)

**"Can't we just theme MUI deeply?"**
- Possible but fights library at every step
- Still looks like "Material Design derivative"
- Design system should feel unique, not themed

**"Isn't building on primitives too much work?"**
- Upfront: Yes (6 months vs 2 months for theming)
- Long-term: No (full control, no fighting library)
- ROI positive over 5 years

**"What about maintenance burden?"**
- Radix handles hard parts (accessibility, behavior)
- You maintain styling only (which you'd do anyway)
- Stable API means fewer breaking changes

## Bottom Line

**Design system teams should use headless primitives**:

**Best choice**: Radix UI (most comprehensive, best accessibility)
**Tailwind teams**: Headless UI or Radix + Tailwind
**Vue support needed**: Headless UI (only option)

**Pattern**:
1. Radix/Headless UI (behavior + a11y)
2. Custom styling (Tailwind, CSS Modules, CSS-in-JS)
3. Internal npm package
4. Storybook docs
5. Teams consume via npm

**Don't theme pre-styled libraries**: You want a design system, not "MUI with our colors".

**Don't build 100% from scratch**: Use primitives for accessibility/behavior, custom style everything else.


---

# Use Case: Enterprise Dashboard Development

## Who Needs This

**Persona**: Michael, Senior Frontend Engineer at Enterprise Software Company

**Context**:
- Team of 6-10 frontend engineers
- Building internal admin dashboard or B2B SaaS product
- Data-heavy application (thousands of records, complex filtering)
- Enterprise customers expect robust features
- 3-6 month timeline per major feature

**Technical background**:
- Team has React expertise (3+ years)
- TypeScript required (company standard)
- Performance and security are critical
- Accessibility compliance mandated (Section 508/WCAG AA)

## Why They Need UI Component Libraries

### Pain Points

**1. Complex Data Requirements**
- Need advanced tables (sorting, filtering, pagination, virtual scrolling)
- Complex forms with validation, conditional fields
- Date range selection for reports
- Multi-select, autocomplete, nested dropdowns

**2. Enterprise Quality Bar**
- Customers pay $50K-$500K annually
- Bugs in UI = support tickets = costly
- Accessibility lawsuits are real
- Security audits examine dependencies

**3. Team Coordination**
- Multiple engineers work on same product
- Need consistent component patterns
- Code reviews easier with standard library
- New hires ramp up faster with familiar tools

**4. Long-Term Maintenance**
- Product has 5-10 year lifecycle
- Need security updates and bug fixes
- Can't rebuild components every 2 years
- Vendor stability matters

### Goals

**Primary**: Build robust, maintainable data-heavy applications

**Secondary**:
- Reduce support tickets from UI bugs
- Pass accessibility/security audits
- Enable team velocity with shared components
- Minimize technical debt

### Requirements

**Must-haves**:
- Advanced data tables (sorting, filtering, grouping, virtual scroll)
- Complex form handling (validation, async validation, dependencies)
- Date/time components (pickers, ranges)
- Excellent TypeScript support
- WCAG AA compliance
- Vendor stability (not a hobby project)

**Nice-to-haves**:
- Charts and data visualization
- Export to CSV/Excel
- Commercial support option
- Long-term support (LTS)

**Don't need**:
- Cutting-edge design (enterprise aesthetics acceptable)
- Minimal bundle size (fast WiFi in offices)
- Custom brand differentiation (B2B customers don't care)

## Decision Criteria

### 1. Data Table Capabilities
**Critical**: 80% of app is tables

**What this means**:
- ✅ Handles 10K+ rows with virtual scrolling
- ✅ Fixed columns/headers
- ✅ Sorting, filtering, grouping out-of-box
- ✅ Cell editing, row selection
- ❌ Basic table won't cut it

### 2. Form Complexity
**Critical**: Enterprise forms have 50+ fields

**What this means**:
- ✅ Field-level validation
- ✅ Async validation (API checks)
- ✅ Conditional fields
- ✅ Nested objects/arrays
- ❌ Simple form libraries insufficient

### 3. Vendor Stability
**Critical**: Can't have library abandoned

**What this means**:
- ✅ Company-backed or strong funding
- ✅ 5+ years track record
- ✅ Regular security updates
- ❌ Solo maintainer projects risky

### 4. Accessibility Compliance
**Critical**: Legal requirement

**What this means**:
- ✅ WCAG AA compliant
- ✅ Keyboard navigation
- ✅ Screen reader tested
- ❌ Manual a11y work = lawsuits

### 5. TypeScript Quality
**Important**: Company standard

**What this means**:
- ✅ Full type coverage
- ✅ Generic components
- ✅ Type inference
- ❌ @ts-ignore flags = technical debt

## Why Existing Solutions Fall Short

**Building custom**:
- ❌ Data tables alone = 3-6 months engineering
- ❌ Accessibility compliance = 2-3 months
- ❌ Ongoing maintenance = 1-2 engineers full-time
- ❌ ROI negative vs buying/using library

**Consumer-focused libraries (shadcn/ui)**:
- ❌ Basic table (no virtual scroll, advanced filtering)
- ❌ Simple forms (enterprise needs complex validation)
- ❌ No commercial support

**Minimal libraries (Headless UI)**:
- ❌ Only 14 components (need 60+)
- ❌ No data table
- ❌ No date pickers
- ❌ Must build too much custom

## Success Metrics

**Quarter 1**: Core admin features shipped
**Quarter 2**: Zero critical UI bugs in production
**Quarter 3**: Pass accessibility audit
**Year 1**: New engineers productive within 2 weeks

**Longer term**:
- Support tickets down 30% (fewer UI issues)
- Accessibility lawsuits: 0
- Team velocity up (shared components)
- Technical debt manageable

## Library Recommendations for This Persona

### Best Fit: Ant Design

**Why it works**:
- ✅ **Best-in-class data table** (sorting, filtering, pagination, fixed columns, virtual scrolling)
- ✅ **Powerful form system** (rc-field-form handles complex validation)
- ✅ **Alibaba-backed** (stable funding, long-term support)
- ✅ **60+ enterprise components** (everything needed)
- ✅ **Pro Components** for common admin patterns
- ✅ Enterprise aesthetic (professional, not flashy)

**Why it might not**:
- ❌ Larger bundle (~600 KB full, ~100 KB typical usage)
- ❌ Strong visual identity (hard to customize for consumer apps)

### Alternative: MUI (Material-UI)

**Why it works**:
- ✅ **MUI X Data Grid** (commercial but excellent)
- ✅ **Company-backed** (MUI SAS, commercial support)
- ✅ **Material Design** (familiar to users)
- ✅ **Large ecosystem** (charts, date pickers, etc.)
- ✅ Commercial support available

**Why it might not**:
- ❌ Best features behind paywall (MUI X Pro/Premium: $495-$1660/dev)
- ❌ Material Design may not fit brand

### Consider: Mantine

**Why it works**:
- ✅ Comprehensive (120+ components)
- ✅ Good form handling (@mantine/form)
- ✅ Date components built-in
- ✅ **Free** (no paid tier)

**Why it might not**:
- ❌ No advanced data grid (use TanStack Table separately)
- ❌ Smaller community than Ant/MUI
- ❌ Less proven at enterprise scale

### Avoid: shadcn/ui, Chakra UI

**Why**:
- ❌ No advanced data tables
- ❌ Manual updates (shadcn/ui)
- ❌ Not designed for enterprise data apps

## Real-World Example

**Scenario**: Building CRM admin dashboard for sales team

**What Michael needs**:
- Contacts table (10K+ contacts, search, filter, export)
- Company records (hierarchical data, nested tables)
- Activity log (timeline, filtering by date range)
- Complex forms (50+ fields, validation rules)
- Reporting dashboards

**With Ant Design** (3 months):
- Week 1-2: Setup, theming, component library
- Week 3-6: Contacts table with advanced features (built-in)
- Week 7-10: Company records, nested tables
- Week 11-12: Complex forms with Pro Form patterns
- **Result**: Feature-complete in 3 months

**Without library** (6-9 months):
- Month 1-2: Build custom table component
- Month 2-3: Add sorting, filtering, pagination
- Month 3-4: Virtual scrolling for performance
- Month 4-5: Complex form validation system
- Month 5-6: Date pickers, autocomplete
- Month 6-9: Bug fixes, accessibility compliance
- **Result**: 2x-3x longer, ongoing maintenance burden

**Cost savings**: $200K-$400K in engineering time (2-3 engineers × 3-6 months)

## Persona Objections & Responses

**"What about bundle size?"**
- Enterprise context: Users on fast office WiFi/Ethernet
- 100-200 KB library is acceptable vs months of dev time
- Performance matters but not the bottleneck (API calls are)

**"What if we want custom design?"**
- Ant Design tokens allow theming
- Enterprise customers care about functionality > aesthetics
- B2B SaaS doesn't need unique design language

**"Commercial support is expensive"**
- MUI X: $495/dev = cheap vs engineer time
- Ant Design: Free, Alibaba-backed stability
- ROI positive if saves even 1 week per engineer

**"What about vendor lock-in?"**
- Switching cost high regardless (rebuild all components)
- Pick stable vendor (Ant/MUI) with 5-10 year track record
- Lock-in acceptable if vendor is trustworthy

## Bottom Line

**Enterprise teams should prioritize data table quality**:

**Best choice**: Ant Design (free, best table, proven at scale)
**Premium option**: MUI X (paid, excellent data grid, commercial support)
**Budget option**: Mantine + TanStack Table (free, requires more integration)

**Key insight**: The $1K-$5K cost of commercial libraries is **negligible** vs $200K-$500K in engineering time to build equivalent features.

**Don't build custom**: Unless you're Salesforce/Oracle with dedicated UI platform team, use a library.


---

# Use Case: Freelance Developer Building Client Sites

## Who Needs This

**Persona**: David, Freelance React Developer

**Context**:
- Building custom web applications for small business clients
- 3-5 projects per year
- $10K-$50K per project
- 4-8 week timelines per project
- Solo or with 1-2 collaborators

**Technical background**:
- Strong React skills (4+ years)
- Comfortable with Tailwind CSS
- Prefers TypeScript
- Builds landing pages, dashboards, small SaaS tools

## Why They Need UI Component Libraries

### Pain Points

**1. Time = Money**
- Billing hourly or fixed-price
- Every hour building buttons = lost income
- Clients don't pay extra for custom components
- Need to ship fast to take next project

**2. Client Expectations**
- Clients expect professional UX (they've seen Stripe, Notion, etc.)
- "Make it look modern" means 2025 standards
- Accessibility matters (client's users sue if broken)
- Mobile responsiveness required (50%+ mobile traffic)

**3. Maintenance Burden**
- Supporting 5-10 active client projects
- Can't maintain custom component library per project
- Bugs in one project don't help others
- Need consistent patterns across clients

**4. Project Variety**
- Each client wants different brand
- Can't use same design for everyone
- Need to customize quickly
- Balance speed + uniqueness

### Goals

**Primary**: Ship professional client projects in 4-8 weeks while maximizing profit

**Secondary**:
- Reuse patterns across projects
- Minimize post-launch support
- Build portfolio-worthy work
- Keep clients happy (referrals = 60% of business)

### Requirements

**Must-haves**:
- Fast setup (day 1 productive)
- Easy customization (client brand colors, fonts)
- Professional appearance (clients show to their customers)
- Mobile responsive
- Common components (forms, modals, tables)

**Nice-to-haves**:
- Dark mode toggle
- Animations/transitions
- Code ownership (can tweak anything)

**Don't need**:
- Enterprise features (small business clients)
- Advanced data grids
- Internationalization
- Commercial support

## Decision Criteria

### 1. Time to Ship
**Critical**: Faster = more profit

**What this means**:
- ✅ Day 1: Install and use
- ✅ Week 1: Core features styled
- ❌ Week 2+ learning = eating into margin

### 2. Customization Speed
**Critical**: Each client needs different brand

**What this means**:
- ✅ Change colors in 10 minutes
- ✅ Custom fonts via config
- ✅ Override styles easily
- ❌ Deep theming = lost time

### 3. Professional Appearance
**Important**: Portfolio matters

**What this means**:
- ✅ 2025 aesthetic (not Bootstrap 2015)
- ✅ Animations, transitions
- ✅ "Looks custom" not "template-y"
- ❌ Dated look = hard to get next client

### 4. Reusability
**Important**: Patterns across projects

**What this means**:
- ✅ Same library for all clients
- ✅ Copy component setups between projects
- ✅ Build up personal component library
- ❌ Different library per project = chaos

### 5. Zero Cost
**Moderate**: Clients won't pay for licenses

**What this means**:
- ✅ Free and open source
- ⚠️ Can expense one-time costs ($100-$500)
- ❌ Per-user licensing doesn't work

## Why Existing Solutions Fall Short

**WordPress + page builders**:
- ❌ Clients want custom React apps
- ❌ Not modern SaaS aesthetic
- ❌ Limited customization

**Building from scratch**:
- ❌ 2 weeks building components = $4K-$8K lost
- ❌ Clients won't pay for "basic buttons"
- ❌ Maintenance across projects

**Bootstrap/Foundation**:
- ❌ Dated appearance (2010s aesthetic)
- ❌ Not React-native
- ❌ Clients recognize templates

## Success Metrics

**Week 1**: Client brand applied, core pages built
**Week 4**: App functional, client review
**Week 6-8**: Launched, client happy
**Post-launch**: < 5 hours/month support

**Business metrics**:
- Hourly rate effectively $100-$150/hr (vs $60-$80 building from scratch)
- Clients give 5-star reviews
- Portfolio drives referrals
- Can take 5 projects/year vs 3

## Library Recommendations for This Persona

### Best Fit: shadcn/ui

**Why it works**:
- ✅ **Beautiful defaults** (2025 aesthetic)
- ✅ **Fast customization** (CSS variables for colors/fonts)
- ✅ **Code ownership** (copy into project, tweak freely)
- ✅ **Tailwind-based** (if David knows Tailwind)
- ✅ **Professional look** (clients impressed)
- ✅ **Free** (no licensing)

**Workflow**:
1. New client project: `npx create-next-app`
2. Add shadcn/ui components: `npx shadcn-ui init`
3. Customize colors: Edit CSS variables (10 min)
4. Build features: Copy-paste from previous projects

**Time saved**: 1-2 weeks per project = $2K-$4K

**Why it might not**:
- ❌ Requires Tailwind (learn if new)

### Alternative: Mantine

**Why it works**:
- ✅ **Comprehensive** (forms, dates, notifications)
- ✅ **Easy theming** (theme object with colors/fonts)
- ✅ **Professional look**
- ✅ **Free**
- ✅ **Great docs** (copy-paste examples)

**Why it might not**:
- ❌ Not Tailwind-compatible

### Consider: Chakra UI

**Why it works**:
- ✅ **Fast to customize** (style props)
- ✅ **Dark mode toggle** (clients love this)
- ✅ **Professional**

**Why it might not**:
- ⚠️ Prop-based styling = different from Tailwind

### Avoid: Ant Design

**Why**:
- ❌ Enterprise aesthetic (not modern SaaS)
- ❌ Clients recognize "admin panel" look
- ❌ Harder to customize brand

### Avoid: Radix UI, Headless UI

**Why**:
- ❌ Must style everything (3-5 days per project)
- ❌ Clients won't pay for styling time
- ❌ Better for design systems

## Real-World Example

**Scenario**: Client needs booking app for salon (8-week project, $30K budget)

**What David needs**:
- Landing page (hero, features, pricing)
- Booking form (date picker, time slots, service selection)
- Dashboard for salon owner (appointments, customers)
- Mobile responsive

**With shadcn/ui** (6 weeks):
- Week 1: Setup, brand colors, landing page
- Week 2-3: Booking form with date picker, validation
- Week 4-5: Dashboard with calendar, tables
- Week 6: Polish, mobile testing
- **Result**: Shipped on time, $30K revenue, client thrilled

**Without library** (10 weeks):
- Week 1-2: Build button, input, modal, form components
- Week 3: Date picker component
- Week 4-6: Booking form, validation
- Week 7-9: Dashboard components
- Week 10: Polish
- **Result**: 4 weeks over (lost $12K potential next project)

**Return on investment**:
- Time saved: 4 weeks × $3K/week = $12K
- Client satisfaction: Higher (professional UI)
- Portfolio: Better (modern aesthetic)

## Persona Objections & Responses

**"What if client wants very custom design?"**
- shadcn/ui: Edit the copied components directly (you own code)
- 90% of clients happy with modern defaults + their colors
- 10% super-custom: Use Radix primitives instead

**"What about licensing for client work?"**
- All recommended libraries: MIT (free for commercial)
- shadcn/ui: Not even a dependency (copied code)

**"What if I need to support multiple clients long-term?"**
- Using same library = consistent patterns
- Bug fixes: Copy solution to all affected projects
- Better than per-project custom code

**"Won't all my projects look the same?"**
- Change: Colors, fonts, spacing, border radius
- Result: Different brand feel
- Clients don't care if button internals similar

## Portfolio Building

**Using component libraries helps portfolio**:

**Before (custom build)**:
- Shows: "I can build buttons"
- Risk: Buggy interactions, poor accessibility
- Time: Spent on solved problems

**After (component library)**:
- Shows: "I built this app in 6 weeks"
- Quality: Professional, accessible
- Time: Spent on unique features

**Clients care about**:
1. Does it work? (Yes, libraries are tested)
2. Does it look good? (Yes, modern defaults)
3. Was it on time/budget? (Yes, faster development)

**Clients don't care about**:
- Did you build buttons from scratch? (No)

## Bottom Line

**Freelancers should almost always use component libraries**:

**Best choice**: shadcn/ui (Tailwind users) or Mantine (others)
**Time saved**: 1-2 weeks per project = $2K-$4K
**Quality**: More professional than custom builds
**Profitability**: Higher hourly effective rate

**Key insight**: Clients pay for **solved business problems**, not **custom button implementations**.

**Build custom** only when:
- Client specifically requests (and pays for it)
- Design is so unique that libraries don't help
- Building reusable library for own future projects

Otherwise: Use shadcn/ui or Mantine, ship fast, take more projects.


---

# Use Case: Open-Source Developer Building Community Tool

## Who Needs This

**Persona**: Alex, Open-Source Maintainer

**Context**:
- Building open-source dev tool (CLI dashboard, code editor, API explorer)
- Nights/weekends project (has day job)
- Want users and GitHub stars
- Contributors will help build features
- No budget ($0 for dependencies)

**Technical background**:
- Strong React/TypeScript skills
- Cares about bundle size (CLI tools, Electron apps)
- Accessibility matters (inclusive community)
- Time-constrained (10-15 hrs/week)

## Why They Need UI Component Libraries

### Pain Points

**1. Time Constraints**
- Only 10-15 hours per week
- Every hour counts
- Building components = not building unique features
- Users want features, not "better buttons"

**2. Accessibility Is Critical**
- Open-source = public scrutiny
- GitHub issues for accessibility bugs
- Want inclusive tool (screen readers, keyboard users)
- Can't afford to exclude users

**3. Bundle Size Matters**
- **CLI tools**: Ship as npm package (big bundles = slow install)
- **Electron apps**: Download size matters
- **Web dev tools**: Developers notice bloated bundles
- Performance = GitHub stars

**4. Contributor Experience**
- Contributors need familiar patterns
- Strange component APIs = PR friction
- Standard libraries = lower barrier to contribute
- Documentation matters (contributors read it)

### Goals

**Primary**: Ship useful tool, get users and stars

**Secondary**:
- Keep bundle small (< 100 KB ideal)
- Make contributing easy
- Ensure accessibility
- Avoid dependency bloat

### Requirements

**Must-haves**:
- Minimal bundle size
- Excellent accessibility (public project)
- Free (no paid dependencies)
- Good DX (contributors will use it)

**Nice-to-haves**:
- TypeScript support
- Dark mode (devs expect it)
- Familiar to contributors (lower PR barrier)

**Don't need**:
- Advanced data grids
- Enterprise features
- Commercial support
- Comprehensive component library

## Decision Criteria

### 1. Bundle Size
**Critical**: Performance = user satisfaction

**What this means**:
- ✅ < 20 KB ideal
- ⚠️ < 50 KB acceptable
- ❌ > 100 KB hurts adoption

### 2. Accessibility
**Critical**: Inclusive community

**What this means**:
- ✅ WAI-ARIA compliant
- ✅ Keyboard navigation
- ✅ Screen reader tested
- ❌ Manual a11y = GitHub issues

### 3. Zero Cost
**Critical**: No budget

**What this means**:
- ✅ MIT/Apache/BSD licensed
- ✅ No paid tiers
- ❌ Commercial dependencies blocked

### 4. Contributor Familiarity
**Important**: Lower barrier to contribute

**What this means**:
- ✅ Popular library (contributors know it)
- ✅ Standard patterns
- ✅ Good docs
- ❌ Custom/niche = higher friction

### 5. Maintenance
**Important**: Can't spend time on library issues

**What this means**:
- ✅ Active maintenance
- ✅ Security updates
- ✅ Stable API
- ❌ Abandoned projects risky

## Why Existing Solutions Fall Short

**Building from scratch**:
- ❌ 20-40 hours building components
- ❌ Accessibility bugs will happen
- ❌ Not building unique features
- ❌ Contributors must learn custom API

**Large libraries (MUI, Ant)**:
- ❌ 200-600 KB bundles
- ❌ Developers will roast in GitHub issues
- ❌ Overkill for simple tools

**Copy-paste (shadcn/ui)**:
- ⚠️ Manual updates (time-consuming)
- ⚠️ Contributors might update differently
- ⚠️ Security fixes don't auto-apply

## Success Metrics

**Month 1**: MVP shipped
**Month 3**: 100 GitHub stars
**Month 6**: First external contributor PR
**Year 1**: 1000+ stars, active community

**Quality metrics**:
- Lighthouse score: 95+ (performance matters)
- Zero accessibility issues reported
- Bundle size: < 50 KB
- Contributors: Low friction PRs

## Library Recommendations for This Persona

### Best Fit: Headless UI

**Why it works**:
- ✅ **Smallest bundle** (~12 KB total)
- ✅ **Excellent accessibility** (Tailwind Labs quality)
- ✅ **Zero cost** (MIT, no paid tier)
- ✅ **Familiar to devs** (popular in OSS community)
- ✅ **Minimal components** (14 = small dependency surface)
- ✅ **TypeScript-first**

**Perfect for**: Dev tools (CLI dashboards, code editors, API explorers)

**Why it might not**:
- ❌ Only 14 components (but usually enough)
- ⚠️ Requires Tailwind (learn if new)

### Alternative: Radix UI

**Why it works**:
- ✅ **Small bundles** (~5-7 KB per primitive)
- ✅ **Best accessibility** (industry-leading)
- ✅ **Free** (MIT)
- ✅ **Modular** (import only what you need)
- ✅ **25+ primitives** (more than Headless UI)

**Why it might not**:
- ⚠️ More components = slightly larger bundles
- ⚠️ Compound API = learning curve

### Consider: Mantine

**Why it works**:
- ✅ **Free** (no paid tier)
- ✅ **Comprehensive** (don't need multiple libraries)
- ✅ **CSS Modules** (v7 = zero runtime)
- ✅ **Great docs** (contributors can learn)

**Why it might not**:
- ❌ Larger bundle (~150 KB typical usage)
- ❌ Too comprehensive (shipping unused code)

**Best for**: More complex OSS apps (not CLI tools)

### Avoid: MUI, Ant Design

**Why**:
- ❌ 200-600 KB bundles (too large)
- ❌ Devs will complain in issues
- ❌ Overkill for simple tools

### Avoid: shadcn/ui

**Why**:
- ❌ Manual updates (security fixes don't auto-apply)
- ❌ Contributors might fork/update inconsistently
- ⚠️ Better for commercial products with dedicated maintainers

## Real-World Example

**Scenario**: Building API testing tool (like Postman but simpler)

**What Alex needs**:
- Request builder (method dropdown, URL input)
- Response viewer (JSON, headers)
- Tabs for multiple requests
- Modal for settings
- Dark mode

**With Headless UI** (2 months, nights/weekends):
- Week 1-2: Setup, basic UI with Headless components
- Week 3-4: Request builder (Listbox for method, Input for URL)
- Week 5-6: Response viewer (Tabs for JSON/headers)
- Week 7-8: Settings modal, polish
- **Result**: Shipped in 2 months, 15 KB bundle

**With MUI** (2 months but bloated):
- Week 1-8: Same timeline
- **Result**: Shipped but 200 KB bundle
- **Outcome**: GitHub issues about bundle size

**With custom build** (4+ months):
- Week 1-4: Build dropdown, input, tabs, modal
- Week 5-8: Add accessibility
- Week 9-12: Fix keyboard navigation bugs
- Week 13-16: Feature development
- **Result**: 4 months vs 2, accessibility issues

## Persona Objections & Responses

**"Won't dependencies become a security risk?"**
- Headless UI / Radix: Tailwind Labs / WorkOS-backed (trusted)
- Dependabot auto-PRs for security updates
- Small dependencies = smaller attack surface

**"What if the library gets abandoned?"**
- Choose libraries with company backing (Headless UI, Radix)
- Even if abandoned, code is simple enough to fork
- Better than maintaining custom from scratch

**"Won't contributors complain about dependencies?"**
- Developers respect Headless UI / Radix (quality libraries)
- 12-20 KB is acceptable for good accessibility
- Better than custom components with bugs

**"What about bundle size?"**
- Headless UI: 12 KB (smaller than most icon libraries)
- Radix: 5-7 KB per primitive (import only what you need)
- Both tiny compared to MUI (200 KB)

## Real OSS Projects Using Headless/Radix

**Projects using Radix UI**:
- shadcn/ui (meta: library built on library)
- cal.com (scheduling app)
- Numerous dev tools

**Projects using Headless UI**:
- Various Tailwind ecosystem tools
- CLI dashboards
- Code editors

**Why they chose headless**:
- Small bundles
- Accessibility built-in
- Contributor familiarity

## Contributing Experience

**With Headless UI / Radix**:
```tsx
// Contributor sees familiar patterns
import { Dialog } from '@headlessui/react'

<Dialog open={isOpen} onClose={close}>
  <Dialog.Panel>
    {/* Contributor knows this API */}
  </Dialog.Panel>
</Dialog>
```

**With custom components**:
```tsx
// Contributor must learn custom API
import { Modal } from '../components/Modal'

<Modal visible={isVisible} onDismiss={handleDismiss}>
  {/* Custom API = higher friction */}
</Modal>
```

**Lower friction** = more contributors

## Bottom Line

**Open-source developers should prioritize bundle size + accessibility**:

**Best choice**: Headless UI (smallest, excellent a11y, dev-friendly)
**More components needed**: Radix UI (25+ primitives, modular)
**Complex OSS app**: Mantine (comprehensive, free)

**Key insight**: Your unique value is the **tool's functionality**, not custom UI components.

**Use libraries** to:
- Ship faster (10-15 hrs/week = every hour counts)
- Ensure accessibility (inclusive community)
- Keep bundles small (developers notice)
- Lower contributor barrier (familiar patterns)

**Don't build custom** unless:
- UI is the unique value proposition
- Building design system tool (then use Radix as demo)
- Intentionally learning/teaching component development

Otherwise: Use Headless UI or Radix, ship features, get stars.


---

# Use Case: Startup Building MVP

## Who Needs This

**Persona**: Sarah, Technical Founder at Early-Stage SaaS Startup

**Context**:
- Solo technical founder or 2-3 person team
- Building MVP for investor pitch or first customers
- 6-week timeline to launch
- Limited budget ($0-$5K for all tools)
- Need to move fast, validate market fit

**Technical background**:
- React experience (1-2 years)
- Familiar with Tailwind CSS or basic CSS
- Using Next.js or Vite for build
- TypeScript preferred but not required

## Why They Need UI Component Libraries

### Pain Points

**1. Time Pressure**
- Can't spend 2-3 weeks building components from scratch
- Every day matters for runway and validation
- Need to focus on unique value prop, not buttons

**2. Quality Bar**
- Investors and early customers expect professional UX
- Accessibility matters even at MVP stage (larger TAM)
- Can't ship broken modals or buggy dropdowns

**3. Resource Constraints**
- No designer on team (yet)
- No time for pixel-perfect custom designs
- Need "good enough" that looks professional

**4. Unknown Future**
- May need to pivot - can't invest heavily in custom design system
- Might hire designer later who wants to change everything
- Need flexibility to evolve

### Goals

**Primary**: Ship working product in 6 weeks that looks credible

**Secondary**:
- Keep bundle size reasonable (performance = SEO = growth)
- Don't accumulate technical debt that blocks Series A
- Make it easy to hand off to future hires

### Requirements

**Must-haves**:
- Forms (login, signup, settings)
- Modals (confirmations, onboarding)
- Basic data display (tables, lists)
- Professional appearance

**Nice-to-haves**:
- Dark mode (if time permits)
- Responsive design (mobile users exist)
- Accessibility (WCAG AA minimum)

**Don't need**:
- Advanced data grids
- Complex visualizations
- Custom design language
- Internationalization

## Decision Criteria

### 1. Setup Time
**Critical**: Must be productive within 1-2 hours

**What this means**:
- ✅ npm install → start using
- ❌ Complex theming setup
- ❌ Learning new paradigms

### 2. Component Coverage
**Important**: Need common components out-of-box

**What this means**:
- ✅ Button, Input, Modal, Select, Table
- ✅ Form handling (validation, error states)
- ❌ Don't need 100+ components (unused bloat)

### 3. Documentation Quality
**Critical**: Can't afford to debug library internals

**What this means**:
- ✅ Copy-paste examples that work
- ✅ Common patterns documented
- ❌ Sparse docs = lost time

### 4. Bundle Size
**Moderate**: Investors check performance

**What this means**:
- ✅ < 100 KB for common components
- ⚠️ 100-200 KB acceptable if saves time
- ❌ > 200 KB raises eyebrows

### 5. Flexibility
**Important**: May need to pivot or rebrand

**What this means**:
- ✅ Easy to customize colors, fonts
- ✅ Can swap components later
- ❌ Deep coupling to design system

## Why Existing Solutions Fall Short

**Building from scratch**:
- ❌ 2-3 weeks = 30-50% of runway
- ❌ Quality won't match seasoned libraries
- ❌ Accessibility gaps will emerge

**Using design tools (Figma)**:
- ❌ Still need to implement in code
- ❌ Figma → React translation is work
- ❌ No behavior (modals, dropdowns) from Figma

**Bootstrap/older libraries**:
- ❌ Dated appearance ("investor can tell")
- ❌ Not React-native patterns
- ❌ jQuery-era paradigms

## Success Metrics

**Week 1**: Login/signup flow working
**Week 3**: Core feature usable with professional UI
**Week 6**: Launched with 0 UI-related bugs

**Longer term**:
- Investors don't comment on UI quality
- Can hire designer who can customize
- No technical debt blocking Series A

## Library Recommendations for This Persona

### Best Fit: shadcn/ui

**Why it works**:
- ✅ Fast setup (if using Tailwind)
- ✅ Beautiful defaults (investor-ready)
- ✅ Copy code = owns it (easy to customize later)
- ✅ Excellent docs with examples
- ✅ Small bundle (~20 KB for common components)
- ✅ Modern, professional aesthetic

**Why it might not**:
- ❌ Requires Tailwind CSS (learning curve if new)
- ❌ Manual updates (but startups pivot anyway)

### Alternative: Mantine

**Why it works**:
- ✅ Comprehensive (forms, dates, notifications built-in)
- ✅ Great docs and examples
- ✅ Modern DX, TypeScript-first
- ✅ Free (no premium tier)
- ✅ Can customize later via theme

**Why it might not**:
- ❌ Not compatible with Tailwind (if team knows Tailwind)
- ❌ More opinionated (less flexibility for future designer)

### Avoid: Radix UI, Headless UI

**Why**:
- ❌ Need to style everything (3-5 days of work)
- ❌ Startups don't have time for custom styling
- ❌ Better for design systems, not MVPs

### Avoid: Ant Design

**Why**:
- ❌ Enterprise aesthetic (not modern SaaS look)
- ❌ Larger bundle size
- ❌ Investors might recognize "admin panel" feel

## Real-World Example

**Scenario**: Building project management SaaS MVP

**What Sarah needs**:
- Signup/login forms
- Dashboard with project cards
- Modal for creating new projects
- Table showing tasks
- Settings page

**With shadcn/ui** (Week 1):
- Day 1: Install shadcn/ui, add Button, Input, Form components
- Day 2: Build login/signup with Form validation
- Day 3: Add Modal, Card for dashboard
- Day 4: Implement Table for tasks
- Day 5: Settings page with Form
- **Result**: Investor-ready UI in 1 week

**Without component library** (Week 1-2):
- Day 1-3: Build Button, Input, Form with validation
- Day 4-5: Modal with focus trap, Escape handling
- Day 6-7: Accessible dropdown, select components
- Day 8-10: Table with sorting
- **Result**: Still building components, no product yet

**Time saved**: 1.5 weeks = 25% of entire timeline

## Persona Objections & Responses

**"Won't this lock us into a library?"**
- With shadcn/ui: You own the code, can fork/modify anytime
- With Mantine: Can migrate later if needed, but why spend time now?

**"What if we hire a designer who hates this?"**
- Designer can customize theme (shadcn: edit CSS vars, Mantine: theme object)
- If full rebrand needed, happens at Series A anyway (timeline: 6-12 months out)

**"Shouldn't we build our own for brand differentiation?"**
- MVP stage: Functionality > Brand
- Investors evaluate product-market fit, not button styles
- Can differentiate later with growth

**"What about performance?"**
- Modern libraries (shadcn, Mantine) have small bundles
- Google PageSpeed scores 90+ achievable
- Performance matters, but 20 KB library not the bottleneck

## Bottom Line

**Startups should almost always use a component library** for MVP:

**Time saved**: 1-3 weeks of development
**Quality gained**: Professional appearance, accessibility
**Flexibility retained**: Can customize or migrate post-PMF

**Don't overthink it**: Pick shadcn/ui (Tailwind users) or Mantine (others), ship product, validate market.

</details><details>
<summary>S4: Strategic</summary>

# S4-Strategic: Long-Term Viability Analysis

## Objective

Evaluate **long-term strategic decisions** for UI component libraries: vendor stability, ecosystem health, migration costs, and technology trends. This pass informs which libraries are safe bets for 3-5+ year commitments.

## Analysis Framework

### 1. Vendor Stability
- **Backing**: Company-backed vs community-maintained
- **Funding**: Revenue model, investor backing
- **Track record**: Years in production, major versions
- **Bus factor**: Single maintainer vs team

### 2. Ecosystem Health
- **Adoption**: GitHub stars, npm downloads
- **Community**: Discord activity, GitHub issues response time
- **Third-party**: Plugins, templates, tutorials
- **Jobs market**: Demand for library skills

### 3. Technology Trends
- **Industry direction**: CSS-in-JS vs static CSS
- **Framework evolution**: React 19+, Server Components
- **Styling paradigms**: Tailwind dominance, utility-first
- **Accessibility**: Legal requirements increasing

### 4. Migration Costs
- **Lock-in depth**: How hard to migrate away?
- **Upgrade path**: Breaking changes between majors
- **Codemod support**: Automated migration tools
- **Alternative compatibility**: Can swap incrementally?

## What S4 Covers

**Long-term bets**: Which libraries will exist in 5 years?
**Technology alignment**: Which match future trends?
**Risk assessment**: What could go wrong?
**Exit strategy**: How hard to migrate if needed?

## What S4 Does NOT Cover

- Implementation details (S2)
- Short-term decisions (S3)
- Technical specifications (S2)

## Deliverables

- `<library>-viability.md` for each library
- `recommendation.md` for strategic guidance


---

# S4 Strategic Recommendations

## The 5-Year Safe Bet

**For most teams in 2025, choose: Mantine**

**Why**:
- ✅ Modern architecture (CSS Modules, zero runtime)
- ✅ Comprehensive (120+ components, everything you need)
- ✅ Free (no paid tiers, no vendor lock-in)
- ✅ Active development (v7 released 2024, ongoing updates)
- ✅ Strong community (28K stars, growing)
- ✅ Good TypeScript support
- ✅ Aligned with trends (moved away from CSS-in-JS)

**Risk level**: Low-Medium
- Small team but active, sponsors, community support
- Could add paid tier if funding needed (like Chakra)
- MIT license (can fork if abandoned)

## Risk-Stratified Recommendations

### Minimize Risk (Enterprise, 10-Year Horizon)

**Tier 1: Enterprise-Safe**

**MUI**
- Company-backed (MUI SAS)
- Revenue model (MUI X freemium)
- 8+ year track record
- Used by: Netflix, Amazon, Spotify
- **Choose when**: Material Design acceptable, budget for MUI X if needed

**Ant Design**
- Alibaba-backed
- 9+ year track record
- Massive scale (Alibaba, Alipay)
- Best data table
- **Choose when**: Enterprise dashboard, data-heavy, Chinese market

**Risk**: Minimal (both will exist in 10 years)

### Balance Risk & Innovation (5-Year Horizon)

**Tier 2: Modern & Stable**

**Radix UI**
- WorkOS-backed
- Powers shadcn/ui (proven at scale)
- Accessibility-first
- Stable API
- **Choose when**: Building design system, need full control

**Headless UI**
- Tailwind Labs-backed
- Stable API
- Vue support
- Small bundle
- **Choose when**: Using Tailwind, need minimal library

**Mantine**
- Active development
- Strong momentum
- Free, comprehensive
- Modern architecture
- **Choose when**: Want complete library, modern DX, not using Tailwind

**Risk**: Low (all likely to exist in 5+ years)

### Accept Higher Risk (2-3 Year Horizon)

**Tier 3: Fast-Moving**

**shadcn/ui**
- Fastest growth in React ecosystem history
- Code ownership model
- Modern aesthetic
- Single maintainer (risk)
- **Choose when**: Using Tailwind, want beautiful defaults, short-medium horizon

**Chakra UI**
- Established community
- v3 migration upcoming (Panda CSS)
- Good DX
- **Choose when**: Team already knows Chakra, prop-based styling preferred

**Risk**: Medium (single maintainer for shadcn, major migration for Chakra)

## Decision Matrix by Risk Tolerance

| Risk Tolerance | Recommendation | Rationale |
|----------------|---------------|-----------|
| **Minimal** | MUI or Ant Design | Company-backed, revenue, 8-10 year track record |
| **Low** | Radix UI, Headless UI, or Mantine | Strong backing or momentum, modern, 5+ year safe |
| **Medium** | shadcn/ui or Chakra UI | Faster innovation, some risk acceptable |
| **High** | Bleeding edge (Panda CSS, etc.) | Early adopter, willing to migrate |

## Technology Bet Recommendations

### If You Believe: "Tailwind Will Dominate"

**→ shadcn/ui**
- Purpose-built for Tailwind
- Copy-paste model fits Tailwind philosophy
- Beautiful defaults
- Risk: Single maintainer

**Alternative: Headless UI**
- Tailwind Labs official
- Lower risk
- Fewer components (trade-off)

### If You Believe: "CSS-in-JS Is Dead"

**→ Mantine**
- Already migrated (v7 uses CSS Modules)
- Proven migration path
- Zero runtime overhead

**Avoid**:
- MUI, Ant Design v5 (still CSS-in-JS)
- Chakra v2 (migrating in v3)

### If You Believe: "Developers Want Code Ownership"

**→ shadcn/ui**
- Copy-paste model
- You own the code
- No npm dependency hell

**Challenge**: How to deliver security updates?

**Alternative: Radix UI**
- Build your own copy-paste system
- Same foundation as shadcn/ui

### If You Believe: "Accessibility Will Be Mandated"

**→ Radix UI**
- Best accessibility implementation
- WAI-ARIA experts
- Powers accessible libraries (shadcn/ui)

**Alternative: Headless UI**
- Also accessibility-first
- Simpler API

## Exit Strategy Planning

### Easiest to Migrate Away From

**Headless libraries (Radix UI, Headless UI)**
- Minimal lock-in (just primitives)
- Swap styling paradigm anytime
- 1-2 weeks to migrate to another headless

**shadcn/ui**
- You already own code
- Can swap foundation (Radix → something else)
- 2-4 weeks to migrate

### Moderate Migration Effort

**Mantine, Chakra UI**
- Theme + component patterns
- 2-3 months migration
- Can do incrementally

### Hardest to Migrate Away From

**Ant Design**
- Table, Form deeply integrated
- 4-6 months migration
- Hard to do incrementally

**MUI X Premium**
- Sunk cost (paid licenses)
- Data Grid deeply integrated
- 6+ months migration

**Recommendation**: If long-term flexibility matters, choose headless (Radix/Headless UI).

## Vendor Stability vs Innovation

```
High Stability, Lower Innovation
│
├─ MUI (Enterprise-safe, Material Design, CSS-in-JS)
├─ Ant Design (Enterprise-safe, Enterprise aesthetic, CSS-in-JS)
│
Medium Stability, Good Innovation
│
├─ Radix UI (WorkOS-backed, Accessibility-first, Headless)
├─ Headless UI (Tailwind Labs, Minimal, Vue support)
├─ Mantine (Community-strong, Comprehensive, CSS Modules)
│
Lower Stability, High Innovation
│
├─ shadcn/ui (Single maintainer, Copy-paste model, Fastest growth)
├─ Chakra UI (Community, v3 migration, Zero-runtime soon)
│
High Innovation, Uncertain Stability
│
└─ Bleeding edge (Panda CSS, etc.)
```

**Choose based on horizon**:
- 10+ years → Top tier (MUI, Ant)
- 5 years → Middle tier (Radix, Headless, Mantine)
- 2-3 years → Lower tier (shadcn, Chakra)
- Experimental → Bottom tier

## Diversification Strategy

**For large organizations** (multiple products):

**Portfolio approach**:
1. **Design system team**: Radix UI (build internal library)
2. **Enterprise products**: Ant Design or MUI (proven, data-heavy)
3. **Consumer products**: shadcn/ui or Mantine (modern, flexible)
4. **Marketing sites**: Headless UI + Tailwind (minimal, fast)

**Rationale**: Different products have different needs, one size doesn't fit all.

## The Conservative Play

**If you must minimize regret**:

**Choice: MUI or Ant Design**

**Why**:
- Will definitely exist in 10 years (company-backed)
- Proven at massive scale (Netflix, Alibaba)
- Migration paths well-documented
- Job market demand (hiring easier)
- Commercial support available

**Trade-offs**:
- Larger bundles
- CSS-in-JS (declining trend)
- Strong visual identity (harder to customize)
- Not bleeding-edge

**When this makes sense**:
- Enterprise with 10-year product lifecycle
- Risk-averse organization
- Team unfamiliar with modern alternatives
- Need vendor support contract

## The Modern Play

**If you want to align with industry trends**:

**Choice: shadcn/ui (Tailwind users) or Mantine (others)**

**Why**:
- Aligned with 2025 trends (static CSS, code ownership)
- Modern developer experience
- Active communities
- Growing momentum

**Trade-offs**:
- Less proven at enterprise scale
- Smaller vendor stability
- Potentially need to migrate in 5 years

**When this makes sense**:
- Startup or growth-stage company
- Team comfortable with modern tools
- 2-5 year horizon
- Willing to accept some risk for better DX

## The Future-Proof Play

**If you want maximum flexibility**:

**Choice: Radix UI (React) or Headless UI (Vue)**

**Why**:
- Minimal lock-in (just behavior/a11y)
- Can swap styling paradigm anytime
- Aligned with accessibility requirements
- Powers other libraries (proven)

**Trade-offs**:
- More work upfront (must style everything)
- Longer time-to-market
- Need CSS expertise

**When this makes sense**:
- Building long-term design system
- Uncertain about styling approach
- Team has design/CSS expertise
- Want to own visual identity

## 2025 Industry Consensus

**Emerging consensus** from developers, companies, surveys:

1. **For new projects using Tailwind** → shadcn/ui
2. **For new projects not using Tailwind** → Mantine
3. **For enterprise data-heavy apps** → Ant Design or MUI
4. **For custom design systems** → Radix UI
5. **For maximum flexibility** → Headless UI or Radix UI

**The "safest bet" for most teams** → **Mantine**:
- Modern (CSS Modules, not CSS-in-JS)
- Comprehensive (120+ components)
- Free (no vendor lock-in)
- Growing (strong momentum)
- Medium risk (community-backed, but active)

## Red Flags (When to Avoid a Library)

**Avoid if**:
- Single maintainer + no company backing + critical project
- Declining GitHub activity (< 1 commit/month)
- Unresolved security issues (check GitHub security tab)
- Major version with no migration path
- Company pivoting away from OSS (rare but happens)

**Current libraries with red flags**:
- ⚠️ shadcn/ui: Single maintainer (but you own code anyway)
- ⚠️ Chakra UI: v3 migration uncertainty

**All others**: Green light for 2025

## Final Strategic Recommendation

**Default choice for 2025**: **Mantine**

**If using Tailwind**: **shadcn/ui**

**If enterprise/risk-averse**: **Ant Design** (data-heavy) or **MUI** (Material Design)

**If building design system**: **Radix UI**

**Don't overthink it**: All modern libraries (Mantine, shadcn, Radix, Headless, MUI, Ant) are viable. Choose based on context, not "perfect" choice (doesn't exist).

**The real mistake**: Building custom from scratch (unless you're Stripe/Figma/etc. with dedicated UI platform team).


---

# Strategic Viability Comparison

## Vendor Stability Matrix

| Library | Backing | Funding Model | Years Active | Bus Factor | Stability Score |
|---------|---------|---------------|--------------|------------|-----------------|
| **MUI** | MUI SAS (company) | Freemium (MUI X Pro/Premium) | 8+ years | Team (15+) | ★★★★★ |
| **Ant Design** | Alibaba | Corporate OSS | 9+ years | Team (20+) | ★★★★★ |
| **Radix UI** | WorkOS (company) | Corporate OSS | 5+ years | Team (5+) | ★★★★☆ |
| **Headless UI** | Tailwind Labs | Corporate OSS (Tailwind revenue) | 4+ years | Team (3+) | ★★★★☆ |
| **Mantine** | Community + sponsors | Donations/sponsors | 4+ years | Small team (2-3) | ★★★☆☆ |
| **Chakra UI** | Community + sponsors | Donations/sponsors | 6+ years | Distributed team | ★★★☆☆ |
| **shadcn/ui** | Vercel engineer (personal) | Community OSS | 2+ years | Single maintainer | ★★☆☆☆ |

### Stability Analysis

**Tier 1: Enterprise-Safe (10-year bet)**
- **MUI**: Company with revenue ($5M+ ARR from MUI X), investors, team
- **Ant Design**: Alibaba-backed, used in production at scale

**Tier 2: Very Stable (5-year bet)**
- **Radix UI**: WorkOS-backed (company product), team, battle-tested
- **Headless UI**: Tailwind Labs (profitable company), small team

**Tier 3: Community-Strong (3-5 year bet)**
- **Mantine**: Active maintainer, sponsors, growing community
- **Chakra UI**: Established community, multiple maintainers

**Tier 4: Emerging (2-3 year bet, monitor)**
- **shadcn/ui**: Single maintainer (employed by Vercel), rapid growth

## Ecosystem Health

### Adoption Metrics (2025)

| Library | GitHub Stars | npm Downloads/Week | Growth Trend | Community Activity |
|---------|-------------|-------------------|--------------|-------------------|
| **MUI** | 95K | 4.1M | Steady | Very High |
| **Ant Design** | 94K | 1.4M | Steady | High |
| **shadcn/ui** | 85K | N/A (copy-paste) | ↗️ Explosive | Very High |
| **Chakra UI** | 39K | 587K | Steady | High |
| **Mantine** | 28K | 500K | ↗️ Growing | High |
| **Headless UI** | 26K | 800K | Steady | Moderate |
| **Radix UI** | 17K (per primitive) | 226K/primitive | ↗️ Growing | Moderate |

**2023-2025 Trends**:
- **shadcn/ui**: +60K stars (fastest growth ever seen)
- **Mantine**: +15K stars (strong growth)
- **Radix UI**: +8K stars (growing as shadcn foundation)
- **MUI/Ant**: Steady (established)
- **Chakra**: Declining slightly (still stable)

### Developer Sentiment (Twitter, Reddit, Blogs)

**Rising**:
- shadcn/ui: "Changed how I think about components"
- Mantine: "Most underrated library"
- Radix UI: "The foundation for everything"

**Established**:
- MUI: "Go-to for Material Design"
- Ant Design: "Best for enterprise dashboards"

**Declining**:
- Chakra UI: "Good but CSS-in-JS feels dated"
- Bootstrap: "Nobody talks about it anymore"

### Job Market Demand

**Indeed.com mentions (2025)**:
- React + MUI: 2,400 jobs
- React + Ant Design: 1,800 jobs
- React + Chakra UI: 600 jobs
- React + Tailwind + shadcn: Growing (600+)
- React + Mantine: 200 jobs

**Interpretation**: MUI/Ant are established, shadcn/Tailwind rising fast

## Technology Alignment

### Industry Trends (2023-2025)

**Trend 1: CSS-in-JS Declining**
- Emotion, styled-components losing favor
- Performance concerns (runtime overhead)
- Build-time CSS preferred

**Impact**:
- ✅ **Mantine v7**: Migrated from Emotion → CSS Modules (aligned)
- ✅ **shadcn/ui, Headless UI, Radix**: Never used CSS-in-JS (aligned)
- ⚠️ **Chakra UI v3**: Moving to Panda CSS (zero-runtime) (adapting)
- ❌ **MUI, Ant v5**: Still CSS-in-JS (behind trend but functional)

**Trend 2: Tailwind Dominance**
- Utility-first CSS mainstream
- 50%+ of new React projects use Tailwind
- shadcn/ui proved copy-paste + Tailwind works

**Impact**:
- ✅ **shadcn/ui, Headless UI**: Purpose-built for Tailwind (perfect alignment)
- ⚠️ **Radix UI**: Works with Tailwind (good alignment)
- ❌ **MUI, Ant, Chakra, Mantine**: Not Tailwind-compatible (diverging)

**Trend 3: Component Ownership**
- Developers want to own code (not npm dependencies)
- Copy-paste model gaining traction
- shadcn/ui pioneered, others may follow

**Impact**:
- ✅ **shadcn/ui**: Invented the model (perfect alignment)
- ⚠️ **Others**: Traditional npm model (functional but less aligned)

**Trend 4: Server Components (React 19+)**
- Next.js App Router, RSC architecture
- Need components compatible with Server Components

**Impact**:
- ✅ **All modern libraries**: Compatible with RSC
- ⚠️ **Older versions**: May need updates (mostly resolved)

**Trend 5: Accessibility Requirements**
- WCAG 2.2 / ADA lawsuits increasing
- Accessibility table stakes, not nice-to-have

**Impact**:
- ✅ **Radix, Headless UI, shadcn**: Accessibility-first (best aligned)
- ⚠️ **Chakra, Mantine**: Good accessibility (aligned)
- ⚠️ **MUI, Ant**: Acceptable but gaps (minimally aligned)

### Technology Forecast (2026-2028)

**Prediction 1**: CSS-in-JS will decline further
- **Winners**: Mantine, shadcn/ui, Headless UI, Radix UI
- **Adapters**: Chakra (moving to Panda CSS)
- **Laggers**: MUI, Ant (but revenue offsets technical debt)

**Prediction 2**: Tailwind will remain dominant
- **Winners**: shadcn/ui, Headless UI
- **Unaffected**: Others serve non-Tailwind market (still large)

**Prediction 3**: Copy-paste model will grow
- **Pioneer**: shadcn/ui
- **Possible**: Others may offer copy-paste variants
- **Challenge**: How to deliver security updates?

## Migration Cost Analysis

### Lock-In Depth (How hard to migrate away?)

**Low Lock-In**:
- **Headless UI, Radix UI**: Primitives only, easy to swap
- **shadcn/ui**: You own code, already "forked"

**Medium Lock-In**:
- **Mantine, Chakra**: Theming + components, 2-3 months to migrate
- **MUI**: Moderate (theme + components + sx prop patterns)

**High Lock-In**:
- **Ant Design**: Deep integration (Table, Form), 4-6 months to migrate
- **MUI X Premium**: Paid components, sunk cost + migration time

### Upgrade Path (Major version migrations)

| Library | v4→v5 Difficulty | v5→v6 Expected | Codemod Support | Breaking Change Frequency |
|---------|-----------------|----------------|-----------------|--------------------------|
| **Radix UI** | N/A (stable) | Minimal | No (not needed) | Rare |
| **Headless UI** | Minimal | Minimal | No (not needed) | Rare |
| **Mantine** | Significant (Emotion→CSS) | Moderate | Yes (good) | Every 1-2 years |
| **Chakra UI** | Moderate | Significant (v3 zero-runtime) | Yes | Every 2 years |
| **MUI** | Significant (JSS→Emotion) | Moderate (zero-runtime?) | Yes (excellent) | Every 2-3 years |
| **Ant Design** | Significant (Less→CSS-in-JS) | Moderate | Yes (good) | Every 2-3 years |
| **shadcn/ui** | Manual (copy-paste) | Manual | N/A | Self-managed |

**Interpretation**:
- **Headless libraries** (Radix, Headless UI): Stable APIs, rare breaking changes
- **Full libraries** (Mantine, Chakra, MUI, Ant): Major migrations every 2-3 years
- **shadcn/ui**: You control updates (blessing + curse)

## Risk Assessment

### High-Risk Scenarios

**shadcn/ui**:
- ⚠️ **Single maintainer**: If shadcn (the person) leaves, project stalls
- Mitigation: Vercel connection, community can fork, you own code anyway

**Mantine**:
- ⚠️ **Funding sustainability**: Relies on sponsors, no revenue model
- Mitigation: Strong community, could add paid tier if needed

**Chakra UI**:
- ⚠️ **CSS-in-JS migration**: v3 is major rewrite (Panda CSS)
- Mitigation: Codemod available, but still risky

**MUI X Premium**:
- ⚠️ **Pricing changes**: Company could raise prices
- Mitigation: Perpetual licenses available

**All libraries**:
- ⚠️ **React paradigm shifts**: If React architecture changes drastically
- Mitigation: All libraries adapt (ecosystem incentive)

### Low-Risk (Safe Bets)

**MUI**:
- ✅ Company with revenue, team, track record
- Risk: Minimal (enterprise-safe)

**Ant Design**:
- ✅ Alibaba-backed, used at massive scale
- Risk: Minimal (enterprise-safe)

**Radix UI**:
- ✅ WorkOS-backed, powers shadcn/ui (huge adoption)
- Risk: Low (very safe)

**Headless UI**:
- ✅ Tailwind Labs (profitable company from Tailwind CSS)
- Risk: Low (safe bet)

## Strategic Recommendations

### For 10-Year Horizons (Enterprise)

**Safest bets**:
1. **MUI** - Company revenue, team, established
2. **Ant Design** - Alibaba-backed, proven at scale

**Rationale**: Company/corporate backing, revenue models, proven track records

### For 5-Year Horizons (Most Projects)

**Recommended**:
1. **Radix UI** - WorkOS-backed, battle-tested (powers shadcn/ui)
2. **Headless UI** - Tailwind Labs, stable API
3. **Mantine** - Strong community, active development
4. **MUI / Ant Design** - Established, low risk

**Rationale**: Mix of stability + modern architecture

### For 2-3 Year Horizons (Startups, MVPs)

**Recommended**:
1. **shadcn/ui** - Fastest growth, you own code anyway
2. **Mantine** - Comprehensive, free
3. **Chakra UI** - Good DX, community support

**Rationale**: Risk acceptable for shorter horizon, prioritize speed

### Technology Bet: Tailwind vs CSS-in-JS

**If betting on Tailwind dominance**:
- ✅ shadcn/ui
- ✅ Headless UI
- ⚠️ Radix UI (works but not optimized)

**If staying with CSS-in-JS**:
- ⚠️ Chakra → Panda (zero-runtime) coming
- ⚠️ MUI, Ant → Declining trend but functional

**If betting on CSS Modules**:
- ✅ Mantine v7

### Exit Strategy Planning

**Easiest to migrate from**:
- Headless UI, Radix UI (just primitives)
- shadcn/ui (already own code)

**Medium effort**:
- Mantine, Chakra (2-3 months)

**Hardest to migrate from**:
- Ant Design (Table, Form deeply integrated)
- MUI X Premium (sunk cost + time)

**Recommendation**: If unsure, choose headless (Radix/Headless UI) - easiest to swap later

## 2025-2030 Forecast

**Libraries likely to grow**:
- shadcn/ui (if sustainable model found)
- Mantine (strong momentum)
- Radix UI (as headless foundation)

**Libraries likely stable**:
- MUI (enterprise incumbent)
- Ant Design (China + enterprise)
- Headless UI (Tailwind ecosystem)

**Libraries at crossroads**:
- Chakra UI (v3 migration will determine fate)

**Libraries likely to decline** (relative share):
- Bootstrap, Material-UI v4, Semantic UI (already happened)

## Final Strategic Guidance

**Conservative choice** (minimize risk):
- MUI or Ant Design (enterprise-proven)

**Modern choice** (align with trends):
- shadcn/ui (Tailwind) or Mantine (non-Tailwind)

**Design system choice** (flexibility + control):
- Radix UI (best primitives)

**Future-proof choice** (adapt to changes):
- Headless libraries (Radix, Headless UI) - can swap styling paradigms

**Key insight**: The safest 5-year bet is **Mantine** (free, comprehensive, modern architecture, active development, no vendor lock-in).

</details>
