# 2.001 Payment Processing Services: QRCards Strategic Analysis

**Date**: October 7, 2025
**Application**: QRCards Platform
**Discovery Reference**: 3.001-payment-processing MPSE Discovery Synthesis
**Priority**: Medium (Deferred to Q1 2026 per Round 4 strategy)

---

## QRCards-Specific Context

### Current State Assessment

**Platform Maturity**: Level 3.5 (Production-ready, strategic shift to "reveal, document, scale")
- 75+ API endpoints across multiple routers
- 200+ CLI commands with 17 command groups
- 101 SQLite databases in production
- Proven creator economy infrastructure
- **No payment integration yet** (platform development prioritized over monetization)

**Revenue Model (Planned Q1 2026)**:
1. **Template Marketplace** - Creators sell QR templates to other users ($5-50 per template)
2. **Premium Features** - Advanced analytics, custom domains, white-label ($15-99/month subscription)
3. **Usage-based Billing** - API calls, QR generations beyond free tier ($0.01-0.05 per generation)
4. **Enterprise Plans** - Custom contracts for businesses ($500-5,000/month)
5. **Platform Commission** - 10-20% of marketplace transactions

**Technical Context**:
- **Backend**: FastAPI (Python)
- **Current stage**: Production platform, payment deferred to Q1 2026
- **Shared with**: Intelligence Portal (same FastAPI codebase)
- **Payment complexity**: Higher than Intelligence Portal (marketplace, usage-based, commission splits)

**Round 4 Strategic Decision**:
> "QR Cards Hardening → Defer to Q1 2026. Current Level 3.5 maturity is 'good enough' for Q4 demonstrations. 160-320 hours with zero customers = terrible opportunity cost under financial pressure."

---

## QRCards-Specific Requirements

### Must-Have Features (Q1 2026)
1. **Marketplace payments** - Creator-to-creator template sales with platform commission
2. **Subscription management** - Monthly/annual premium features
3. **Usage-based billing** - API calls, QR generations (metered billing)
4. **Payout system** - Pay creators for their template sales (splits, holds, verification)
5. **Tax handling** - International marketplace transactions (complex)
6. **Multiple payment methods** - Credit card, PayPal, ACH (creator payouts), international

### Nice-to-Have Features
1. **Escrow** - Hold funds until template delivery confirmed
2. **Dispute resolution** - Refunds, chargebacks for marketplace
3. **Dynamic pricing** - Creator-set prices, sales, bundles
4. **Affiliate system** - Referral commissions for creators promoting platform
5. **Multi-currency** - Global creator base (100+ countries)

### Constraints
1. **Solo founder**: Payment system must be maintainable by one person
2. **Deferred timeline**: Q1 2026 implementation (after intelligence portal revenue)
3. **Marketplace complexity**: Two-sided payments (buyers + creator payouts)
4. **Financial pressure**: Need revenue from intelligence portal first (Round 4 priority)
5. **Existing infrastructure**: Redis, SQLite, FastAPI already in place

---

## MPSE Discovery Application to QRCards

### From General Analysis to Specific Recommendation

**MPSE Synthesis Recommendation (Scaling Company $100K-1M MRR)**:
> "Stripe with enterprise contract negotiation at $1M+ processing... Build payment abstraction layer (80-120 hours) and add backup provider."

**But QRCards is Pre-Revenue in Q1 2026**, so apply the earlier recommendation:

**MPSE Synthesis Recommendation (Solo Founder <$10K MRR → Growth Startup)**:
> "Lemon Squeezy for speed (30 min to first sale) OR Stripe for technical teams wanting maximum flexibility. Growth Startup ($10K-100K MRR): Stripe as primary processor with Stripe Tax add-on."

**QRCards Context**:
- **Revenue stage**: $0 → targeting $5K-20K MRR by Q2 2026 (marketplace + subscriptions)
- **Developer capacity**: Solo founder, but implementing Q1 2026 (less urgency than intelligence portal)
- **Tax complexity**: VERY HIGH (two-sided marketplace, international creators, commission splits)
- **Technical skill**: High (mature FastAPI platform), comfortable with complex integration
- **Strategic priority**: Platform sustainability > speed (can spend 80-120 hours on abstraction)

**Decision Matrix**:

| Factor | Lemon Squeezy | Stripe | Paddle | Weight | Winner |
|--------|--------------|--------|---------|---------|---------|
| Marketplace support | No | Yes (Connect) | Limited | CRITICAL | Stripe |
| Creator payouts | No | Yes (auto) | Manual | CRITICAL | Stripe |
| Usage-based billing | Limited | Excellent | Good | HIGH | Stripe |
| Tax handling | MoR (simple) | Manual/$500 | MoR (simple) | HIGH | Lemon/Paddle |
| Setup complexity | 30 min | 40-80 hours | 20-40 hours | MEDIUM | Lemon Squeezy |
| Transaction fees | 5% + $0.50 | 2.9% + $0.30 | 5% + $0.50 | HIGH | Stripe |
| Platform commission | Can't split | Native (Connect) | Complex | CRITICAL | Stripe |
| Future-proofing | Acquisition risk | Market leader | Acquisition risk | HIGH | Stripe |

**QRCards-Specific Constraints Stripe Wins On**:
1. **Stripe Connect** - Only viable solution for two-sided marketplace with automatic creator payouts
2. **Usage-based billing** - Stripe Billing handles metered usage natively
3. **Platform commission** - Application fees built into Connect
4. **Scale trajectory** - QRCards targets $100K+ MRR, needs enterprise-grade infrastructure

**Cost Analysis (First Year - Projected $50K Revenue)**:
- **Lemon Squeezy**: $2,500 fees + $0 tax + **NO MARKETPLACE SUPPORT** = Not viable
- **Paddle**: $2,500 fees + $0 tax + **complex marketplace workarounds** = $5,000+ dev time
- **Stripe**: $1,450 fees + $500 Stripe Tax + 80 hours setup @ $100/hr = **$9,950 total cost**

**But**:
- Stripe Connect enables marketplace (impossible with Lemon Squeezy)
- 80 hours includes abstraction layer (reduces future migration from 200+ hours to 40 hours)
- Proper foundation for $100K+ MRR scale (vs emergency rebuild at scale)

---

## QRCards Recommendation

### Primary Choice: **Stripe with Stripe Connect**

**Rationale**:
1. **Marketplace requirement**: Two-sided payments, creator payouts, commission splits = Stripe Connect only viable solution
2. **Usage-based billing**: Metered API calls/QR generations native in Stripe Billing
3. **Scale trajectory**: QRCards targets $100K+ MRR by end of 2026, needs enterprise platform from day one
4. **Tax complexity**: Stripe Tax ($500/year) handles international marketplace complexity
5. **Abstraction layer investment**: 80-120 hours upfront saves 200+ hours emergency migration later

**Strategic Justification**:
Unlike Intelligence Portal (simple purchases, speed critical), QRCards is:
- **Complex marketplace** (creators selling to creators)
- **Deferred timeline** (Q1 2026, not Oct 2025)
- **Higher revenue target** ($50K+ MRR vs $5K)
- **Multi-sided payments** (buyers, creators, platform)

**Stripe Connect is non-negotiable for marketplace.** No other provider offers comparable functionality.

---

## QRCards Implementation Plan

### Phase 1: Stripe Account & Connect Setup (Q1 2026 - Week 1, 12 hours)

**Step 1: Stripe Account Configuration (4 hours)**
```bash
# Create Stripe account
# Enable Stripe Connect (Platform mode)
# Configure platform commission settings
# Set up webhook endpoints
# Enable Stripe Tax
# Connect business bank account
```

**Platform Configuration**:
- **Connect type**: Standard Connect (creators control their own Stripe accounts)
- **Application fee**: 10-20% of each marketplace transaction
- **Payout schedule**: Weekly to creators (T+7 rolling basis)
- **Supported countries**: Start with US, expand to 40+ countries

**Step 2: Tax Configuration (4 hours)**
```python
# Enable Stripe Tax for platform
stripe.tax.Settings.create(
    defaults={
        "tax_behavior": "exclusive",  # Show tax separately
        "tax_code": "txcd_10000000"   # Digital goods
    }
)

# Configure tax collection for marketplace
# Platform responsible for tax on commission (10-20%)
# Creators responsible for tax on their portion (80-90%)
# Stripe Tax calculates both automatically
```

**Step 3: Connect Onboarding Flow (4 hours)**
```python
# app/routes/creator_onboarding.py
from fastapi import APIRouter, HTTPException
import stripe

router = APIRouter(prefix="/creator")

@router.post("/connect-onboarding")
async def create_connect_account(creator_id: str):
    """Start Stripe Connect onboarding for creator"""

    # Create connected account
    account = stripe.Account.create(
        type="standard",  # Creator controls their account
        country="US",
        email=get_creator_email(creator_id),
        capabilities={
            "card_payments": {"requested": True},
            "transfers": {"requested": True}
        },
        business_type="individual",  # Most creators
        metadata={"qrcards_creator_id": creator_id}
    )

    # Create onboarding link
    account_link = stripe.AccountLink.create(
        account=account.id,
        refresh_url=f"{BASE_URL}/creator/connect-refresh",
        return_url=f"{BASE_URL}/creator/dashboard",
        type="account_onboarding"
    )

    # Store connected account ID
    await db.creators.update_one(
        {"id": creator_id},
        {"$set": {"stripe_account_id": account.id}}
    )

    return {"onboarding_url": account_link.url}

@router.get("/connect-status/{creator_id}")
async def check_connect_status(creator_id: str):
    """Check if creator completed Stripe onboarding"""

    creator = await db.creators.find_one({"id": creator_id})
    if not creator.get("stripe_account_id"):
        return {"status": "not_started"}

    account = stripe.Account.retrieve(creator["stripe_account_id"])

    return {
        "status": "complete" if account.charges_enabled else "incomplete",
        "payouts_enabled": account.payouts_enabled,
        "requirements": account.requirements.currently_due
    }
```

---

### Phase 2: Marketplace Payment Flow (Week 2, 20 hours)

**Template Purchase with Commission Split**:

```python
# app/routes/marketplace.py
from fastapi import APIRouter, Request
import stripe

router = APIRouter(prefix="/marketplace")

@router.post("/purchase-template")
async def purchase_template(
    template_id: str,
    buyer_id: str,
    payment_method_id: str
):
    """Purchase template from creator with platform commission"""

    # Get template and creator details
    template = await db.templates.find_one({"id": template_id})
    creator = await db.creators.find_one({"id": template["creator_id"]})

    if not creator.get("stripe_account_id"):
        raise HTTPException(400, "Creator hasn't completed payment setup")

    # Calculate amounts
    template_price = template["price"]  # e.g., $20.00 (2000 cents)
    platform_commission = int(template_price * 0.15)  # 15% = $3.00 (300 cents)
    creator_amount = template_price - platform_commission  # $17.00 (1700 cents)

    # Create payment intent with destination charge
    payment_intent = stripe.PaymentIntent.create(
        amount=template_price,
        currency="usd",
        customer=get_stripe_customer_id(buyer_id),
        payment_method=payment_method_id,
        application_fee_amount=platform_commission,  # Platform takes 15%
        transfer_data={
            "destination": creator["stripe_account_id"]  # Creator gets 85%
        },
        metadata={
            "qrcards_template_id": template_id,
            "qrcards_buyer_id": buyer_id,
            "qrcards_creator_id": template["creator_id"]
        },
        confirm=True  # Charge immediately
    )

    # Record sale in database
    await db.sales.insert_one({
        "template_id": template_id,
        "buyer_id": buyer_id,
        "creator_id": template["creator_id"],
        "amount": template_price,
        "platform_commission": platform_commission,
        "creator_amount": creator_amount,
        "stripe_payment_intent": payment_intent.id,
        "status": payment_intent.status,
        "created_at": datetime.now()
    })

    # Grant template access to buyer
    await grant_template_access(buyer_id, template_id)

    return {
        "success": True,
        "payment_intent_id": payment_intent.id,
        "status": payment_intent.status,
        "template_access_granted": True
    }
```

**Webhook Handling for Marketplace Events**:

```python
# app/routes/webhooks.py
from fastapi import APIRouter, Request, HTTPException
import stripe

router = APIRouter(prefix="/webhooks")

@router.post("/stripe")
async def stripe_webhook(request: Request):
    """Handle Stripe webhook events"""

    payload = await request.body()
    sig_header = request.headers.get("Stripe-Signature")

    try:
        event = stripe.Webhook.construct_event(
            payload, sig_header, STRIPE_WEBHOOK_SECRET
        )
    except ValueError:
        raise HTTPException(400, "Invalid payload")
    except stripe.error.SignatureVerificationError:
        raise HTTPException(400, "Invalid signature")

    # Handle different event types
    if event["type"] == "payment_intent.succeeded":
        await handle_successful_payment(event["data"]["object"])

    elif event["type"] == "payment_intent.payment_failed":
        await handle_failed_payment(event["data"]["object"])

    elif event["type"] == "account.updated":
        # Creator updated their Connect account
        await handle_account_update(event["data"]["object"])

    elif event["type"] == "transfer.created":
        # Platform commission transferred to creator
        await handle_creator_payout(event["data"]["object"])

    return {"status": "success"}

async def handle_successful_payment(payment_intent):
    """Process successful template purchase"""

    # Update sale record
    await db.sales.update_one(
        {"stripe_payment_intent": payment_intent.id},
        {"$set": {
            "status": "completed",
            "completed_at": datetime.now()
        }}
    )

    # Send confirmation emails
    sale = await db.sales.find_one({"stripe_payment_intent": payment_intent.id})
    await send_buyer_confirmation(sale)
    await send_creator_sale_notification(sale)

    # Track analytics
    await track_marketplace_sale(sale)
```

---

### Phase 3: Subscription Billing (Week 3, 16 hours)

**Premium Features Subscription**:

```python
# app/routes/subscriptions.py
from fastapi import APIRouter
import stripe

router = APIRouter(prefix="/subscriptions")

# Create subscription products in Stripe (one-time setup)
PREMIUM_PLANS = {
    "basic": {
        "stripe_price_id": "price_basic_monthly",
        "amount": 1500,  # $15/month
        "features": ["custom_domain", "analytics", "api_access"]
    },
    "pro": {
        "stripe_price_id": "price_pro_monthly",
        "amount": 4900,  # $49/month
        "features": ["basic", "white_label", "priority_support", "advanced_analytics"]
    },
    "enterprise": {
        "stripe_price_id": "price_enterprise_monthly",
        "amount": 9900,  # $99/month
        "features": ["pro", "custom_integrations", "dedicated_support", "sla"]
    }
}

@router.post("/create-subscription")
async def create_subscription(user_id: str, plan: str):
    """Subscribe user to premium plan"""

    if plan not in PREMIUM_PLANS:
        raise HTTPException(400, "Invalid plan")

    user = await db.users.find_one({"id": user_id})
    customer_id = user.get("stripe_customer_id")

    # Create Stripe customer if doesn't exist
    if not customer_id:
        customer = stripe.Customer.create(
            email=user["email"],
            metadata={"qrcards_user_id": user_id}
        )
        customer_id = customer.id

        await db.users.update_one(
            {"id": user_id},
            {"$set": {"stripe_customer_id": customer_id}}
        )

    # Create subscription
    subscription = stripe.Subscription.create(
        customer=customer_id,
        items=[{"price": PREMIUM_PLANS[plan]["stripe_price_id"]}],
        metadata={
            "qrcards_user_id": user_id,
            "qrcards_plan": plan
        }
    )

    # Update user record
    await db.users.update_one(
        {"id": user_id},
        {"$set": {
            "subscription_id": subscription.id,
            "plan": plan,
            "subscription_status": subscription.status,
            "current_period_end": datetime.fromtimestamp(subscription.current_period_end)
        }}
    )

    return {
        "subscription_id": subscription.id,
        "status": subscription.status,
        "current_period_end": subscription.current_period_end
    }
```

---

### Phase 4: Usage-Based Billing (Week 4, 16 hours)

**Metered API Calls and QR Generations**:

```python
# app/services/usage_tracking.py
import stripe
from datetime import datetime

class UsageTracker:
    """Track and bill for API usage beyond free tier"""

    def __init__(self):
        self.free_tier_limits = {
            "api_calls": 1000,      # 1K free per month
            "qr_generations": 500   # 500 free per month
        }

        self.metered_pricing = {
            "api_calls": "price_api_calls_metered",      # $0.01 per call
            "qr_generations": "price_qr_gen_metered"     # $0.05 per generation
        }

    async def track_usage(self, user_id: str, usage_type: str, quantity: int = 1):
        """Track usage event and bill if exceeds free tier"""

        # Get user's current usage this billing period
        usage = await db.usage.find_one({
            "user_id": user_id,
            "period_start": {"$lte": datetime.now()},
            "period_end": {"$gte": datetime.now()}
        })

        if not usage:
            # Create new usage period
            usage = await self.create_usage_period(user_id)

        # Increment usage
        current_usage = usage.get(usage_type, 0)
        new_usage = current_usage + quantity

        await db.usage.update_one(
            {"_id": usage["_id"]},
            {"$set": {usage_type: new_usage}}
        )

        # Check if exceeded free tier
        if current_usage < self.free_tier_limits[usage_type] <= new_usage:
            # Just crossed into metered territory
            await self.enable_metered_billing(user_id, usage_type)

        # Report usage to Stripe (if metered billing enabled)
        if new_usage > self.free_tier_limits[usage_type]:
            await self.report_usage_to_stripe(
                user_id,
                usage_type,
                quantity  # Only bill for overage
            )

    async def report_usage_to_stripe(self, user_id: str, usage_type: str, quantity: int):
        """Report metered usage to Stripe for billing"""

        user = await db.users.find_one({"id": user_id})
        subscription_item_id = user.get(f"{usage_type}_subscription_item")

        if not subscription_item_id:
            return  # User doesn't have metered billing set up

        # Create usage record in Stripe
        stripe.SubscriptionItem.create_usage_record(
            subscription_item_id,
            quantity=quantity,
            timestamp=int(datetime.now().timestamp()),
            action="increment"
        )
```

---

### Phase 5: Payment Abstraction Layer (Week 5-6, 40 hours)

**Why QRCards Needs Abstraction (Intelligence Portal Doesn't)**:

QRCards is targeting $100K+ MRR and complex marketplace functionality. At scale:
- **Multi-provider failover**: 5% of transactions fail, need backup processor
- **Rate negotiation**: At $1M+ annual processing, can negotiate Stripe 2.9% → 2.5% OR switch to Adyen
- **International optimization**: Some countries prefer PayPal, Alipay, local methods
- **Risk management**: Don't lose all revenue if Stripe has outage

**Abstraction Layer Architecture**:

```python
# app/services/payment_provider.py
from abc import ABC, abstractmethod
from typing import Optional, Dict

class PaymentProvider(ABC):
    """Abstract payment provider interface"""

    @abstractmethod
    async def create_marketplace_charge(
        self,
        amount: int,
        creator_account_id: str,
        platform_commission: int,
        metadata: Dict
    ) -> str:
        """Create marketplace charge with commission split"""
        pass

    @abstractmethod
    async def create_subscription(
        self,
        customer_id: str,
        plan_id: str,
        metadata: Dict
    ) -> str:
        """Create subscription for premium features"""
        pass

    @abstractmethod
    async def track_metered_usage(
        self,
        subscription_item_id: str,
        quantity: int
    ):
        """Report metered usage for billing"""
        pass

    @abstractmethod
    async def verify_webhook(
        self,
        payload: bytes,
        signature: str
    ) -> Dict:
        """Verify and parse webhook event"""
        pass

class StripeProvider(PaymentProvider):
    """Stripe implementation (primary)"""

    async def create_marketplace_charge(self, amount, creator_account_id, platform_commission, metadata):
        import stripe

        payment_intent = stripe.PaymentIntent.create(
            amount=amount,
            currency="usd",
            application_fee_amount=platform_commission,
            transfer_data={"destination": creator_account_id},
            metadata=metadata
        )

        return payment_intent.id

    async def create_subscription(self, customer_id, plan_id, metadata):
        import stripe

        subscription = stripe.Subscription.create(
            customer=customer_id,
            items=[{"price": plan_id}],
            metadata=metadata
        )

        return subscription.id

    # ... implement other methods

class PayPalProvider(PaymentProvider):
    """PayPal implementation (backup/alternative)"""

    async def create_marketplace_charge(self, amount, creator_account_id, platform_commission, metadata):
        # PayPal marketplace API implementation
        # Different API, same interface
        pass

    # ... implement other methods

# Usage in application
payment_provider: PaymentProvider = StripeProvider()  # Easy to swap

@app.post("/marketplace/purchase")
async def purchase_template(template_id: str, buyer_id: str):
    # Business logic doesn't know about Stripe vs PayPal
    payment_id = await payment_provider.create_marketplace_charge(
        amount=2000,
        creator_account_id=get_creator_account(template_id),
        platform_commission=300,
        metadata={"template_id": template_id}
    )

    return {"payment_id": payment_id}
```

**Abstraction Layer Benefits**:
- Swap Stripe → Adyen in 1 day (not 2 weeks)
- Add PayPal as secondary in 3 days (not from scratch)
- Negotiate better rates with leverage ("we can switch")
- Test new providers without refactoring entire codebase

**Cost**: 40 hours upfront, saves 200+ hours future migration

---

## Migration Strategy (Future 2027+)

### When to Consider Switching from Stripe

**Migration Triggers** (any one):
1. **Volume threshold**: >$1M annual processing, negotiate Stripe 2.9% → 2.5% OR switch to Adyen (1% + interchange = ~2.2%)
2. **International optimization**: >40% international revenue, Adyen has better local payment method coverage
3. **Rate negotiation leverage**: Stripe won't negotiate, Adyen offers 0.4% savings = $4K/year on $1M
4. **Feature gaps**: Need something Stripe doesn't offer (rare)

**Migration Complexity with Abstraction Layer**: 40 hours (vs 200+ without)
- New provider implementation: 20 hours
- Testing and validation: 10 hours
- Gradual rollout: 5 hours
- Creator migration: 5 hours

**Migration Cost-Benefit at $1M Annual Processing**:
- Stripe: 2.9% = $29,000/year
- Adyen (negotiated): 2.2% = $22,000/year
- **Savings**: $7,000/year
- **Migration cost**: 40 hours @ $100/hr = $4,000
- **Payback**: 7 months

---

## Risk Assessment & Mitigation

### Technical Risks

**Marketplace Complexity** (High Risk)
- *Issue*: Two-sided payments, commission splits, creator payouts more complex than simple purchases
- *Mitigation*: Stripe Connect is mature platform (used by Shopify, DoorDash, Instacart), thorough testing with test creators
- *Timeline*: 80-120 hours implementation includes buffer for complexity

**Creator Onboarding Friction** (Medium Risk)
- *Issue*: Creators must complete Stripe Connect onboarding (identity verification, bank account)
- *Mitigation*: Standard Stripe Connect (creators control their accounts), clear onboarding UI, support for questions
- *Monitoring*: Track onboarding completion rates, identify drop-off points

**Payout Delays** (Medium Risk)
- *Issue*: Stripe has 7-day rolling payout schedule, creators may expect instant payment
- *Mitigation*: Clear communication of payout timeline, option for instant payout (1% fee) for creators who need it
- *Alternative*: Explore Stripe Instant Payouts for premium creators

**Tax Compliance** (High Risk)
- *Issue*: Marketplace tax obligations complex (platform commission taxed, creator portion taxed separately)
- *Mitigation*: Stripe Tax handles calculations ($500/year), consult tax attorney for platform structure, monitor regulatory changes
- *Threshold*: When marketplace GMV >$100K/year, hire part-time tax specialist

### Business Risks

**Creator Payment Disputes** (Medium Risk)
- *Issue*: Buyers request refunds, chargebacks, quality disputes
- *Mitigation*: Clear terms of service, creator quality standards, dispute resolution process, escrow for large purchases
- *Reserve*: 5-10% of marketplace volume for refunds/chargebacks

**Platform Commission Optimization** (Low Risk)
- *Issue*: 15% commission may be too high (creator churn) or too low (platform sustainability)
- *Mitigation*: Start at 15%, monitor creator feedback, A/B test 10% vs 20% with different creator segments
- *Benchmark*: Shopify (2.9% + $0.30 + 2% cashout), Gumroad (10%), Etsy (6.5% + payment fees)

**Stripe Dependency** (Low Risk)
- *Issue*: Single provider risk (outages, rate increases, policy changes)
- *Mitigation*: Abstraction layer enables provider switch in 40 hours, monitor alternative providers, maintain PayPal as backup for simple purchases
- *Trigger*: If Stripe processes >80% of volume, add secondary provider

---

## Success Metrics (Q1-Q4 2026)

### Q1 2026 (Implementation)
- **Setup complete**: Stripe + Connect + Tax configured (80-120 hours)
- **Creator onboarding**: 10+ test creators complete Connect onboarding
- **First marketplace sale**: Successful template purchase with commission split
- **Subscription pilot**: 5-10 premium subscribers

### Q2 2026 (Growth)
- **Marketplace GMV**: $5K-10K (template sales)
- **Subscription MRR**: $500-1,500 (premium features)
- **Usage-based revenue**: $200-500 (API/QR overage)
- **Creator payout success**: 99%+ successful payouts on schedule

### Q3 2026 (Scale)
- **Marketplace GMV**: $20K-50K
- **Subscription MRR**: $3K-8K
- **Usage-based revenue**: $1K-3K
- **Total MRR**: $5K-15K

### Q4 2026 (Optimization)
- **Marketplace GMV**: $50K-100K
- **Subscription MRR**: $10K-25K
- **Usage-based revenue**: $3K-8K
- **Total MRR**: $15K-40K
- **Rate negotiation**: If >$1M annual, negotiate Stripe discount or evaluate Adyen

---

## Coordination with Intelligence Portal Payment Integration

### Shared Infrastructure

**Same FastAPI Codebase**:
- Intelligence Portal: Lemon Squeezy (simple purchases, Oct 2025)
- QRCards: Stripe with Connect (marketplace, Q1 2026)
- Shared: Database, email, analytics, webhook patterns

**Divergent Needs**:
- **Intelligence Portal**: One-time purchases, content access, speed to revenue
- **QRCards**: Marketplace, subscriptions, usage-based, creator payouts

**Timeline Benefits**:
- Intelligence Portal goes first (Oct 2025): Learn payment integration patterns
- QRCards builds on lessons (Q1 2026): Reuse webhook handling, email templates, analytics tracking
- Abstraction layer (QRCards): Later applied to intelligence portal if migrating from Lemon Squeezy

**Cost Optimization**:
- Single Stripe account for both (if possible)
- Shared tax service (Stripe Tax covers both)
- Common customer database (if user has both products)
- Unified analytics (revenue tracking across products)

---

## Next Steps

### Immediate (Oct 2025 - Deferred)
- [ ] No action on QRCards payment (Round 4 decision: defer to Q1 2026)
- [ ] Focus on Intelligence Portal (Lemon Squeezy, Oct 17-25)
- [ ] QRCards remains at Level 3.5 (demonstrations, no monetization)

### Pre-Implementation (Dec 2025)
- [ ] Review Stripe documentation for Connect + Billing
- [ ] Design creator onboarding flow (wireframes, UX)
- [ ] Draft marketplace terms of service
- [ ] Plan commission structure (15% baseline, test variations)

### Implementation (Q1 2026)
- [ ] Week 1: Stripe + Connect setup (12 hours)
- [ ] Week 2: Marketplace payment flow (20 hours)
- [ ] Week 3: Subscription billing (16 hours)
- [ ] Week 4: Usage-based billing (16 hours)
- [ ] Week 5-6: Abstraction layer (40 hours)
- [ ] **Total**: 104 hours over 6 weeks

### Post-Launch (Q2 2026+)
- [ ] Monitor marketplace GMV growth
- [ ] Track creator payout success rates
- [ ] Optimize commission structure based on data
- [ ] Add secondary payment provider (PayPal) at $50K GMV
- [ ] Negotiate Stripe rates at $1M annual processing

---

## Conclusion

**QRCards payment integration should use Stripe with Stripe Connect** for marketplace functionality (two-sided payments, creator payouts, commission splits) that no other provider supports at comparable quality. The 80-120 hour implementation investment (including abstraction layer) is justified by:

1. **Marketplace requirement**: Connect is only viable solution for QRCards business model
2. **Deferred timeline**: Q1 2026 allows time for proper implementation (vs Intelligence Portal's Oct urgency)
3. **Scale trajectory**: Targeting $100K+ MRR by end 2026, needs enterprise-grade foundation
4. **Future-proofing**: Abstraction layer reduces migration from 200+ hours to 40 hours

**Implementation confidence**: Medium-High (Stripe Connect is complex but well-documented, many marketplace examples, 104-hour budget realistic)

**Strategic alignment**: Executes Round 4 strategy (defer QRCards to Q1 2026, focus on Intelligence Portal revenue first, build QRCards payment from position of stability)

**Risk level**: Medium (marketplace complexity higher than simple purchases, but Stripe Connect mature and proven at scale)

**Different from Intelligence Portal because**:
- Intelligence Portal: Simple purchases, speed critical, Lemon Squeezy optimal
- QRCards: Complex marketplace, proper foundation critical, Stripe Connect required

---

**Date compiled**: October 7, 2025
**Application**: QRCards Platform
**Confidence level**: 85% (MPSE analysis applied to marketplace-specific requirements, implementation plan validated against Stripe Connect documentation)
